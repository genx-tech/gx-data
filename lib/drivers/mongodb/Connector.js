"use strict";const{_,waitUntil_}=require("rk-utils");const{tryRequire}=require("../../utils/lib");const mongodb=tryRequire("mongodb");const{MongoClient,GridFSBucket}=mongodb;const Connector=require("../../Connector");const UpdateOpsField=["$currentDate","$inc","$min","$max","$mul","$rename","$set","$setOnInsert","$unset"];const UpdateOpsArray=["$addToSet","$pop","$pull","$push","$pullAll"];const UpdateOps=UpdateOpsField.concat(UpdateOpsArray);class MongodbConnector extends Connector{constructor(connectionString,options){super("mongodb",connectionString,options);this.findAll_=this.find_}async end_(){if(this.client&&this.client.isConnected()){await this.client.close()}delete this.client}async connect_(options){if(!this.client||!this.client.isConnected()){let client=new MongoClient(this.connectionString,{useNewUrlParser:true});this.client=await client.connect()}return this.client.db(this.database)}async disconnect_(conn){}async ping_(){return this.execute_(db=>{return db.listCollections(null,{nameOnly:true}).toArray()})}async execute_(dbExecutor){let db;try{db=await this.connect_();return await dbExecutor(db)}catch(err){throw err}finally{db&&(await this.disconnect_(db))}}async createGridFSBucket_(options){let db=await this.connect_();return new GridFSBucket(db,options)}async insertOne_(model,data,options){return this.onCollection_(model,coll=>coll.insertOne(data,{bypassDocumentValidation:true,...options}))}async insertMany_(model,data,options){return this.onCollection_(model,coll=>coll.insertMany(data,{bypassDocumentValidation:true,ordered:false,...options}))}async insertOneIfNotExist_(model,data,options){try{return await this.insertOne_(model,data,options)}catch(error){if(error.code===11000){return false}throw error}}async findOneAndReplace_(model,data,condition,options){return this.onCollection_(model,coll=>coll.findOneAndReplace(condition,data,options))}async findOneAndUpdate_(model,data,condition,options){return this.onCollection_(model,coll=>coll.findOneAndUpdate(condition,this._translateUpdate(data),options))}async findOneAndDelete_(model,condition,options){return this.onCollection_(model,coll=>coll.findOneAndDelete(condition,options))}async findOne_(model,condition,options){return this.onCollection_(model,coll=>coll.findOne(condition,options))}async updateOne_(model,data,condition,options){return this.onCollection_(model,coll=>coll.updateOne(condition,this._translateUpdate(data),options))}async upsertOne_(model,data,condition,options,retry){return this.onCollection_(model,async coll=>{let current,locked=false;try{do{current=await coll.findOneAndUpdate(condition,{$set:{__lock__:true}})}while(current.value&&current.value.__lock__);if(current.value){locked=true;return await coll.updateOne({_id:current.value._id},{$set:_.omit(data,["_id"]),$unset:{__lock__:""}},{bypassDocumentValidation:true,...options})}try{return await coll.insertOne(data,{bypassDocumentValidation:true,...options})}catch(error2){if(!retry&&error2.message.startsWith("E11000 duplicate key error")){return this.upsertOne_(model,data,condition,options,true)}throw error2}}catch(error){if(locked){await coll.updateOne({_id:current.value._id},{$unset:{__lock__:""}})}throw error}})}async upsertMany_(model,data,uniqueKeys,options){let ops=data.map(record=>{let{_id,...updateData}=record;let updateOp={$set:updateData};if(_id){updateOp.$setOnInsert={_id}}return{updateOne:{filter:{..._.pick(record,uniqueKeys)},update:updateOp,upsert:true}}});return this.onCollection_(model,coll=>coll.bulkWrite(ops,{bypassDocumentValidation:true,ordered:false,...options}))}async insertManyIfNotExist_(model,data,uniqueKeys,options){let ops=data.map(record=>({updateOne:{filter:{..._.pick(record,uniqueKeys)},update:{$setOnInsert:record},upsert:true}}));return this.onCollection_(model,coll=>coll.bulkWrite(ops,{bypassDocumentValidation:true,ordered:false,...options}))}async updateMany_(model,data,condition,options){return this.onCollection_(model,coll=>coll.updateMany(condition,this._translateUpdate(data),options))}async replaceOne_(model,data,condition,options){return this.onCollection_(model,coll=>coll.replaceOne(condition,data,options))}async deleteOne_(model,condition,options){return this.onCollection_(model,coll=>coll.deleteOne(condition,options))}async deleteMany_(model,condition,options){return this.onCollection_(model,coll=>coll.deleteMany(condition,options))}async find_(model,condition,options){return this.onCollection_(model,async coll=>{let queryOptions={...options};let query={};if(condition){let{$projection,$orderBy,$offset,$limit,$query,...others}=condition;if($projection){queryOptions.projection=$projection}if($orderBy){queryOptions.sort=$orderBy}if($offset){queryOptions.skip=$offset}if($limit){queryOptions.limit=$limit}Object.assign(query,_.pickBy(others,(v,k)=>k[0]!=="$"));if($query){Object.assign(query,$query)}}let result=await coll.find(query,queryOptions).toArray();if(condition&&condition.$totalCount){let totalCount=await coll.find(query).count();return[result,totalCount]}return result})}async onCollection_(model,executor){return this.execute_(db=>executor(db.collection(model)))}_translateUpdate(update){let ops=_.pick(update,UpdateOps);let others=_.omit(update,UpdateOps);if(ops.$set){ops.$set={...ops.$set,...others}}else if(!_.isEmpty(others)){ops.$set=others}return ops}}module.exports=MongodbConnector;