{"version":3,"file":"EntityModel.js","names":["_","eachAsync_","require","EntityModel","ApplicationError","ReferencedNotExistError","DuplicateError","ValidationError","InvalidArgument","Types","getValueFrom","mapFilter","defaultNestedKeyGetter","anchor","MySQLEntityModel","hasAutoIncrement","autoId","meta","features","fields","field","autoIncrementId","getNestedObject","entityObj","keyPath","get","split","map","p","join","_translateSymbolToken","name","db","connector","raw","Error","_serializeByTypeInfo","value","info","type","DATETIME","serialize","Array","isArray","csv","ARRAY","toCsv","OBJECT","create_","args","error","errorCode","code","message","updateOne_","_doReplaceOne_","context","ensureTransaction_","entity","findOne_","$query","options","connOptions","ret","$retrieveExisting","rawOptions","$existing","keyField","valueOfKey","omit","$retrieveCreated","$retrieveUpdated","$result","_internalBeforeCreate_","_fillResult","result","affectedRows","insertId","latest","upsert","return","_internalAfterCreate_","$retrieveDbResult","queryKey","getUniqueKeyValuePairsFrom","isEmpty","retrieveOptions","isPlainObject","_internalBeforeUpdate_","_internalBeforeUpdateMany_","_internalAfterUpdate_","changedRows","retrieveUpdated","$retrieveActualUpdated","$retrieveNotUpdate","condition","$bypassEnsureUnique","$relationships","$includeDeleted","$retrieveDeleted","_internalAfterUpdateMany_","findAll_","_internalBeforeDelete_","$physicalDeletion","existing","_internalBeforeDeleteMany_","_internalAfterDelete_","_internalAfterDeleteMany_","_prepareAssociations","findOptions","normalAssocs","customAssocs","partition","$association","assoc","associations","uniq","sort","concat","assocTable","counter","cache","forEach","_translateSchemaNameToDb","alias","joinType","output","key","on","dataset","buildQuery","model","_prepareQueries","$variables","_loadAssocIntoTable","lastPos","lastIndexOf","assocInfo","base","substr","last","baseNode","subAssocs","currentDb","indexOf","schemaName","entityName","app","refDb","database","_mapRecordsToObjects","rows","columns","aliasMap","hierarchy","nestedKeyGetter","mapValues","chain","mainIndex","self","col","table","pos","mergeRecord","existingRow","rowObject","nodePath","each","sql","list","currentPath","push","objKey","subObj","subIndexes","rowKeyValue","isNil","existingSubRow","subIndex","buildSubIndexes","indexes","subObject","arrayOfObjs","tableTemplate","reduce","bucket","row","tableCache","colIdx","forOwn","obj","set","rowKey","_extractAssociations","data","isNew","assocs","refs","v","k","assocMeta","assocAnchor","_populateReferences_","references","refQuery","ReferencedEntity","created","JSON","stringify","_createAssocs_","beforeEntityCreate","keyValue","query","pendingAssocs","finished","passOnOptions","pick","assocModel","castArray","item","assocQuery","refFieldValue","localField","_updateAssocs_","beforeEntityUpdate","forSingleRecord","currentKeyValue","assocKeys","record","assocRecordsToRemove","length","$notIn","deleteMany_","destEntityId","sugar","Object","keys","module","exports"],"sources":["../../../src/drivers/mysql/EntityModel.js"],"sourcesContent":["const { _, eachAsync_ } = require('@genx/july');\nconst EntityModel = require('../../EntityModel');\nconst {\n    ApplicationError,\n    ReferencedNotExistError,\n    DuplicateError,\n    ValidationError,\n    InvalidArgument,\n} = require('../../utils/Errors');\nconst Types = require('../../types');\nconst { getValueFrom, mapFilter } = require('../../utils/lang');\n\nconst defaultNestedKeyGetter = (anchor) => ':' + anchor;\n\n/**\n * MySQL entity model class.\n */\nclass MySQLEntityModel extends EntityModel {\n    /**\n     * [specific] Check if this entity has auto increment feature.\n     */\n    static get hasAutoIncrement() {\n        const autoId = this.meta.features.autoId;\n        return autoId && this.meta.fields[autoId.field].autoIncrementId;\n    }\n\n    /**\n     * [override]\n     * @param {*} entityObj\n     * @param {*} keyPath\n     */\n    static getNestedObject(entityObj, keyPath) {\n        return _.get(\n            entityObj,\n            keyPath\n                .split('.')\n                .map((p) => ':' + p)\n                .join('.')\n        );\n    }\n\n    /**\n     * [override] Serialize value into database acceptable format.\n     * @param {object} name - Name of the symbol token\n     */\n    static _translateSymbolToken(name) {\n        if (name === 'NOW') {\n            return this.db.connector.raw('NOW()');\n        }\n\n        throw new Error('not support: ' + name);\n    }\n\n    /**\n     * [override]\n     * @param {*} value\n     * @param {*} info\n     */\n    static _serializeByTypeInfo(value, info) {\n        if (info.type === 'boolean') {\n            return value ? 1 : 0;\n        }\n\n        if (info.type === 'datetime') {\n            return Types.DATETIME.serialize(value);\n        }\n\n        if (info.type === 'array' && Array.isArray(value)) {\n            if (info.csv) {\n                return Types.ARRAY.toCsv(value);\n            } else {\n                return Types.ARRAY.serialize(value);\n            }\n        }\n\n        if (info.type === 'object') {\n            return Types.OBJECT.serialize(value);\n        }\n\n        return value;\n    }\n\n    static async create_(...args) {\n        try {\n            return await super.create_(...args);\n        } catch (error) {\n            const errorCode = error.code;\n\n            if (errorCode === 'ER_NO_REFERENCED_ROW_2') {\n                throw new ReferencedNotExistError(\n                    'The new entity is referencing to an unexisting entity. Detail: ' +\n                        error.message,\n                    error.info\n                );\n            } else if (errorCode === 'ER_DUP_ENTRY') {\n                throw new DuplicateError(\n                    error.message +\n                        ` while creating a new \"${this.meta.name}\".`,\n                    error.info\n                );\n            }\n\n            throw error;\n        }\n    }\n\n    static async updateOne_(...args) {\n        try {\n            return await super.updateOne_(...args);\n        } catch (error) {\n            const errorCode = error.code;\n\n            if (errorCode === 'ER_NO_REFERENCED_ROW_2') {\n                throw new ReferencedNotExistError(\n                    'The entity to be updated is referencing to an unexisting entity. Detail: ' +\n                        error.message,\n                    error.info\n                );\n            } else if (errorCode === 'ER_DUP_ENTRY') {\n                throw new DuplicateError(\n                    error.message +\n                        ` while updating an existing \"${this.meta.name}\".`,\n                    error.info\n                );\n            }\n\n            throw error;\n        }\n    }\n\n    static async _doReplaceOne_(context) {\n        await this.ensureTransaction_(context);\n\n        const entity = await this.findOne_(\n            { $query: context.options.$query },\n            context.connOptions\n        );\n\n        let ret, options;\n\n        if (entity) {\n            if (context.options.$retrieveExisting) {\n                context.rawOptions.$existing = entity;\n            }\n\n            options = {\n                ...context.options,\n                $query: { [this.meta.keyField]: super.valueOfKey(entity) },\n                $existing: entity,\n            };\n\n            ret = await this.updateOne_(\n                context.raw,\n                options,\n                context.connOptions\n            );\n        } else {\n            options = {\n                ..._.omit(context.options, [\n                    '$retrieveUpdated',\n                    '$bypassEnsureUnique',\n                ]),\n                $retrieveCreated: context.options.$retrieveUpdated,\n            };\n\n            ret = await this.create_(context.raw, options, context.connOptions);\n        }\n\n        if (options.$existing) {\n            context.rawOptions.$existing = options.$existing;\n        }\n\n        if (options.$result) {\n            context.rawOptions.$result = options.$result;\n        }\n\n        return ret;\n    }\n\n    static _internalBeforeCreate_(context) {\n        return true;\n    }\n\n    static _fillResult(context) {\n        if (this.hasAutoIncrement && context.result.affectedRows > 0) {\n            const { insertId } = context.result;\n            if (insertId > 0) {\n                context.latest = {\n                    ...context.latest,\n                    [this.meta.features.autoId.field]: insertId,\n                };\n            } else if (context.result.upsert) {\n                // the key is not correct \n                delete context.latest[this.meta.features.autoId.field];\n            }\n        } else if (context.result.upsert) {\n            // the key is not used \n            delete context.latest[this.meta.keyField];\n        }\n\n        context.return = context.latest;\n    }\n\n    /**\n     * Post create processing.\n     * @param {*} context\n     * @property {object} [context.options] - Create options\n     * @property {bool} [options.$retrieveCreated] - Retrieve the newly created record from db.\n     */\n    static async _internalAfterCreate_(context) {\n        if (context.options.$retrieveDbResult) {\n            context.rawOptions.$result = context.result;\n        }\n\n        if (context.options.$retrieveCreated) {\n            if (this.hasAutoIncrement) {\n                if (context.result.affectedRows === 0) {\n                    // insert ignored\n                    context.queryKey = this.getUniqueKeyValuePairsFrom(\n                        context.latest\n                    );\n\n                    if (_.isEmpty(context.queryKey)) {\n                        throw new ApplicationError(\n                            'Cannot extract unique keys from input data.',\n                            {\n                                entity: this.meta.name,\n                            }\n                        );\n                    }\n                } else {\n                    const { insertId } = context.result;\n                    context.queryKey = {\n                        [this.meta.features.autoId.field]: insertId,\n                    };\n                }\n            } else {\n                context.queryKey = this.getUniqueKeyValuePairsFrom(\n                    context.latest\n                );\n\n                if (_.isEmpty(context.queryKey)) {\n                    throw new ApplicationError(\n                        'Cannot extract unique keys from input data.',\n                        {\n                            entity: this.meta.name,\n                        }\n                    );\n                }\n            }\n\n            const retrieveOptions = _.isPlainObject(\n                context.options.$retrieveCreated\n            )\n                ? context.options.$retrieveCreated\n                : {};\n            context.return = await this.findOne_(\n                { ...retrieveOptions, $query: context.queryKey },\n                context.connOptions\n            );\n        } else {\n            if (this.hasAutoIncrement) {\n                if (context.result.affectedRows === 0) {\n                    context.queryKey = this.getUniqueKeyValuePairsFrom(\n                        context.latest\n                    );\n                } else {\n                    const { insertId } = context.result;\n                    context.queryKey = {\n                        [this.meta.features.autoId.field]: insertId,\n                    };\n                }\n            }\n        }\n    }\n\n    static _internalBeforeUpdate_(context) {\n        return true;\n    }\n\n    static _internalBeforeUpdateMany_(context) {\n        return true;\n    }\n\n    /**\n     * Post update processing.\n     * @param {*} context\n     * @property {object} [context.options] - Update options\n     * @property {bool} [context.options.$retrieveUpdated] - Retrieve the newly updated record from db.\n     */\n    static async _internalAfterUpdate_(context) {\n        const options = context.options;\n\n        if (options.$retrieveDbResult) {\n            context.rawOptions.$result = context.result || {\n                affectedRows: 0,\n                changedRows: 0,\n            };\n        }\n\n        let retrieveUpdated = options.$retrieveUpdated;\n\n        if (!retrieveUpdated) {\n            if (\n                options.$retrieveActualUpdated &&\n                context.result.affectedRows > 0\n            ) {\n                retrieveUpdated = options.$retrieveActualUpdated;\n            } else if (\n                options.$retrieveNotUpdate &&\n                context.result.affectedRows === 0\n            ) {\n                retrieveUpdated = options.$retrieveNotUpdate;\n            }\n        }\n\n        if (retrieveUpdated) {\n            const condition = {\n                $query: this.getUniqueKeyValuePairsFrom(options.$query),\n            };\n            if (options.$bypassEnsureUnique) {\n                condition.$bypassEnsureUnique = options.$bypassEnsureUnique;\n            }\n\n            let retrieveOptions = {};\n\n            if (_.isPlainObject(retrieveUpdated)) {\n                retrieveOptions = retrieveUpdated;\n            } else if (options.$relationships) {\n                retrieveOptions.$relationships = options.$relationships;\n            }\n\n            context.return = await this.findOne_(\n                {\n                    ...condition,\n                    $includeDeleted: options.$retrieveDeleted,\n                    ...retrieveOptions,\n                },\n                context.connOptions\n            );\n\n            if (context.return) {\n                context.queryKey = this.getUniqueKeyValuePairsFrom(\n                    context.return\n                );\n            } else {\n                context.queryKey = condition.$query;\n            }\n        }\n    }\n\n    /**\n     * Post update processing.\n     * @param {*} context\n     * @param {object} [options] - Update options\n     * @property {bool} [options.$retrieveUpdated] - Retrieve the newly updated record from db.\n     */\n    static async _internalAfterUpdateMany_(context) {\n        const options = context.options;\n\n        if (options.$retrieveDbResult) {\n            context.rawOptions.$result = context.result || {\n                affectedRows: 0,\n                changedRows: 0,\n            };\n\n            /**\n             * afterUpdateMany ResultSetHeader {\n             * fieldCount: 0,\n             * affectedRows: 1,\n             * insertId: 0,\n             * info: 'Rows matched: 1  Changed: 1  Warnings: 0',\n             * serverStatus: 3,\n             * warningStatus: 0,\n             * changedRows: 1 }\n             */\n        }\n\n        if (options.$retrieveUpdated) {\n            let retrieveOptions = {};\n\n            if (_.isPlainObject(options.$retrieveUpdated)) {\n                retrieveOptions = options.$retrieveUpdated;\n            } else if (options.$relationships) {\n                retrieveOptions.$relationships = options.$relationships;\n            }\n\n            context.return = await this.findAll_(\n                {\n                    $query: options.$query,\n                    $includeDeleted: options.$retrieveDeleted,\n                    ...retrieveOptions,\n                },\n                context.connOptions\n            );\n        }\n\n        context.queryKey = options.$query;\n    }\n\n    /**\n     * Before deleting an entity.\n     * @param {*} context\n     * @property {object} [context.options] - Delete options\n     * @property {bool} [context.options.$retrieveDeleted] - Retrieve the recently deleted record from db.\n     */\n    static async _internalBeforeDelete_(context) {\n        if (context.options.$retrieveDeleted) {\n            await this.ensureTransaction_(context);\n\n            const retrieveOptions = _.isPlainObject(\n                context.options.$retrieveDeleted\n            )\n                ? {\n                      ...context.options.$retrieveDeleted,\n                      $query: context.options.$query,\n                  }\n                : { $query: context.options.$query };\n\n            if (context.options.$physicalDeletion) {\n                retrieveOptions.$includeDeleted = true;\n            }\n\n            context.return = context.existing = await this.findOne_(\n                retrieveOptions,\n                context.connOptions\n            );\n        }\n\n        return true;\n    }\n\n    static async _internalBeforeDeleteMany_(context) {\n        if (context.options.$retrieveDeleted) {\n            await this.ensureTransaction_(context);\n\n            const retrieveOptions = _.isPlainObject(\n                context.options.$retrieveDeleted\n            )\n                ? {\n                      ...context.options.$retrieveDeleted,\n                      $query: context.options.$query,\n                  }\n                : { $query: context.options.$query };\n\n            if (context.options.$physicalDeletion) {\n                retrieveOptions.$includeDeleted = true;\n            }\n\n            context.return = context.existing = await this.findAll_(\n                retrieveOptions,\n                context.connOptions\n            );\n        }\n\n        return true;\n    }\n\n    /**\n     * Post delete processing.\n     * @param {*} context\n     */\n    static _internalAfterDelete_(context) {\n        if (context.options.$retrieveDbResult) {\n            context.rawOptions.$result = context.result;\n        }\n    }\n\n    /**\n     * Post delete processing.\n     * @param {*} context\n     */\n    static _internalAfterDeleteMany_(context) {\n        if (context.options.$retrieveDbResult) {\n            context.rawOptions.$result = context.result;\n        }\n    }\n\n    /**\n     *\n     * @param {*} findOptions\n     */\n    static _prepareAssociations(findOptions) {\n        const [normalAssocs, customAssocs] = _.partition(\n            findOptions.$association,\n            (assoc) => typeof assoc === 'string'\n        );\n\n        const associations = _.uniq(normalAssocs).sort().concat(customAssocs);\n        const assocTable = {};\n            let counter = 0;\n            const cache = {};\n\n        associations.forEach((assoc) => {\n            if (_.isPlainObject(assoc)) {\n                assoc = this._translateSchemaNameToDb(assoc);\n\n                let alias = assoc.alias;\n                if (!assoc.alias) {\n                    alias = ':join' + ++counter;\n                }\n\n                assocTable[alias] = {\n                    entity: assoc.entity,\n                    joinType: assoc.type,\n                    output: assoc.output,\n                    key: assoc.key,\n                    alias,\n                    on: assoc.on,\n                    ...(assoc.dataset\n                        ? this.db.connector.buildQuery(\n                              assoc.entity,\n                              assoc.model._prepareQueries({\n                                  ...assoc.dataset,\n                                  $variables: findOptions.$variables,\n                              })\n                          )\n                        : {}),\n                };\n            } else {\n                this._loadAssocIntoTable(assocTable, cache, assoc);\n            }\n        });\n\n        return assocTable;\n    }\n\n    /**\n     *\n     * @param {*} assocTable - Hierarchy with subAssocs\n     * @param {*} cache - Dotted path as key\n     * @param {*} assoc - Dotted path\n     */\n    static _loadAssocIntoTable(assocTable, cache, assoc) {\n        if (cache[assoc]) return cache[assoc];\n\n        const lastPos = assoc.lastIndexOf('.');\n        let result;\n\n        if (lastPos === -1) {\n            // direct association\n            const assocInfo = { ...this.meta.associations[assoc] };\n            if (_.isEmpty(assocInfo)) {\n                throw new InvalidArgument(\n                    `Entity \"${this.meta.name}\" does not have the association \"${assoc}\".`\n                );\n            }\n\n            result =\n                cache[assoc] =\n                assocTable[assoc] =\n                    { ...this._translateSchemaNameToDb(assocInfo) };\n        } else {\n            const base = assoc.substr(0, lastPos);\n            const last = assoc.substr(lastPos + 1);\n\n            let baseNode = cache[base];\n            if (!baseNode) {\n                baseNode = this._loadAssocIntoTable(assocTable, cache, base);\n            }\n\n            const entity = baseNode.model || this.db.model(baseNode.entity);\n            const assocInfo = { ...entity.meta.associations[last] };\n            if (_.isEmpty(assocInfo)) {\n                throw new InvalidArgument(\n                    `Entity \"${entity.meta.name}\" does not have the association \"${assoc}\".`\n                );\n            }\n\n            result = { ...entity._translateSchemaNameToDb(assocInfo, this.db) };\n\n            if (!baseNode.subAssocs) {\n                baseNode.subAssocs = {};\n            }\n\n            cache[assoc] = baseNode.subAssocs[last] = result;\n        }\n\n        if (result.assoc) {\n            this._loadAssocIntoTable(\n                assocTable,\n                cache,\n                assoc + '.' + result.assoc\n            );\n        }\n\n        return result;\n    }\n\n    static _translateSchemaNameToDb(assoc, currentDb) {\n        if (!assoc.entity) {\n            throw new ApplicationError('\"entity\" is required in the association object.');\n        }\n\n        if (assoc.entity.indexOf('.') > 0) {\n            const [schemaName, entityName] = assoc.entity.split('.', 2);\n\n            const app = this.db.app;\n\n            const refDb = app.db(schemaName);\n            if (!refDb) {\n                throw new ApplicationError(\n                    `The referenced schema \"${schemaName}\" does not have db model in the same application.`\n                );\n            }\n\n            assoc.entity = refDb.connector.database + '.' + entityName;\n            assoc.model = refDb.model(entityName);\n\n            if (!assoc.model) {\n                throw new ApplicationError(\n                    `Failed load the entity model \"${schemaName}.${entityName}\".`\n                );\n            }\n        } else {\n            assoc.model = this.db.model(assoc.entity);\n\n            if (currentDb && currentDb !== this.db) {\n                assoc.entity = this.db.connector.database + '.' + assoc.entity;\n            }\n        }\n\n        if (!assoc.key) {\n            assoc.key = assoc.model.meta.keyField;\n        }\n\n        return assoc;\n    }\n\n    static _mapRecordsToObjects(\n        [rows, columns, aliasMap],\n        hierarchy,\n        nestedKeyGetter\n    ) {\n        nestedKeyGetter == null && (nestedKeyGetter = defaultNestedKeyGetter);\n        aliasMap = _.mapValues(aliasMap, (chain) =>\n            chain.map((anchor) => nestedKeyGetter(anchor))\n        );\n\n        const mainIndex = {};\n        const self = this;\n\n        // map mysql column result into array of { table <table alias>, name: <column name> }\n        columns = columns.map((col) => {\n            if (col.table === '') {\n                const pos = col.name.indexOf('$');\n                if (pos > 0) {\n                    return {\n                        table: col.name.substr(0, pos),\n                        name: col.name.substr(pos + 1),\n                    };\n                }\n\n                return {\n                    table: 'A',\n                    name: col.name,\n                };\n            }\n\n            return {\n                table: col.table,\n                name: col.name,\n            };\n        });\n\n        // map flat record into hierachy\n        function mergeRecord(existingRow, rowObject, associations, nodePath) {\n            return _.each(\n                associations,\n                ({ sql, key, list, subAssocs }, anchor) => {\n                    if (sql) return;\n\n                    const currentPath = nodePath.concat();\n                    currentPath.push(anchor);\n\n                    const objKey = nestedKeyGetter(anchor);\n                    const subObj = rowObject[objKey];\n\n                    if (!subObj) {\n                        // associated entity not in result set, probably when custom projection is used\n                        return;\n                    }\n\n                    const subIndexes = existingRow.subIndexes[objKey];\n\n                    // joined an empty record\n                    const rowKeyValue = subObj[key];\n                    if (_.isNil(rowKeyValue)) {\n                        if (list && rowKeyValue == null) {\n                            if (existingRow.rowObject[objKey]) {\n                                existingRow.rowObject[objKey].push(subObj);\n                            } else {\n                                existingRow.rowObject[objKey] = [subObj];\n                            }\n                        }\n\n                        return;\n                    }\n\n                    const existingSubRow = subIndexes && subIndexes[rowKeyValue];\n                    if (existingSubRow) {\n                        if (subAssocs) {\n                            return mergeRecord(\n                                existingSubRow,\n                                subObj,\n                                subAssocs,\n                                currentPath\n                            );\n                        }\n                    } else {\n                        if (!list) {\n                            throw new ApplicationError(\n                                `The structure of association \"${currentPath.join(\n                                    '.'\n                                )}\" with [key=${key}] of entity \"${\n                                    self.meta.name\n                                }\" should be a list.`,\n                                { existingRow, rowObject }\n                            );\n                        }\n\n                        if (existingRow.rowObject[objKey]) {\n                            existingRow.rowObject[objKey].push(subObj);\n                        } else {\n                            existingRow.rowObject[objKey] = [subObj];\n                        }\n\n                        const subIndex = {\n                            rowObject: subObj,\n                        };\n\n                        if (subAssocs) {\n                            subIndex.subIndexes = buildSubIndexes(\n                                subObj,\n                                subAssocs\n                            );\n                        }\n\n                        if (!subIndexes) {\n                            throw new ApplicationError(\n                                `The subIndexes of association \"${currentPath.join(\n                                    '.'\n                                )}\" with [key=${key}] of entity \"${\n                                    self.meta.name\n                                }\" does not exist.`,\n                                { existingRow, rowObject }\n                            );\n                        }\n\n                        subIndexes[rowKeyValue] = subIndex;\n                    }\n                }\n            );\n        }\n\n        // build sub index for list member\n        function buildSubIndexes(rowObject, associations) {\n            const indexes = {};\n\n            _.each(associations, ({ sql, key, list, subAssocs }, anchor) => {\n                if (sql) {\n                    return;\n                }\n\n                const objKey = nestedKeyGetter(anchor);\n                let subObject = rowObject[objKey];\n                const subIndex = {\n                    rowObject: subObject,\n                };\n\n                if (list) {\n                    if (!subObject) {\n                        // associated entity not in result set, probably when custom projection is used\n                        rowObject[objKey] = [];\n                        return;\n                    }\n\n                    rowObject[objKey] = [subObject];\n\n                    // many to *\n                    if (_.isNil(subObject[key])) {\n                        // when custom projection is used\n                        subObject = null;\n                    }\n                }\n\n                if (subObject) {\n                    if (subAssocs) {\n                        subIndex.subIndexes = buildSubIndexes(\n                            subObject,\n                            subAssocs\n                        );\n                    }\n\n                    indexes[objKey] = subObject[key]\n                        ? {\n                              [subObject[key]]: subIndex,\n                          }\n                        : {};\n                }\n            });\n\n            return indexes;\n        }\n\n        const arrayOfObjs = [];\n\n        // build the result object skeleton\n        const tableTemplate = columns.reduce((result, col) => {\n            if (col.table !== 'A') {\n                const bucket = result[col.table];\n                if (bucket) {\n                    bucket[col.name] = null;\n                } else {\n                    result[col.table] = { [col.name]: null };\n                }\n            }\n\n            return result;\n        }, {});\n\n        // process each row\n        rows.forEach((row) => {\n            const tableCache = {}; // from alias to child prop of rowObject\n\n            // hash-style data row\n            const rowObject = row.reduce((result, value, colIdx) => {\n                const col = columns[colIdx];\n\n                if (col.table === 'A') {\n                    result[col.name] = value;\n                } else if (value != null) {\n                    // avoid a object with all null value exists\n                    const bucket = tableCache[col.table];\n                    if (bucket) {\n                        // already nested inside\n                        bucket[col.name] = value;\n                    } else {\n                        tableCache[col.table] = {\n                            ...tableTemplate[col.table],\n                            [col.name]: value,\n                        };\n                    }\n                }\n\n                return result;\n            }, {});\n\n            _.forOwn(tableCache, (obj, table) => {\n                const nodePath = aliasMap[table];\n                _.set(rowObject, nodePath, obj);\n            });\n\n            const rowKey = rowObject[self.meta.keyField];\n            const existingRow = mainIndex[rowKey];\n            if (existingRow) {\n                return mergeRecord(existingRow, rowObject, hierarchy, []);\n            }\n\n            arrayOfObjs.push(rowObject);\n            mainIndex[rowKey] = {\n                rowObject,\n                subIndexes: buildSubIndexes(rowObject, hierarchy),\n            };\n        });\n\n        return arrayOfObjs;\n    }\n\n    /**\n     * Pre-process assoicated db operation\n     * @param {*} data\n     * @param {*} isNew - New record flag, true for creating, false for updating\n     * @returns {Array} [raw, assocs, refs];\n     */\n    static _extractAssociations(data, isNew) {\n        const raw = {};\n            const assocs = {};\n            const refs = {};\n        const meta = this.meta.associations;\n\n        _.forOwn(data, (v, k) => {\n            if (k[0] === ':') {\n                // cascade update\n                const anchor = k.substr(1);\n                const assocMeta = meta[anchor];\n                if (!assocMeta) {\n                    throw new ValidationError(\n                        `Unknown association \"${anchor}\" of entity \"${this.meta.name}\".`\n                    );\n                }\n\n                if (\n                    isNew &&\n                    (assocMeta.type === 'refersTo' ||\n                        assocMeta.type === 'belongsTo') &&\n                    anchor in data\n                ) {\n                    throw new ValidationError(\n                        `Association data \":${anchor}\" of entity \"${this.meta.name}\" conflicts with input value of field \"${anchor}\".`\n                    );\n                }\n\n                assocs[anchor] = v;\n            } else if (k[0] === '@') {\n                // update by reference\n                const anchor = k.substr(1);\n                const assocMeta = meta[anchor];\n                if (!assocMeta) {\n                    throw new ValidationError(\n                        `Unknown association \"${anchor}\" of entity \"${this.meta.name}\".`\n                    );\n                }\n\n                if (\n                    assocMeta.type !== 'refersTo' &&\n                    assocMeta.type !== 'belongsTo'\n                ) {\n                    throw new ValidationError(\n                        `Association type \"${assocMeta.type}\" cannot be used for update by reference.`,\n                        {\n                            entity: this.meta.name,\n                            data,\n                        }\n                    );\n                }\n\n                if (isNew && anchor in data) {\n                    throw new ValidationError(\n                        `Association reference \"@${anchor}\" of entity \"${this.meta.name}\" conflicts with input value of field \"${anchor}\".`\n                    );\n                }\n\n                const assocAnchor = ':' + anchor;\n                if (assocAnchor in data) {\n                    throw new ValidationError(\n                        `Association reference \"@${anchor}\" of entity \"${this.meta.name}\" conflicts with association data \"${assocAnchor}\".`\n                    );\n                }\n\n                if (v == null) {\n                    raw[anchor] = null;\n                } else {\n                    refs[anchor] = v;\n                }\n            } else {\n                raw[k] = v;\n            }\n        });\n\n        return [raw, assocs, refs];\n    }\n\n    static async _populateReferences_(context, references) {\n        const meta = this.meta.associations;\n\n        await eachAsync_(references, async (refQuery, anchor) => {\n            const assocMeta = meta[anchor];\n            const ReferencedEntity = this.db.model(assocMeta.entity);\n\n            const created = await ReferencedEntity.findOne_(\n                refQuery,\n                context.connOptions\n            );\n\n            if (!created) {\n                throw new ReferencedNotExistError(\n                    `Referenced entity \"${\n                        ReferencedEntity.meta.name\n                    }\" with ${JSON.stringify(refQuery)} not exist.`\n                );\n            }\n\n            context.raw[anchor] = created[assocMeta.field];\n        });\n    }\n\n    static async _createAssocs_(context, assocs, beforeEntityCreate) {\n        const meta = this.meta.associations;\n        let keyValue;\n\n        if (!beforeEntityCreate) {\n            keyValue = context.return[this.meta.keyField];\n\n            if (_.isNil(keyValue)) {\n                if (context.result.affectedRows === 0) {\n                    // insert ignored\n\n                    const query = this.getUniqueKeyValuePairsFrom(\n                        context.return\n                    );\n                    context.return = await this.findOne_(\n                        { $query: query },\n                        context.connOptions\n                    );\n                    if (!context.return) {\n                        throw new ApplicationError(\n                            'The parent entity is duplicated on unique keys different from the pair of keys used to query',\n                            {\n                                query,\n                                data: context.return,\n                                associations: assocs,\n                            }\n                        );\n                    }\n                }\n\n                keyValue = context.return[this.meta.keyField];\n\n                if (_.isNil(keyValue)) {\n                    throw new ApplicationError(\n                        'Missing required primary key field value. Entity: ' +\n                            this.meta.name,\n                        {\n                            data: context.return,\n                            associations: assocs,\n                        }\n                    );\n                }\n            }\n        }\n\n        const pendingAssocs = {};\n        const finished = {};\n\n        // todo: double check to ensure including all required options\n        const passOnOptions = _.pick(context.options, [\n            '$skipModifiers',\n            '$migration',\n            '$variables',\n            '$upsert',\n            '$dryRun'\n        ]);\n\n        await eachAsync_(assocs, async (data, anchor) => {\n            const assocMeta = meta[anchor];\n\n            if (\n                beforeEntityCreate &&\n                assocMeta.type !== 'refersTo' &&\n                assocMeta.type !== 'belongsTo'\n            ) {\n                pendingAssocs[anchor] = data;\n                return;\n            }\n\n            const assocModel = this.db.model(assocMeta.entity);\n\n            if (assocMeta.list) {\n                data = _.castArray(data);\n\n                if (!assocMeta.field) {\n                    throw new ApplicationError(\n                        `Missing \"field\" property in the metadata of association \"${anchor}\" of entity \"${this.meta.name}\".`\n                    );\n                }\n\n                return eachAsync_(data, (item) =>\n                    assocModel.create_(\n                        { ...item, [assocMeta.field]: keyValue },\n                        passOnOptions,\n                        context.connOptions\n                    )\n                );\n            } else if (!_.isPlainObject(data)) {\n                if (Array.isArray(data)) {\n                    throw new ApplicationError(\n                        `Invalid type of associated entity (${assocMeta.entity}) data triggered from \"${this.meta.name}\" entity. Singular value expected (${anchor}), but an array is given instead.`\n                    );\n                }\n\n                if (!assocMeta.assoc) {\n                    throw new ApplicationError(\n                        `The associated field of relation \"${anchor}\" does not exist in the entity meta data.`\n                    );\n                }\n\n                data = { [assocMeta.assoc]: data };\n            }\n\n            if (!beforeEntityCreate && assocMeta.field) {\n                // hasMany or hasOne\n                data = { ...data, [assocMeta.field]: keyValue };\n            }\n\n            passOnOptions.$retrieveDbResult = true;\n            let created = await assocModel.create_(\n                data,\n                passOnOptions,\n                context.connOptions\n            );\n\n            if (\n                passOnOptions.$result.affectedRows === 0 ||\n                (assocModel.hasAutoIncrement &&\n                    passOnOptions.$result.insertId === 0)\n            ) {\n                // insert ignored or upserted\n\n                const assocQuery = assocModel.getUniqueKeyValuePairsFrom(data);\n\n                created = await assocModel.findOne_(\n                    { $query: assocQuery },\n                    context.connOptions\n                );\n                if (!created) {\n                    throw new ApplicationError(\n                        'The assoicated entity is duplicated on unique keys different from the pair of keys used to query',\n                        {\n                            query: assocQuery,\n                            data,\n                        }\n                    );\n                }\n            }\n\n            finished[anchor] = beforeEntityCreate\n                ? created[assocMeta.field]\n                : created[assocMeta.key];\n        });\n\n        if (beforeEntityCreate) {\n            _.forOwn(finished, (refFieldValue, localField) => {\n                context.raw[localField] = refFieldValue;\n            });\n        }\n\n        return pendingAssocs;\n    }\n\n    static async _updateAssocs_(\n        context,\n        assocs,\n        beforeEntityUpdate,\n        forSingleRecord\n    ) {\n        const meta = this.meta.associations;\n\n        let currentKeyValue;\n\n        if (!beforeEntityUpdate) {\n            currentKeyValue = getValueFrom(\n                [context.options.$query, context.return],\n                this.meta.keyField\n            );\n            if (_.isNil(currentKeyValue)) {\n                // should have in updating\n                throw new ApplicationError(\n                    'Missing required primary key field value. Entity: ' +\n                        this.meta.name\n                );\n            }\n        }\n\n        const pendingAssocs = {};\n\n        // todo: double check to ensure including all required options\n        const passOnOptions = _.pick(context.options, [\n            '$skipModifiers',\n            '$migration',\n            '$variables',\n            '$upsert',\n        ]);\n\n        await eachAsync_(assocs, async (data, anchor) => {\n            const assocMeta = meta[anchor];\n\n            if (\n                beforeEntityUpdate &&\n                assocMeta.type !== 'refersTo' &&\n                assocMeta.type !== 'belongsTo'\n            ) {\n                pendingAssocs[anchor] = data;\n                return;\n            }\n\n            const assocModel = this.db.model(assocMeta.entity);\n\n            if (assocMeta.list) {\n                data = _.castArray(data);\n\n                if (!assocMeta.field) {\n                    throw new ApplicationError(\n                        `Missing \"field\" property in the metadata of association \"${anchor}\" of entity \"${this.meta.name}\".`\n                    );\n                }\n\n                const assocKeys = mapFilter(\n                    data,\n                    (record) => record[assocMeta.key] != null,\n                    (record) => record[assocMeta.key]\n                );\n                const assocRecordsToRemove = {\n                    [assocMeta.field]: currentKeyValue,\n                };\n                if (assocKeys.length > 0) {\n                    assocRecordsToRemove[assocMeta.key] = { $notIn: assocKeys };\n                }\n\n                await assocModel.deleteMany_(\n                    assocRecordsToRemove,\n                    context.connOptions\n                );\n\n                return eachAsync_(data, (item) =>\n                    item[assocMeta.key] != null\n                        ? assocModel.updateOne_(\n                              {\n                                  ..._.omit(item, [assocMeta.key]),\n                                  [assocMeta.field]: currentKeyValue,\n                              },\n                              {\n                                  $query: {\n                                      [assocMeta.key]: item[assocMeta.key],\n                                  },\n                                  ...passOnOptions,\n                              },\n                              context.connOptions\n                          )\n                        : assocModel.create_(\n                              { ...item, [assocMeta.field]: currentKeyValue },\n                              passOnOptions,\n                              context.connOptions\n                          )\n                );\n            } else if (!_.isPlainObject(data)) {\n                if (Array.isArray(data)) {\n                    throw new ApplicationError(\n                        `Invalid type of associated entity (${assocMeta.entity}) data triggered from \"${this.meta.name}\" entity. Singular value expected (${anchor}), but an array is given instead.`\n                    );\n                }\n\n                if (!assocMeta.assoc) {\n                    throw new ApplicationError(\n                        `The associated field of relation \"${anchor}\" does not exist in the entity meta data.`\n                    );\n                }\n\n                // connected by\n                data = { [assocMeta.assoc]: data };\n            }\n\n            if (beforeEntityUpdate) {\n                if (_.isEmpty(data)) return;\n\n                // refersTo or belongsTo\n                let destEntityId = getValueFrom(\n                    [context.existing, context.options.$query, context.raw],\n                    anchor\n                );\n\n                if (destEntityId == null) {\n                    if (_.isEmpty(context.existing)) {\n                        context.existing = await this.findOne_(\n                            context.options.$query,\n                            context.connOptions\n                        );\n                        if (!context.existing) {\n                            throw new ValidationError(\n                                `Specified \"${this.meta.name}\" not found.`,\n                                {\n                                    query: context.options.$query,\n                                }\n                            );\n                        }\n                        destEntityId = context.existing[anchor];\n                    }\n\n                    if (destEntityId == null) {\n                        if (!(anchor in context.existing)) {\n                            throw new ApplicationError(\n                                'Existing entity record does not contain the referenced entity id.',\n                                {\n                                    anchor,\n                                    data,\n                                    existing: context.existing,\n                                    query: context.options.$query,\n                                    raw: context.raw,\n                                }\n                            );\n                        }\n\n                        // to create the associated, existing is null\n\n                        passOnOptions.$retrieveDbResult = true;\n                        let created = await assocModel.create_(\n                            data,\n                            passOnOptions,\n                            context.connOptions\n                        );\n\n                        if (passOnOptions.$result.affectedRows === 0) {\n                            // insert ignored\n\n                            const assocQuery =\n                                assocModel.getUniqueKeyValuePairsFrom(data);\n                            created = await assocModel.findOne_(\n                                { $query: assocQuery },\n                                context.connOptions\n                            );\n                            if (!created) {\n                                throw new ApplicationError(\n                                    'The assoicated entity is duplicated on unique keys different from the pair of keys used to query',\n                                    {\n                                        query: assocQuery,\n                                        data,\n                                    }\n                                );\n                            }\n                        }\n\n                        context.raw[anchor] = created[assocMeta.field];\n                        return;\n                    }\n                }\n\n                if (destEntityId) {\n                    return assocModel.updateOne_(\n                        data,\n                        { [assocMeta.field]: destEntityId, ...passOnOptions },\n                        context.connOptions\n                    );\n                }\n\n                // nothing to do for null dest entity id\n                return;\n            }\n\n            await assocModel.deleteMany_(\n                { [assocMeta.field]: currentKeyValue },\n                context.connOptions\n            );\n\n            if (forSingleRecord) {\n                return assocModel.create_(\n                    { ...data, [assocMeta.field]: currentKeyValue },\n                    passOnOptions,\n                    context.connOptions\n                );\n            }\n\n            throw new Error(\n                'update associated data for multiple records not implemented'\n            );\n\n            // return assocModel.replaceOne_({ ...data, ...(assocMeta.field ? { [assocMeta.field]: keyValue } : {}) }, null, context.connOptions);\n        });\n\n        return pendingAssocs;\n    }\n}\n\nconst sugar = require('./mixin/sugar');\nfor (const key of Object.keys(sugar)) {\n    MySQLEntityModel[key] = sugar[key];\n}\n\nmodule.exports = MySQLEntityModel;\n"],"mappings":"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"}