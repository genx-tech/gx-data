{"version":3,"sources":["../../../src/drivers/mysql/EntityModel.js"],"names":["_","eachAsync_","require","EntityModel","ApplicationError","ReferencedNotExistError","DuplicateError","ValidationError","InvalidArgument","Types","getValueFrom","mapFilter","defaultNestedKeyGetter","anchor","MySQLEntityModel","hasAutoIncrement","autoId","meta","features","fields","field","autoIncrementId","getNestedObject","entityObj","keyPath","get","split","map","p","join","_translateSymbolToken","name","db","connector","raw","Error","_serializeByTypeInfo","value","info","type","DATETIME","serialize","Array","isArray","csv","ARRAY","toCsv","OBJECT","create_","args","error","errorCode","code","message","updateOne_","_doReplaceOne_","context","ensureTransaction_","entity","findOne_","$query","options","connOptions","ret","$retrieveExisting","rawOptions","$existing","keyField","valueOfKey","omit","$retrieveCreated","$retrieveUpdated","$result","_internalBeforeCreate_","_fillResult","result","affectedRows","insertId","latest","upsert","return","_internalAfterCreate_","$retrieveDbResult","queryKey","getUniqueKeyValuePairsFrom","isEmpty","retrieveOptions","isPlainObject","_internalBeforeUpdate_","_internalBeforeUpdateMany_","_internalAfterUpdate_","changedRows","retrieveUpdated","$retrieveActualUpdated","$retrieveNotUpdate","condition","$bypassEnsureUnique","$relationships","$includeDeleted","$retrieveDeleted","_internalAfterUpdateMany_","findAll_","_internalBeforeDelete_","$physicalDeletion","existing","_internalBeforeDeleteMany_","_internalAfterDelete_","_internalAfterDeleteMany_","_prepareAssociations","findOptions","normalAssocs","customAssocs","partition","$association","assoc","associations","uniq","sort","concat","assocTable","counter","cache","forEach","_translateSchemaNameToDb","alias","joinType","output","key","on","dataset","buildQuery","model","_prepareQueries","$variables","_loadAssocIntoTable","lastPos","lastIndexOf","assocInfo","base","substr","last","baseNode","subAssocs","currentDb","indexOf","schemaName","entityName","app","refDb","database","_mapRecordsToObjects","rows","columns","aliasMap","hierarchy","nestedKeyGetter","mapValues","chain","mainIndex","self","col","table","pos","mergeRecord","existingRow","rowObject","nodePath","each","sql","list","currentPath","push","objKey","subObj","subIndexes","rowKeyValue","isNil","existingSubRow","subIndex","buildSubIndexes","indexes","subObject","arrayOfObjs","tableTemplate","reduce","bucket","row","tableCache","colIdx","forOwn","obj","set","rowKey","_extractAssociations","data","isNew","assocs","refs","v","k","assocMeta","assocAnchor","_populateReferences_","references","refQuery","ReferencedEntity","created","JSON","stringify","_createAssocs_","beforeEntityCreate","keyValue","query","pendingAssocs","finished","passOnOptions","pick","assocModel","castArray","item","assocQuery","refFieldValue","localField","_updateAssocs_","beforeEntityUpdate","forSingleRecord","currentKeyValue","assocKeys","record","assocRecordsToRemove","length","$notIn","deleteMany_","destEntityId","module","exports"],"mappings":"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","sourcesContent":["const { _, eachAsync_ } = require('@genx/july');\nconst EntityModel = require('../../EntityModel');\nconst {\n    ApplicationError,\n    ReferencedNotExistError,\n    DuplicateError,\n    ValidationError,\n    InvalidArgument,\n} = require('../../utils/Errors');\nconst Types = require('../../types');\nconst { getValueFrom, mapFilter } = require('../../utils/lang');\n\nconst defaultNestedKeyGetter = (anchor) => ':' + anchor;\n\n/**\n * MySQL entity model class.\n */\nclass MySQLEntityModel extends EntityModel {\n    /**\n     * [specific] Check if this entity has auto increment feature.\n     */\n    static get hasAutoIncrement() {\n        const autoId = this.meta.features.autoId;\n        return autoId && this.meta.fields[autoId.field].autoIncrementId;\n    }\n\n    /**\n     * [override]\n     * @param {*} entityObj\n     * @param {*} keyPath\n     */\n    static getNestedObject(entityObj, keyPath) {\n        return _.get(\n            entityObj,\n            keyPath\n                .split('.')\n                .map((p) => ':' + p)\n                .join('.')\n        );\n    }\n\n    /**\n     * [override] Serialize value into database acceptable format.\n     * @param {object} name - Name of the symbol token\n     */\n    static _translateSymbolToken(name) {\n        if (name === 'NOW') {\n            return this.db.connector.raw('NOW()');\n        }\n\n        throw new Error('not support: ' + name);\n    }\n\n    /**\n     * [override]\n     * @param {*} value\n     * @param {*} info\n     */\n    static _serializeByTypeInfo(value, info) {\n        if (info.type === 'boolean') {\n            return value ? 1 : 0;\n        }\n\n        if (info.type === 'datetime') {\n            return Types.DATETIME.serialize(value);\n        }\n\n        if (info.type === 'array' && Array.isArray(value)) {\n            if (info.csv) {\n                return Types.ARRAY.toCsv(value);\n            } else {\n                return Types.ARRAY.serialize(value);\n            }\n        }\n\n        if (info.type === 'object') {\n            return Types.OBJECT.serialize(value);\n        }\n\n        return value;\n    }\n\n    static async create_(...args) {\n        try {\n            return await super.create_(...args);\n        } catch (error) {\n            const errorCode = error.code;\n\n            if (errorCode === 'ER_NO_REFERENCED_ROW_2') {\n                throw new ReferencedNotExistError(\n                    'The new entity is referencing to an unexisting entity. Detail: ' +\n                        error.message,\n                    error.info\n                );\n            } else if (errorCode === 'ER_DUP_ENTRY') {\n                throw new DuplicateError(\n                    error.message +\n                        ` while creating a new \"${this.meta.name}\".`,\n                    error.info\n                );\n            }\n\n            throw error;\n        }\n    }\n\n    static async updateOne_(...args) {\n        try {\n            return await super.updateOne_(...args);\n        } catch (error) {\n            const errorCode = error.code;\n\n            if (errorCode === 'ER_NO_REFERENCED_ROW_2') {\n                throw new ReferencedNotExistError(\n                    'The entity to be updated is referencing to an unexisting entity. Detail: ' +\n                        error.message,\n                    error.info\n                );\n            } else if (errorCode === 'ER_DUP_ENTRY') {\n                throw new DuplicateError(\n                    error.message +\n                        ` while updating an existing \"${this.meta.name}\".`,\n                    error.info\n                );\n            }\n\n            throw error;\n        }\n    }\n\n    static async _doReplaceOne_(context) {\n        await this.ensureTransaction_(context);\n\n        const entity = await this.findOne_(\n            { $query: context.options.$query },\n            context.connOptions\n        );\n\n        let ret, options;\n\n        if (entity) {\n            if (context.options.$retrieveExisting) {\n                context.rawOptions.$existing = entity;\n            }\n\n            options = {\n                ...context.options,\n                $query: { [this.meta.keyField]: super.valueOfKey(entity) },\n                $existing: entity,\n            };\n\n            ret = await this.updateOne_(\n                context.raw,\n                options,\n                context.connOptions\n            );\n        } else {\n            options = {\n                ..._.omit(context.options, [\n                    '$retrieveUpdated',\n                    '$bypassEnsureUnique',\n                ]),\n                $retrieveCreated: context.options.$retrieveUpdated,\n            };\n\n            ret = await this.create_(context.raw, options, context.connOptions);\n        }\n\n        if (options.$existing) {\n            context.rawOptions.$existing = options.$existing;\n        }\n\n        if (options.$result) {\n            context.rawOptions.$result = options.$result;\n        }\n\n        return ret;\n    }\n\n    static _internalBeforeCreate_(context) {\n        return true;\n    }\n\n    static _fillResult(context) {\n        if (this.hasAutoIncrement && context.result.affectedRows > 0) {\n            const { insertId } = context.result;\n            if (insertId > 0) {\n                context.latest = {\n                    ...context.latest,\n                    [this.meta.features.autoId.field]: insertId,\n                };\n            } else if (context.result.upsert) {\n                // the key is not correct \n                delete context.latest[this.meta.features.autoId.field];\n            }\n        } else if (context.result.upsert) {\n            // the key is not correct \n            delete context.latest[this.meta.features.autoId.field];\n        }\n\n        context.return = context.latest;\n    }\n\n    /**\n     * Post create processing.\n     * @param {*} context\n     * @property {object} [context.options] - Create options\n     * @property {bool} [options.$retrieveCreated] - Retrieve the newly created record from db.\n     */\n    static async _internalAfterCreate_(context) {\n        if (context.options.$retrieveDbResult) {\n            context.rawOptions.$result = context.result;\n        }\n\n        if (context.options.$retrieveCreated) {\n            if (this.hasAutoIncrement) {\n                if (context.result.affectedRows === 0) {\n                    // insert ignored\n                    context.queryKey = this.getUniqueKeyValuePairsFrom(\n                        context.latest\n                    );\n\n                    if (_.isEmpty(context.queryKey)) {\n                        throw new ApplicationError(\n                            'Cannot extract unique keys from input data.',\n                            {\n                                entity: this.meta.name,\n                            }\n                        );\n                    }\n                } else {\n                    const { insertId } = context.result;\n                    context.queryKey = {\n                        [this.meta.features.autoId.field]: insertId,\n                    };\n                }\n            } else {\n                context.queryKey = this.getUniqueKeyValuePairsFrom(\n                    context.latest\n                );\n\n                if (_.isEmpty(context.queryKey)) {\n                    throw new ApplicationError(\n                        'Cannot extract unique keys from input data.',\n                        {\n                            entity: this.meta.name,\n                        }\n                    );\n                }\n            }\n\n            const retrieveOptions = _.isPlainObject(\n                context.options.$retrieveCreated\n            )\n                ? context.options.$retrieveCreated\n                : {};\n            context.return = await this.findOne_(\n                { ...retrieveOptions, $query: context.queryKey },\n                context.connOptions\n            );\n        } else {\n            if (this.hasAutoIncrement) {\n                if (context.result.affectedRows === 0) {\n                    context.queryKey = this.getUniqueKeyValuePairsFrom(\n                        context.latest\n                    );\n                } else {\n                    const { insertId } = context.result;\n                    context.queryKey = {\n                        [this.meta.features.autoId.field]: insertId,\n                    };\n                }\n            }\n        }\n    }\n\n    static _internalBeforeUpdate_(context) {\n        return true;\n    }\n\n    static _internalBeforeUpdateMany_(context) {\n        return true;\n    }\n\n    /**\n     * Post update processing.\n     * @param {*} context\n     * @property {object} [context.options] - Update options\n     * @property {bool} [context.options.$retrieveUpdated] - Retrieve the newly updated record from db.\n     */\n    static async _internalAfterUpdate_(context) {\n        const options = context.options;\n\n        if (options.$retrieveDbResult) {\n            context.rawOptions.$result = context.result || {\n                affectedRows: 0,\n                changedRows: 0,\n            };\n        }\n\n        let retrieveUpdated = options.$retrieveUpdated;\n\n        if (!retrieveUpdated) {\n            if (\n                options.$retrieveActualUpdated &&\n                context.result.affectedRows > 0\n            ) {\n                retrieveUpdated = options.$retrieveActualUpdated;\n            } else if (\n                options.$retrieveNotUpdate &&\n                context.result.affectedRows === 0\n            ) {\n                retrieveUpdated = options.$retrieveNotUpdate;\n            }\n        }\n\n        if (retrieveUpdated) {\n            const condition = {\n                $query: this.getUniqueKeyValuePairsFrom(options.$query),\n            };\n            if (options.$bypassEnsureUnique) {\n                condition.$bypassEnsureUnique = options.$bypassEnsureUnique;\n            }\n\n            let retrieveOptions = {};\n\n            if (_.isPlainObject(retrieveUpdated)) {\n                retrieveOptions = retrieveUpdated;\n            } else if (options.$relationships) {\n                retrieveOptions.$relationships = options.$relationships;\n            }\n\n            context.return = await this.findOne_(\n                {\n                    ...condition,\n                    $includeDeleted: options.$retrieveDeleted,\n                    ...retrieveOptions,\n                },\n                context.connOptions\n            );\n\n            if (context.return) {\n                context.queryKey = this.getUniqueKeyValuePairsFrom(\n                    context.return\n                );\n            } else {\n                context.queryKey = condition.$query;\n            }\n        }\n    }\n\n    /**\n     * Post update processing.\n     * @param {*} context\n     * @param {object} [options] - Update options\n     * @property {bool} [options.$retrieveUpdated] - Retrieve the newly updated record from db.\n     */\n    static async _internalAfterUpdateMany_(context) {\n        const options = context.options;\n\n        if (options.$retrieveDbResult) {\n            context.rawOptions.$result = context.result || {\n                affectedRows: 0,\n                changedRows: 0,\n            };\n\n            /**\n             * afterUpdateMany ResultSetHeader {\n             * fieldCount: 0,\n             * affectedRows: 1,\n             * insertId: 0,\n             * info: 'Rows matched: 1  Changed: 1  Warnings: 0',\n             * serverStatus: 3,\n             * warningStatus: 0,\n             * changedRows: 1 }\n             */\n        }\n\n        if (options.$retrieveUpdated) {\n            let retrieveOptions = {};\n\n            if (_.isPlainObject(options.$retrieveUpdated)) {\n                retrieveOptions = options.$retrieveUpdated;\n            } else if (options.$relationships) {\n                retrieveOptions.$relationships = options.$relationships;\n            }\n\n            context.return = await this.findAll_(\n                {\n                    $query: options.$query,\n                    $includeDeleted: options.$retrieveDeleted,\n                    ...retrieveOptions,\n                },\n                context.connOptions\n            );\n        }\n\n        context.queryKey = options.$query;\n    }\n\n    /**\n     * Before deleting an entity.\n     * @param {*} context\n     * @property {object} [context.options] - Delete options\n     * @property {bool} [context.options.$retrieveDeleted] - Retrieve the recently deleted record from db.\n     */\n    static async _internalBeforeDelete_(context) {\n        if (context.options.$retrieveDeleted) {\n            await this.ensureTransaction_(context);\n\n            const retrieveOptions = _.isPlainObject(\n                context.options.$retrieveDeleted\n            )\n                ? {\n                      ...context.options.$retrieveDeleted,\n                      $query: context.options.$query,\n                  }\n                : { $query: context.options.$query };\n\n            if (context.options.$physicalDeletion) {\n                retrieveOptions.$includeDeleted = true;\n            }\n\n            context.return = context.existing = await this.findOne_(\n                retrieveOptions,\n                context.connOptions\n            );\n        }\n\n        return true;\n    }\n\n    static async _internalBeforeDeleteMany_(context) {\n        if (context.options.$retrieveDeleted) {\n            await this.ensureTransaction_(context);\n\n            const retrieveOptions = _.isPlainObject(\n                context.options.$retrieveDeleted\n            )\n                ? {\n                      ...context.options.$retrieveDeleted,\n                      $query: context.options.$query,\n                  }\n                : { $query: context.options.$query };\n\n            if (context.options.$physicalDeletion) {\n                retrieveOptions.$includeDeleted = true;\n            }\n\n            context.return = context.existing = await this.findAll_(\n                retrieveOptions,\n                context.connOptions\n            );\n        }\n\n        return true;\n    }\n\n    /**\n     * Post delete processing.\n     * @param {*} context\n     */\n    static _internalAfterDelete_(context) {\n        if (context.options.$retrieveDbResult) {\n            context.rawOptions.$result = context.result;\n        }\n    }\n\n    /**\n     * Post delete processing.\n     * @param {*} context\n     */\n    static _internalAfterDeleteMany_(context) {\n        if (context.options.$retrieveDbResult) {\n            context.rawOptions.$result = context.result;\n        }\n    }\n\n    /**\n     *\n     * @param {*} findOptions\n     */\n    static _prepareAssociations(findOptions) {\n        const [normalAssocs, customAssocs] = _.partition(\n            findOptions.$association,\n            (assoc) => typeof assoc === 'string'\n        );\n\n        const associations = _.uniq(normalAssocs).sort().concat(customAssocs);\n        const assocTable = {};\n            let counter = 0;\n            const cache = {};\n\n        associations.forEach((assoc) => {\n            if (_.isPlainObject(assoc)) {\n                assoc = this._translateSchemaNameToDb(assoc);\n\n                let alias = assoc.alias;\n                if (!assoc.alias) {\n                    alias = ':join' + ++counter;\n                }\n\n                assocTable[alias] = {\n                    entity: assoc.entity,\n                    joinType: assoc.type,\n                    output: assoc.output,\n                    key: assoc.key,\n                    alias,\n                    on: assoc.on,\n                    ...(assoc.dataset\n                        ? this.db.connector.buildQuery(\n                              assoc.entity,\n                              assoc.model._prepareQueries({\n                                  ...assoc.dataset,\n                                  $variables: findOptions.$variables,\n                              })\n                          )\n                        : {}),\n                };\n            } else {\n                this._loadAssocIntoTable(assocTable, cache, assoc);\n            }\n        });\n\n        return assocTable;\n    }\n\n    /**\n     *\n     * @param {*} assocTable - Hierarchy with subAssocs\n     * @param {*} cache - Dotted path as key\n     * @param {*} assoc - Dotted path\n     */\n    static _loadAssocIntoTable(assocTable, cache, assoc) {\n        if (cache[assoc]) return cache[assoc];\n\n        const lastPos = assoc.lastIndexOf('.');\n        let result;\n\n        if (lastPos === -1) {\n            // direct association\n            const assocInfo = { ...this.meta.associations[assoc] };\n            if (_.isEmpty(assocInfo)) {\n                throw new InvalidArgument(\n                    `Entity \"${this.meta.name}\" does not have the association \"${assoc}\".`\n                );\n            }\n\n            result =\n                cache[assoc] =\n                assocTable[assoc] =\n                    { ...this._translateSchemaNameToDb(assocInfo) };\n        } else {\n            const base = assoc.substr(0, lastPos);\n            const last = assoc.substr(lastPos + 1);\n\n            let baseNode = cache[base];\n            if (!baseNode) {\n                baseNode = this._loadAssocIntoTable(assocTable, cache, base);\n            }\n\n            const entity = baseNode.model || this.db.model(baseNode.entity);\n            const assocInfo = { ...entity.meta.associations[last] };\n            if (_.isEmpty(assocInfo)) {\n                throw new InvalidArgument(\n                    `Entity \"${entity.meta.name}\" does not have the association \"${assoc}\".`\n                );\n            }\n\n            result = { ...entity._translateSchemaNameToDb(assocInfo, this.db) };\n\n            if (!baseNode.subAssocs) {\n                baseNode.subAssocs = {};\n            }\n\n            cache[assoc] = baseNode.subAssocs[last] = result;\n        }\n\n        if (result.assoc) {\n            this._loadAssocIntoTable(\n                assocTable,\n                cache,\n                assoc + '.' + result.assoc\n            );\n        }\n\n        return result;\n    }\n\n    static _translateSchemaNameToDb(assoc, currentDb) {\n        if (assoc.entity.indexOf('.') > 0) {\n            const [schemaName, entityName] = assoc.entity.split('.', 2);\n\n            const app = this.db.app;\n\n            const refDb = app.db(schemaName);\n            if (!refDb) {\n                throw new ApplicationError(\n                    `The referenced schema \"${schemaName}\" does not have db model in the same application.`\n                );\n            }\n\n            assoc.entity = refDb.connector.database + '.' + entityName;\n            assoc.model = refDb.model(entityName);\n\n            if (!assoc.model) {\n                throw new ApplicationError(\n                    `Failed load the entity model \"${schemaName}.${entityName}\".`\n                );\n            }\n        } else {\n            assoc.model = this.db.model(assoc.entity);\n\n            if (currentDb && currentDb !== this.db) {\n                assoc.entity = this.db.connector.database + '.' + assoc.entity;\n            }\n        }\n\n        if (!assoc.key) {\n            assoc.key = assoc.model.meta.keyField;\n        }\n\n        return assoc;\n    }\n\n    static _mapRecordsToObjects(\n        [rows, columns, aliasMap],\n        hierarchy,\n        nestedKeyGetter\n    ) {\n        nestedKeyGetter == null && (nestedKeyGetter = defaultNestedKeyGetter);\n        aliasMap = _.mapValues(aliasMap, (chain) =>\n            chain.map((anchor) => nestedKeyGetter(anchor))\n        );\n\n        const mainIndex = {};\n        const self = this;\n\n        // map mysql column result into array of { table <table alias>, name: <column name> }\n        columns = columns.map((col) => {\n            if (col.table === '') {\n                const pos = col.name.indexOf('$');\n                if (pos > 0) {\n                    return {\n                        table: col.name.substr(0, pos),\n                        name: col.name.substr(pos + 1),\n                    };\n                }\n\n                return {\n                    table: 'A',\n                    name: col.name,\n                };\n            }\n\n            return {\n                table: col.table,\n                name: col.name,\n            };\n        });\n\n        // map flat record into hierachy\n        function mergeRecord(existingRow, rowObject, associations, nodePath) {\n            return _.each(\n                associations,\n                ({ sql, key, list, subAssocs }, anchor) => {\n                    if (sql) return;\n\n                    const currentPath = nodePath.concat();\n                    currentPath.push(anchor);\n\n                    const objKey = nestedKeyGetter(anchor);\n                    const subObj = rowObject[objKey];\n\n                    if (!subObj) {\n                        // associated entity not in result set, probably when custom projection is used\n                        return;\n                    }\n\n                    const subIndexes = existingRow.subIndexes[objKey];\n\n                    // joined an empty record\n                    const rowKeyValue = subObj[key];\n                    if (_.isNil(rowKeyValue)) {\n                        if (list && rowKeyValue == null) {\n                            if (existingRow.rowObject[objKey]) {\n                                existingRow.rowObject[objKey].push(subObj);\n                            } else {\n                                existingRow.rowObject[objKey] = [subObj];\n                            }\n                        }\n\n                        return;\n                    }\n\n                    const existingSubRow = subIndexes && subIndexes[rowKeyValue];\n                    if (existingSubRow) {\n                        if (subAssocs) {\n                            return mergeRecord(\n                                existingSubRow,\n                                subObj,\n                                subAssocs,\n                                currentPath\n                            );\n                        }\n                    } else {\n                        if (!list) {\n                            throw new ApplicationError(\n                                `The structure of association \"${currentPath.join(\n                                    '.'\n                                )}\" with [key=${key}] of entity \"${\n                                    self.meta.name\n                                }\" should be a list.`,\n                                { existingRow, rowObject }\n                            );\n                        }\n\n                        if (existingRow.rowObject[objKey]) {\n                            existingRow.rowObject[objKey].push(subObj);\n                        } else {\n                            existingRow.rowObject[objKey] = [subObj];\n                        }\n\n                        const subIndex = {\n                            rowObject: subObj,\n                        };\n\n                        if (subAssocs) {\n                            subIndex.subIndexes = buildSubIndexes(\n                                subObj,\n                                subAssocs\n                            );\n                        }\n\n                        if (!subIndexes) {\n                            throw new ApplicationError(\n                                `The subIndexes of association \"${currentPath.join(\n                                    '.'\n                                )}\" with [key=${key}] of entity \"${\n                                    self.meta.name\n                                }\" does not exist.`,\n                                { existingRow, rowObject }\n                            );\n                        }\n\n                        subIndexes[rowKeyValue] = subIndex;\n                    }\n                }\n            );\n        }\n\n        // build sub index for list member\n        function buildSubIndexes(rowObject, associations) {\n            const indexes = {};\n\n            _.each(associations, ({ sql, key, list, subAssocs }, anchor) => {\n                if (sql) {\n                    return;\n                }\n\n                const objKey = nestedKeyGetter(anchor);\n                let subObject = rowObject[objKey];\n                const subIndex = {\n                    rowObject: subObject,\n                };\n\n                if (list) {\n                    if (!subObject) {\n                        // associated entity not in result set, probably when custom projection is used\n                        rowObject[objKey] = [];\n                        return;\n                    }\n\n                    rowObject[objKey] = [subObject];\n\n                    // many to *\n                    if (_.isNil(subObject[key])) {\n                        // when custom projection is used\n                        subObject = null;\n                    }\n                }\n\n                if (subObject) {\n                    if (subAssocs) {\n                        subIndex.subIndexes = buildSubIndexes(\n                            subObject,\n                            subAssocs\n                        );\n                    }\n\n                    indexes[objKey] = subObject[key]\n                        ? {\n                              [subObject[key]]: subIndex,\n                          }\n                        : {};\n                }\n            });\n\n            return indexes;\n        }\n\n        const arrayOfObjs = [];\n\n        // build the result object skeleton\n        const tableTemplate = columns.reduce((result, col) => {\n            if (col.table !== 'A') {\n                const bucket = result[col.table];\n                if (bucket) {\n                    bucket[col.name] = null;\n                } else {\n                    result[col.table] = { [col.name]: null };\n                }\n            }\n\n            return result;\n        }, {});\n\n        // process each row\n        rows.forEach((row) => {\n            const tableCache = {}; // from alias to child prop of rowObject\n\n            // hash-style data row\n            const rowObject = row.reduce((result, value, colIdx) => {\n                const col = columns[colIdx];\n\n                if (col.table === 'A') {\n                    result[col.name] = value;\n                } else if (value != null) {\n                    // avoid a object with all null value exists\n                    const bucket = tableCache[col.table];\n                    if (bucket) {\n                        // already nested inside\n                        bucket[col.name] = value;\n                    } else {\n                        tableCache[col.table] = {\n                            ...tableTemplate[col.table],\n                            [col.name]: value,\n                        };\n                    }\n                }\n\n                return result;\n            }, {});\n\n            _.forOwn(tableCache, (obj, table) => {\n                const nodePath = aliasMap[table];\n                _.set(rowObject, nodePath, obj);\n            });\n\n            const rowKey = rowObject[self.meta.keyField];\n            const existingRow = mainIndex[rowKey];\n            if (existingRow) {\n                return mergeRecord(existingRow, rowObject, hierarchy, []);\n            }\n\n            arrayOfObjs.push(rowObject);\n            mainIndex[rowKey] = {\n                rowObject,\n                subIndexes: buildSubIndexes(rowObject, hierarchy),\n            };\n        });\n\n        return arrayOfObjs;\n    }\n\n    /**\n     * Pre-process assoicated db operation\n     * @param {*} data\n     * @param {*} isNew - New record flag, true for creating, false for updating\n     * @returns {Array} [raw, assocs, refs];\n     */\n    static _extractAssociations(data, isNew) {\n        const raw = {};\n            const assocs = {};\n            const refs = {};\n        const meta = this.meta.associations;\n\n        _.forOwn(data, (v, k) => {\n            if (k[0] === ':') {\n                // cascade update\n                const anchor = k.substr(1);\n                const assocMeta = meta[anchor];\n                if (!assocMeta) {\n                    throw new ValidationError(\n                        `Unknown association \"${anchor}\" of entity \"${this.meta.name}\".`\n                    );\n                }\n\n                if (\n                    isNew &&\n                    (assocMeta.type === 'refersTo' ||\n                        assocMeta.type === 'belongsTo') &&\n                    anchor in data\n                ) {\n                    throw new ValidationError(\n                        `Association data \":${anchor}\" of entity \"${this.meta.name}\" conflicts with input value of field \"${anchor}\".`\n                    );\n                }\n\n                assocs[anchor] = v;\n            } else if (k[0] === '@') {\n                // update by reference\n                const anchor = k.substr(1);\n                const assocMeta = meta[anchor];\n                if (!assocMeta) {\n                    throw new ValidationError(\n                        `Unknown association \"${anchor}\" of entity \"${this.meta.name}\".`\n                    );\n                }\n\n                if (\n                    assocMeta.type !== 'refersTo' &&\n                    assocMeta.type !== 'belongsTo'\n                ) {\n                    throw new ValidationError(\n                        `Association type \"${assocMeta.type}\" cannot be used for update by reference.`,\n                        {\n                            entity: this.meta.name,\n                            data,\n                        }\n                    );\n                }\n\n                if (isNew && anchor in data) {\n                    throw new ValidationError(\n                        `Association reference \"@${anchor}\" of entity \"${this.meta.name}\" conflicts with input value of field \"${anchor}\".`\n                    );\n                }\n\n                const assocAnchor = ':' + anchor;\n                if (assocAnchor in data) {\n                    throw new ValidationError(\n                        `Association reference \"@${anchor}\" of entity \"${this.meta.name}\" conflicts with association data \"${assocAnchor}\".`\n                    );\n                }\n\n                if (v == null) {\n                    raw[anchor] = null;\n                } else {\n                    refs[anchor] = v;\n                }\n            } else {\n                raw[k] = v;\n            }\n        });\n\n        return [raw, assocs, refs];\n    }\n\n    static async _populateReferences_(context, references) {\n        const meta = this.meta.associations;\n\n        await eachAsync_(references, async (refQuery, anchor) => {\n            const assocMeta = meta[anchor];\n            const ReferencedEntity = this.db.model(assocMeta.entity);\n\n            const created = await ReferencedEntity.findOne_(\n                refQuery,\n                context.connOptions\n            );\n\n            if (!created) {\n                throw new ReferencedNotExistError(\n                    `Referenced entity \"${\n                        ReferencedEntity.meta.name\n                    }\" with ${JSON.stringify(refQuery)} not exist.`\n                );\n            }\n\n            context.raw[anchor] = created[assocMeta.field];\n        });\n    }\n\n    static async _createAssocs_(context, assocs, beforeEntityCreate) {\n        const meta = this.meta.associations;\n        let keyValue;\n\n        if (!beforeEntityCreate) {\n            keyValue = context.return[this.meta.keyField];\n\n            if (_.isNil(keyValue)) {\n                if (context.result.affectedRows === 0) {\n                    // insert ignored\n\n                    const query = this.getUniqueKeyValuePairsFrom(\n                        context.return\n                    );\n                    context.return = await this.findOne_(\n                        { $query: query },\n                        context.connOptions\n                    );\n                    if (!context.return) {\n                        throw new ApplicationError(\n                            'The parent entity is duplicated on unique keys different from the pair of keys used to query',\n                            {\n                                query,\n                                data: context.return,\n                                associations: assocs,\n                            }\n                        );\n                    }\n                }\n\n                keyValue = context.return[this.meta.keyField];\n\n                if (_.isNil(keyValue)) {\n                    throw new ApplicationError(\n                        'Missing required primary key field value. Entity: ' +\n                            this.meta.name,\n                        {\n                            data: context.return,\n                            associations: assocs,\n                        }\n                    );\n                }\n            }\n        }\n\n        const pendingAssocs = {};\n        const finished = {};\n\n        // todo: double check to ensure including all required options\n        const passOnOptions = _.pick(context.options, [\n            '$skipModifiers',\n            '$migration',\n            '$variables',\n            '$upsert',\n            '$dryRun'\n        ]);\n\n        await eachAsync_(assocs, async (data, anchor) => {\n            const assocMeta = meta[anchor];\n\n            if (\n                beforeEntityCreate &&\n                assocMeta.type !== 'refersTo' &&\n                assocMeta.type !== 'belongsTo'\n            ) {\n                pendingAssocs[anchor] = data;\n                return;\n            }\n\n            const assocModel = this.db.model(assocMeta.entity);\n\n            if (assocMeta.list) {\n                data = _.castArray(data);\n\n                if (!assocMeta.field) {\n                    throw new ApplicationError(\n                        `Missing \"field\" property in the metadata of association \"${anchor}\" of entity \"${this.meta.name}\".`\n                    );\n                }\n\n                return eachAsync_(data, (item) =>\n                    assocModel.create_(\n                        { ...item, [assocMeta.field]: keyValue },\n                        passOnOptions,\n                        context.connOptions\n                    )\n                );\n            } else if (!_.isPlainObject(data)) {\n                if (Array.isArray(data)) {\n                    throw new ApplicationError(\n                        `Invalid type of associated entity (${assocMeta.entity}) data triggered from \"${this.meta.name}\" entity. Singular value expected (${anchor}), but an array is given instead.`\n                    );\n                }\n\n                if (!assocMeta.assoc) {\n                    throw new ApplicationError(\n                        `The associated field of relation \"${anchor}\" does not exist in the entity meta data.`\n                    );\n                }\n\n                data = { [assocMeta.assoc]: data };\n            }\n\n            if (!beforeEntityCreate && assocMeta.field) {\n                // hasMany or hasOne\n                data = { ...data, [assocMeta.field]: keyValue };\n            }\n\n            passOnOptions.$retrieveDbResult = true;\n            let created = await assocModel.create_(\n                data,\n                passOnOptions,\n                context.connOptions\n            );\n\n            if (\n                passOnOptions.$result.affectedRows === 0 ||\n                (assocModel.hasAutoIncrement &&\n                    passOnOptions.$result.insertId === 0)\n            ) {\n                // insert ignored or upserted\n\n                const assocQuery = assocModel.getUniqueKeyValuePairsFrom(data);\n\n                created = await assocModel.findOne_(\n                    { $query: assocQuery },\n                    context.connOptions\n                );\n                if (!created) {\n                    throw new ApplicationError(\n                        'The assoicated entity is duplicated on unique keys different from the pair of keys used to query',\n                        {\n                            query: assocQuery,\n                            data,\n                        }\n                    );\n                }\n            }\n\n            finished[anchor] = beforeEntityCreate\n                ? created[assocMeta.field]\n                : created[assocMeta.key];\n        });\n\n        if (beforeEntityCreate) {\n            _.forOwn(finished, (refFieldValue, localField) => {\n                context.raw[localField] = refFieldValue;\n            });\n        }\n\n        return pendingAssocs;\n    }\n\n    static async _updateAssocs_(\n        context,\n        assocs,\n        beforeEntityUpdate,\n        forSingleRecord\n    ) {\n        const meta = this.meta.associations;\n\n        let currentKeyValue;\n\n        if (!beforeEntityUpdate) {\n            currentKeyValue = getValueFrom(\n                [context.options.$query, context.return],\n                this.meta.keyField\n            );\n            if (_.isNil(currentKeyValue)) {\n                // should have in updating\n                throw new ApplicationError(\n                    'Missing required primary key field value. Entity: ' +\n                        this.meta.name\n                );\n            }\n        }\n\n        const pendingAssocs = {};\n\n        // todo: double check to ensure including all required options\n        const passOnOptions = _.pick(context.options, [\n            '$skipModifiers',\n            '$migration',\n            '$variables',\n            '$upsert',\n        ]);\n\n        await eachAsync_(assocs, async (data, anchor) => {\n            const assocMeta = meta[anchor];\n\n            if (\n                beforeEntityUpdate &&\n                assocMeta.type !== 'refersTo' &&\n                assocMeta.type !== 'belongsTo'\n            ) {\n                pendingAssocs[anchor] = data;\n                return;\n            }\n\n            const assocModel = this.db.model(assocMeta.entity);\n\n            if (assocMeta.list) {\n                data = _.castArray(data);\n\n                if (!assocMeta.field) {\n                    throw new ApplicationError(\n                        `Missing \"field\" property in the metadata of association \"${anchor}\" of entity \"${this.meta.name}\".`\n                    );\n                }\n\n                const assocKeys = mapFilter(\n                    data,\n                    (record) => record[assocMeta.key] != null,\n                    (record) => record[assocMeta.key]\n                );\n                const assocRecordsToRemove = {\n                    [assocMeta.field]: currentKeyValue,\n                };\n                if (assocKeys.length > 0) {\n                    assocRecordsToRemove[assocMeta.key] = { $notIn: assocKeys };\n                }\n\n                await assocModel.deleteMany_(\n                    assocRecordsToRemove,\n                    context.connOptions\n                );\n\n                return eachAsync_(data, (item) =>\n                    item[assocMeta.key] != null\n                        ? assocModel.updateOne_(\n                              {\n                                  ..._.omit(item, [assocMeta.key]),\n                                  [assocMeta.field]: currentKeyValue,\n                              },\n                              {\n                                  $query: {\n                                      [assocMeta.key]: item[assocMeta.key],\n                                  },\n                                  ...passOnOptions,\n                              },\n                              context.connOptions\n                          )\n                        : assocModel.create_(\n                              { ...item, [assocMeta.field]: currentKeyValue },\n                              passOnOptions,\n                              context.connOptions\n                          )\n                );\n            } else if (!_.isPlainObject(data)) {\n                if (Array.isArray(data)) {\n                    throw new ApplicationError(\n                        `Invalid type of associated entity (${assocMeta.entity}) data triggered from \"${this.meta.name}\" entity. Singular value expected (${anchor}), but an array is given instead.`\n                    );\n                }\n\n                if (!assocMeta.assoc) {\n                    throw new ApplicationError(\n                        `The associated field of relation \"${anchor}\" does not exist in the entity meta data.`\n                    );\n                }\n\n                // connected by\n                data = { [assocMeta.assoc]: data };\n            }\n\n            if (beforeEntityUpdate) {\n                if (_.isEmpty(data)) return;\n\n                // refersTo or belongsTo\n                let destEntityId = getValueFrom(\n                    [context.existing, context.options.$query, context.raw],\n                    anchor\n                );\n\n                if (destEntityId == null) {\n                    if (_.isEmpty(context.existing)) {\n                        context.existing = await this.findOne_(\n                            context.options.$query,\n                            context.connOptions\n                        );\n                        if (!context.existing) {\n                            throw new ValidationError(\n                                `Specified \"${this.meta.name}\" not found.`,\n                                {\n                                    query: context.options.$query,\n                                }\n                            );\n                        }\n                        destEntityId = context.existing[anchor];\n                    }\n\n                    if (destEntityId == null) {\n                        if (!(anchor in context.existing)) {\n                            throw new ApplicationError(\n                                'Existing entity record does not contain the referenced entity id.',\n                                {\n                                    anchor,\n                                    data,\n                                    existing: context.existing,\n                                    query: context.options.$query,\n                                    raw: context.raw,\n                                }\n                            );\n                        }\n\n                        // to create the associated, existing is null\n\n                        passOnOptions.$retrieveDbResult = true;\n                        let created = await assocModel.create_(\n                            data,\n                            passOnOptions,\n                            context.connOptions\n                        );\n\n                        if (passOnOptions.$result.affectedRows === 0) {\n                            // insert ignored\n\n                            const assocQuery =\n                                assocModel.getUniqueKeyValuePairsFrom(data);\n                            created = await assocModel.findOne_(\n                                { $query: assocQuery },\n                                context.connOptions\n                            );\n                            if (!created) {\n                                throw new ApplicationError(\n                                    'The assoicated entity is duplicated on unique keys different from the pair of keys used to query',\n                                    {\n                                        query: assocQuery,\n                                        data,\n                                    }\n                                );\n                            }\n                        }\n\n                        context.raw[anchor] = created[assocMeta.field];\n                        return;\n                    }\n                }\n\n                if (destEntityId) {\n                    return assocModel.updateOne_(\n                        data,\n                        { [assocMeta.field]: destEntityId, ...passOnOptions },\n                        context.connOptions\n                    );\n                }\n\n                // nothing to do for null dest entity id\n                return;\n            }\n\n            await assocModel.deleteMany_(\n                { [assocMeta.field]: currentKeyValue },\n                context.connOptions\n            );\n\n            if (forSingleRecord) {\n                return assocModel.create_(\n                    { ...data, [assocMeta.field]: currentKeyValue },\n                    passOnOptions,\n                    context.connOptions\n                );\n            }\n\n            throw new Error(\n                'update associated data for multiple records not implemented'\n            );\n\n            // return assocModel.replaceOne_({ ...data, ...(assocMeta.field ? { [assocMeta.field]: keyValue } : {}) }, null, context.connOptions);\n        });\n\n        return pendingAssocs;\n    }\n}\n\nmodule.exports = MySQLEntityModel;\n"],"file":"EntityModel.js"}