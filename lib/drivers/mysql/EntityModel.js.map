{"version":3,"file":"EntityModel.js","names":["_","eachAsync_","require","EntityModel","ApplicationError","ReferencedNotExistError","DuplicateError","ValidationError","InvalidArgument","Types","getValueFrom","mapFilter","defaultNestedKeyGetter","anchor","MySQLEntityModel","hasAutoIncrement","autoId","meta","features","fields","field","autoIncrementId","getNestedObject","entityObj","keyPath","get","split","map","p","join","_translateSymbolToken","name","db","connector","raw","Error","_serializeByTypeInfo","value","info","type","DATETIME","serialize","Array","isArray","csv","ARRAY","toCsv","OBJECT","create_","args","error","errorCode","code","message","updateOne_","_doReplaceOne_","context","ensureTransaction_","entity","findOne_","$query","options","connOptions","ret","$retrieveExisting","rawOptions","$existing","keyField","valueOfKey","omit","$retrieveCreated","$retrieveUpdated","$result","_internalBeforeCreate_","_fillResult","result","affectedRows","insertId","latest","upsert","return","_internalAfterCreate_","$retrieveDbResult","queryKey","getUniqueKeyValuePairsFrom","isEmpty","retrieveOptions","isPlainObject","_internalBeforeUpdate_","_internalBeforeUpdateMany_","_internalAfterUpdate_","changedRows","retrieveUpdated","$retrieveActualUpdated","$retrieveNotUpdate","condition","$bypassEnsureUnique","$relationships","$includeDeleted","$retrieveDeleted","_internalAfterUpdateMany_","findAll_","_internalBeforeDelete_","$physicalDeletion","existing","_internalBeforeDeleteMany_","_internalAfterDelete_","_internalAfterDeleteMany_","_prepareAssociations","findOptions","normalAssocs","customAssocs","partition","$association","assoc","associations","uniq","sort","concat","assocTable","counter","cache","forEach","_translateSchemaNameToDb","alias","joinType","output","key","on","dataset","buildQuery","model","_prepareQueries","$variables","_loadAssocIntoTable","lastPos","lastIndexOf","assocInfo","base","substr","last","baseNode","subAssocs","currentDb","indexOf","schemaName","entityName","app","refDb","database","_mapRecordsToObjects","rows","columns","aliasMap","hierarchy","nestedKeyGetter","mapValues","chain","mainIndex","self","col","table","pos","mergeRecord","existingRow","rowObject","nodePath","each","sql","list","currentPath","push","objKey","subObj","subIndexes","rowKeyValue","isNil","existingSubRow","subIndex","buildSubIndexes","indexes","subObject","arrayOfObjs","tableTemplate","reduce","bucket","row","tableCache","colIdx","forOwn","obj","set","rowKey","_extractAssociations","data","isNew","assocs","refs","v","k","assocMeta","assocAnchor","_populateReferences_","references","refQuery","ReferencedEntity","created","JSON","stringify","_createAssocs_","beforeEntityCreate","keyValue","query","pendingAssocs","finished","passOnOptions","pick","assocModel","castArray","item","assocQuery","refFieldValue","localField","_updateAssocs_","beforeEntityUpdate","forSingleRecord","currentKeyValue","assocKeys","record","assocRecordsToRemove","length","$notIn","deleteMany_","destEntityId","sugar","Object","keys","module","exports"],"sources":["../../../src/drivers/mysql/EntityModel.js"],"sourcesContent":["const { _, eachAsync_ } = require('@genx/july');\nconst EntityModel = require('../../EntityModel');\nconst {\n    ApplicationError,\n    ReferencedNotExistError,\n    DuplicateError,\n    ValidationError,\n    InvalidArgument,\n} = require('../../utils/Errors');\nconst Types = require('../../types');\nconst { getValueFrom, mapFilter } = require('../../utils/lang');\n\nconst defaultNestedKeyGetter = (anchor) => ':' + anchor;\n\n/**\n * MySQL entity model class.\n */\nclass MySQLEntityModel extends EntityModel {\n    /**\n     * [specific] Check if this entity has auto increment feature.\n     */\n    static get hasAutoIncrement() {\n        const autoId = this.meta.features.autoId;\n        return autoId && this.meta.fields[autoId.field].autoIncrementId;\n    }\n\n    /**\n     * [override]\n     * @param {*} entityObj\n     * @param {*} keyPath\n     */\n    static getNestedObject(entityObj, keyPath) {\n        return _.get(\n            entityObj,\n            keyPath\n                .split('.')\n                .map((p) => ':' + p)\n                .join('.')\n        );\n    }\n\n    /**\n     * [override] Serialize value into database acceptable format.\n     * @param {object} name - Name of the symbol token\n     */\n    static _translateSymbolToken(name) {\n        if (name === 'NOW') {\n            return this.db.connector.raw('NOW()');\n        }\n\n        throw new Error('not support: ' + name);\n    }\n\n    /**\n     * [override]\n     * @param {*} value\n     * @param {*} info\n     */\n    static _serializeByTypeInfo(value, info) {\n        if (info.type === 'boolean') {\n            return value ? 1 : 0;\n        }\n\n        if (info.type === 'datetime') {\n            return Types.DATETIME.serialize(value);\n        }\n\n        if (info.type === 'array' && Array.isArray(value)) {\n            if (info.csv) {\n                return Types.ARRAY.toCsv(value);\n            } else {\n                return Types.ARRAY.serialize(value);\n            }\n        }\n\n        if (info.type === 'object') {\n            return Types.OBJECT.serialize(value);\n        }\n\n        return value;\n    }\n\n    static async create_(...args) {\n        try {\n            return await super.create_(...args);\n        } catch (error) {\n            const errorCode = error.code;\n\n            if (errorCode === 'ER_NO_REFERENCED_ROW_2') {\n                throw new ReferencedNotExistError(\n                    'The new entity is referencing to an unexisting entity. Detail: ' +\n                        error.message,\n                    error.info\n                );\n            } else if (errorCode === 'ER_DUP_ENTRY') {\n                throw new DuplicateError(\n                    error.message +\n                        ` while creating a new \"${this.meta.name}\".`,\n                    error.info\n                );\n            }\n\n            throw error;\n        }\n    }\n\n    static async updateOne_(...args) {\n        try {\n            return await super.updateOne_(...args);\n        } catch (error) {\n            const errorCode = error.code;\n\n            if (errorCode === 'ER_NO_REFERENCED_ROW_2') {\n                throw new ReferencedNotExistError(\n                    'The entity to be updated is referencing to an unexisting entity. Detail: ' +\n                        error.message,\n                    error.info\n                );\n            } else if (errorCode === 'ER_DUP_ENTRY') {\n                throw new DuplicateError(\n                    error.message +\n                        ` while updating an existing \"${this.meta.name}\".`,\n                    error.info\n                );\n            }\n\n            throw error;\n        }\n    }\n\n    static async _doReplaceOne_(context) {\n        await this.ensureTransaction_(context);\n\n        const entity = await this.findOne_(\n            { $query: context.options.$query },\n            context.connOptions\n        );\n\n        let ret, options;\n\n        if (entity) {\n            if (context.options.$retrieveExisting) {\n                context.rawOptions.$existing = entity;\n            }\n\n            options = {\n                ...context.options,\n                $query: { [this.meta.keyField]: super.valueOfKey(entity) },\n                $existing: entity,\n            };\n\n            ret = await this.updateOne_(\n                context.raw,\n                options,\n                context.connOptions\n            );\n        } else {\n            options = {\n                ..._.omit(context.options, [\n                    '$retrieveUpdated',\n                    '$bypassEnsureUnique',\n                ]),\n                $retrieveCreated: context.options.$retrieveUpdated,\n            };\n\n            ret = await this.create_(context.raw, options, context.connOptions);\n        }\n\n        if (options.$existing) {\n            context.rawOptions.$existing = options.$existing;\n        }\n\n        if (options.$result) {\n            context.rawOptions.$result = options.$result;\n        }\n\n        return ret;\n    }\n\n    static _internalBeforeCreate_(context) {\n        return true;\n    }\n\n    static _fillResult(context) {\n        if (this.hasAutoIncrement && context.result.affectedRows > 0) {\n            const { insertId } = context.result;\n            if (insertId > 0) {\n                context.latest = {\n                    ...context.latest,\n                    [this.meta.features.autoId.field]: insertId,\n                };\n            } else if (context.result.upsert) {\n                // the key is not correct \n                delete context.latest[this.meta.features.autoId.field];\n            }\n        } else if (context.result.upsert) {\n            // the key is not used \n            delete context.latest[this.meta.keyField];\n        }\n\n        context.return = context.latest;\n    }\n\n    /**\n     * Post create processing.\n     * @param {*} context\n     * @property {object} [context.options] - Create options\n     * @property {bool} [options.$retrieveCreated] - Retrieve the newly created record from db.\n     */\n    static async _internalAfterCreate_(context) {\n        if (context.options.$retrieveDbResult) {\n            context.rawOptions.$result = context.result;\n        }\n\n        if (context.options.$retrieveCreated) {\n            if (this.hasAutoIncrement) {\n                if (context.result.affectedRows === 0) {\n                    // insert ignored\n                    context.queryKey = this.getUniqueKeyValuePairsFrom(\n                        context.latest\n                    );\n\n                    if (_.isEmpty(context.queryKey)) {\n                        throw new ApplicationError(\n                            'Cannot extract unique keys from input data.',\n                            {\n                                entity: this.meta.name,\n                            }\n                        );\n                    }\n                } else {\n                    const { insertId } = context.result;\n                    context.queryKey = {\n                        [this.meta.features.autoId.field]: insertId,\n                    };\n                }\n            } else {\n                context.queryKey = this.getUniqueKeyValuePairsFrom(\n                    context.latest\n                );\n\n                if (_.isEmpty(context.queryKey)) {\n                    throw new ApplicationError(\n                        'Cannot extract unique keys from input data.',\n                        {\n                            entity: this.meta.name,\n                        }\n                    );\n                }\n            }\n\n            const retrieveOptions = _.isPlainObject(\n                context.options.$retrieveCreated\n            )\n                ? context.options.$retrieveCreated\n                : {};\n            context.return = await this.findOne_(\n                { ...retrieveOptions, $query: context.queryKey },\n                context.connOptions\n            );\n        } else {\n            if (this.hasAutoIncrement) {\n                if (context.result.affectedRows === 0) {\n                    context.queryKey = this.getUniqueKeyValuePairsFrom(\n                        context.latest\n                    );\n                } else {\n                    const { insertId } = context.result;\n                    context.queryKey = {\n                        [this.meta.features.autoId.field]: insertId,\n                    };\n                }\n            }\n        }\n    }\n\n    static _internalBeforeUpdate_(context) {\n        return true;\n    }\n\n    static _internalBeforeUpdateMany_(context) {\n        return true;\n    }\n\n    /**\n     * Post update processing.\n     * @param {*} context\n     * @property {object} [context.options] - Update options\n     * @property {bool} [context.options.$retrieveUpdated] - Retrieve the newly updated record from db.\n     */\n    static async _internalAfterUpdate_(context) {\n        const options = context.options;\n\n        if (options.$retrieveDbResult) {\n            context.rawOptions.$result = context.result || {\n                affectedRows: 0,\n                changedRows: 0,\n            };\n        }\n\n        let retrieveUpdated = options.$retrieveUpdated;\n\n        if (!retrieveUpdated) {\n            if (\n                options.$retrieveActualUpdated &&\n                context.result.affectedRows > 0\n            ) {\n                retrieveUpdated = options.$retrieveActualUpdated;\n            } else if (\n                options.$retrieveNotUpdate &&\n                context.result.affectedRows === 0\n            ) {\n                retrieveUpdated = options.$retrieveNotUpdate;\n            }\n        }\n\n        if (retrieveUpdated) {\n            const condition = {\n                $query: this.getUniqueKeyValuePairsFrom(options.$query),\n            };\n            if (options.$bypassEnsureUnique) {\n                condition.$bypassEnsureUnique = options.$bypassEnsureUnique;\n            }\n\n            let retrieveOptions = {};\n\n            if (_.isPlainObject(retrieveUpdated)) {\n                retrieveOptions = retrieveUpdated;\n            } else if (options.$relationships) {\n                retrieveOptions.$relationships = options.$relationships;\n            }\n\n            context.return = await this.findOne_(\n                {\n                    ...condition,\n                    $includeDeleted: options.$retrieveDeleted,\n                    ...retrieveOptions,\n                },\n                context.connOptions\n            );\n\n            if (context.return) {\n                context.queryKey = this.getUniqueKeyValuePairsFrom(\n                    context.return\n                );\n            } else {\n                context.queryKey = condition.$query;\n            }\n        }\n    }\n\n    /**\n     * Post update processing.\n     * @param {*} context\n     * @param {object} [options] - Update options\n     * @property {bool} [options.$retrieveUpdated] - Retrieve the newly updated record from db.\n     */\n    static async _internalAfterUpdateMany_(context) {\n        const options = context.options;\n\n        if (options.$retrieveDbResult) {\n            context.rawOptions.$result = context.result || {\n                affectedRows: 0,\n                changedRows: 0,\n            };\n\n            /**\n             * afterUpdateMany ResultSetHeader {\n             * fieldCount: 0,\n             * affectedRows: 1,\n             * insertId: 0,\n             * info: 'Rows matched: 1  Changed: 1  Warnings: 0',\n             * serverStatus: 3,\n             * warningStatus: 0,\n             * changedRows: 1 }\n             */\n        }\n\n        if (options.$retrieveUpdated) {\n            let retrieveOptions = {};\n\n            if (_.isPlainObject(options.$retrieveUpdated)) {\n                retrieveOptions = options.$retrieveUpdated;\n            } else if (options.$relationships) {\n                retrieveOptions.$relationships = options.$relationships;\n            }\n\n            context.return = await this.findAll_(\n                {\n                    $query: options.$query,\n                    $includeDeleted: options.$retrieveDeleted,\n                    ...retrieveOptions,\n                },\n                context.connOptions\n            );\n        }\n\n        context.queryKey = options.$query;\n    }\n\n    /**\n     * Before deleting an entity.\n     * @param {*} context\n     * @property {object} [context.options] - Delete options\n     * @property {bool} [context.options.$retrieveDeleted] - Retrieve the recently deleted record from db.\n     */\n    static async _internalBeforeDelete_(context) {\n        if (context.options.$retrieveDeleted) {\n            await this.ensureTransaction_(context);\n\n            const retrieveOptions = _.isPlainObject(\n                context.options.$retrieveDeleted\n            )\n                ? {\n                      ...context.options.$retrieveDeleted,\n                      $query: context.options.$query,\n                  }\n                : { $query: context.options.$query };\n\n            if (context.options.$physicalDeletion) {\n                retrieveOptions.$includeDeleted = true;\n            }\n\n            context.return = context.existing = await this.findOne_(\n                retrieveOptions,\n                context.connOptions\n            );\n        }\n\n        return true;\n    }\n\n    static async _internalBeforeDeleteMany_(context) {\n        if (context.options.$retrieveDeleted) {\n            await this.ensureTransaction_(context);\n\n            const retrieveOptions = _.isPlainObject(\n                context.options.$retrieveDeleted\n            )\n                ? {\n                      ...context.options.$retrieveDeleted,\n                      $query: context.options.$query,\n                  }\n                : { $query: context.options.$query };\n\n            if (context.options.$physicalDeletion) {\n                retrieveOptions.$includeDeleted = true;\n            }\n\n            context.return = context.existing = await this.findAll_(\n                retrieveOptions,\n                context.connOptions\n            );\n        }\n\n        return true;\n    }\n\n    /**\n     * Post delete processing.\n     * @param {*} context\n     */\n    static _internalAfterDelete_(context) {\n        if (context.options.$retrieveDbResult) {\n            context.rawOptions.$result = context.result;\n        }\n    }\n\n    /**\n     * Post delete processing.\n     * @param {*} context\n     */\n    static _internalAfterDeleteMany_(context) {\n        if (context.options.$retrieveDbResult) {\n            context.rawOptions.$result = context.result;\n        }\n    }\n\n    /**\n     *\n     * @param {*} findOptions\n     */\n    static _prepareAssociations(findOptions) {\n        const [normalAssocs, customAssocs] = _.partition(\n            findOptions.$association,\n            (assoc) => typeof assoc === 'string'\n        );\n\n        const associations = _.uniq(normalAssocs).sort().concat(customAssocs);\n        const assocTable = {};\n            let counter = 0;\n            const cache = {};\n\n        associations.forEach((assoc) => {\n            if (_.isPlainObject(assoc)) {\n                assoc = this._translateSchemaNameToDb(assoc);\n\n                let alias = assoc.alias;\n                if (!assoc.alias) {\n                    alias = ':join' + ++counter;\n                }\n\n                assocTable[alias] = {\n                    entity: assoc.entity,\n                    joinType: assoc.type,\n                    output: assoc.output,\n                    key: assoc.key,\n                    alias,\n                    on: assoc.on,\n                    ...(assoc.dataset\n                        ? this.db.connector.buildQuery(\n                              assoc.entity,\n                              assoc.model._prepareQueries({\n                                  ...assoc.dataset,\n                                  $variables: findOptions.$variables,\n                              })\n                          )\n                        : {}),\n                };\n            } else {\n                this._loadAssocIntoTable(assocTable, cache, assoc);\n            }\n        });\n\n        return assocTable;\n    }\n\n    /**\n     *\n     * @param {*} assocTable - Hierarchy with subAssocs\n     * @param {*} cache - Dotted path as key\n     * @param {*} assoc - Dotted path\n     */\n    static _loadAssocIntoTable(assocTable, cache, assoc) {\n        if (cache[assoc]) return cache[assoc];\n\n        const lastPos = assoc.lastIndexOf('.');\n        let result;\n\n        if (lastPos === -1) {\n            // direct association\n            const assocInfo = { ...this.meta.associations[assoc] };\n            if (_.isEmpty(assocInfo)) {\n                throw new InvalidArgument(\n                    `Entity \"${this.meta.name}\" does not have the association \"${assoc}\".`\n                );\n            }\n\n            result =\n                cache[assoc] =\n                assocTable[assoc] =\n                    { ...this._translateSchemaNameToDb(assocInfo) };\n        } else {\n            const base = assoc.substr(0, lastPos);\n            const last = assoc.substr(lastPos + 1);\n\n            let baseNode = cache[base];\n            if (!baseNode) {\n                baseNode = this._loadAssocIntoTable(assocTable, cache, base);\n            }\n\n            const entity = baseNode.model || this.db.model(baseNode.entity);\n            const assocInfo = { ...entity.meta.associations[last] };\n            if (_.isEmpty(assocInfo)) {\n                throw new InvalidArgument(\n                    `Entity \"${entity.meta.name}\" does not have the association \"${assoc}\".`\n                );\n            }\n\n            result = { ...entity._translateSchemaNameToDb(assocInfo, this.db) };\n\n            if (!baseNode.subAssocs) {\n                baseNode.subAssocs = {};\n            }\n\n            cache[assoc] = baseNode.subAssocs[last] = result;\n        }\n\n        if (result.assoc) {\n            this._loadAssocIntoTable(\n                assocTable,\n                cache,\n                assoc + '.' + result.assoc\n            );\n        }\n\n        return result;\n    }\n\n    static _translateSchemaNameToDb(assoc, currentDb) {\n        if (!assoc.entity) {\n            throw new ApplicationError('\"entity\" is required in the association object.');\n        }\n\n        if (assoc.entity.indexOf('.') > 0) {\n            const [schemaName, entityName] = assoc.entity.split('.', 2);\n\n            const app = this.db.app;\n\n            const refDb = app.db(schemaName);\n            if (!refDb) {\n                throw new ApplicationError(\n                    `The referenced schema \"${schemaName}\" does not have db model in the same application.`\n                );\n            }\n\n            assoc.entity = refDb.connector.database + '.' + entityName;\n            assoc.model = refDb.model(entityName);\n\n            if (!assoc.model) {\n                throw new ApplicationError(\n                    `Failed load the entity model \"${schemaName}.${entityName}\".`\n                );\n            }\n        } else {\n            assoc.model = this.db.model(assoc.entity);\n\n            if (currentDb && currentDb !== this.db) {\n                assoc.entity = this.db.connector.database + '.' + assoc.entity;\n            }\n        }\n\n        if (!assoc.key) {\n            assoc.key = assoc.model.meta.keyField;\n        }\n\n        return assoc;\n    }\n\n    static _mapRecordsToObjects(\n        [rows, columns, aliasMap],\n        hierarchy,\n        nestedKeyGetter\n    ) {\n        nestedKeyGetter == null && (nestedKeyGetter = defaultNestedKeyGetter);\n        aliasMap = _.mapValues(aliasMap, (chain) =>\n            chain.map((anchor) => nestedKeyGetter(anchor))\n        );\n\n        const mainIndex = {};\n        const self = this;\n\n        // map mysql column result into array of { table <table alias>, name: <column name> }\n        columns = columns.map((col) => {\n            if (col.table === '') {\n                const pos = col.name.indexOf('$');\n                if (pos > 0) {\n                    return {\n                        table: col.name.substr(0, pos),\n                        name: col.name.substr(pos + 1),\n                    };\n                }\n\n                return {\n                    table: 'A',\n                    name: col.name,\n                };\n            }\n\n            return {\n                table: col.table,\n                name: col.name,\n            };\n        });\n\n        // map flat record into hierachy\n        function mergeRecord(existingRow, rowObject, associations, nodePath) {\n            return _.each(\n                associations,\n                ({ sql, key, list, subAssocs }, anchor) => {\n                    if (sql) return;\n\n                    const currentPath = nodePath.concat();\n                    currentPath.push(anchor);\n\n                    const objKey = nestedKeyGetter(anchor);\n                    const subObj = rowObject[objKey];\n\n                    if (!subObj) {\n                        // associated entity not in result set, probably when custom projection is used\n                        return;\n                    }\n\n                    const subIndexes = existingRow.subIndexes[objKey];\n\n                    // joined an empty record\n                    const rowKeyValue = subObj[key];\n                    if (_.isNil(rowKeyValue)) {\n                        if (list && rowKeyValue == null) {\n                            if (existingRow.rowObject[objKey]) {\n                                existingRow.rowObject[objKey].push(subObj);\n                            } else {\n                                existingRow.rowObject[objKey] = [subObj];\n                            }\n                        }\n\n                        return;\n                    }\n\n                    const existingSubRow = subIndexes && subIndexes[rowKeyValue];\n                    if (existingSubRow) {\n                        if (subAssocs) {\n                            return mergeRecord(\n                                existingSubRow,\n                                subObj,\n                                subAssocs,\n                                currentPath\n                            );\n                        }\n                    } else {\n                        if (!list) {\n                            throw new ApplicationError(\n                                `The structure of association \"${currentPath.join(\n                                    '.'\n                                )}\" with [key=${key}] of entity \"${\n                                    self.meta.name\n                                }\" should be a list.`,\n                                { existingRow, rowObject }\n                            );\n                        }\n\n                        if (existingRow.rowObject[objKey]) {\n                            existingRow.rowObject[objKey].push(subObj);\n                        } else {\n                            existingRow.rowObject[objKey] = [subObj];\n                        }\n\n                        const subIndex = {\n                            rowObject: subObj,\n                        };\n\n                        if (subAssocs) {\n                            subIndex.subIndexes = buildSubIndexes(\n                                subObj,\n                                subAssocs\n                            );\n                        }\n\n                        if (!subIndexes) {\n                            throw new ApplicationError(\n                                `The subIndexes of association \"${currentPath.join(\n                                    '.'\n                                )}\" with [key=${key}] of entity \"${\n                                    self.meta.name\n                                }\" does not exist.`,\n                                { existingRow, rowObject }\n                            );\n                        }\n\n                        subIndexes[rowKeyValue] = subIndex;\n                    }\n                }\n            );\n        }\n\n        // build sub index for list member\n        function buildSubIndexes(rowObject, associations) {\n            const indexes = {};\n\n            _.each(associations, ({ sql, key, list, subAssocs }, anchor) => {\n                if (sql) {\n                    return;\n                }\n\n                const objKey = nestedKeyGetter(anchor);\n                let subObject = rowObject[objKey];\n                const subIndex = {\n                    rowObject: subObject,\n                };\n\n                if (list) {\n                    if (!subObject) {\n                        // associated entity not in result set, probably when custom projection is used\n                        rowObject[objKey] = [];\n                        return;\n                    }\n\n                    rowObject[objKey] = [subObject];\n\n                    // many to *\n                    if (_.isNil(subObject[key])) {\n                        // when custom projection is used\n                        subObject = null;\n                    }\n                }\n\n                if (subObject) {\n                    if (subAssocs) {\n                        subIndex.subIndexes = buildSubIndexes(\n                            subObject,\n                            subAssocs\n                        );\n                    }\n\n                    indexes[objKey] = subObject[key]\n                        ? {\n                              [subObject[key]]: subIndex,\n                          }\n                        : {};\n                }\n            });\n\n            return indexes;\n        }\n\n        const arrayOfObjs = [];\n\n        // build the result object skeleton\n        const tableTemplate = columns.reduce((result, col) => {\n            if (col.table !== 'A') {\n                const bucket = result[col.table];\n                if (bucket) {\n                    bucket[col.name] = null;\n                } else {\n                    result[col.table] = { [col.name]: null };\n                }\n            }\n\n            return result;\n        }, {});\n\n        // process each row\n        rows.forEach((row) => {\n            const tableCache = {}; // from alias to child prop of rowObject\n\n            // hash-style data row\n            const rowObject = row.reduce((result, value, colIdx) => {\n                const col = columns[colIdx];\n\n                if (col.table === 'A') {\n                    result[col.name] = value;\n                } else if (value != null) {\n                    // avoid a object with all null value exists\n                    const bucket = tableCache[col.table];\n                    if (bucket) {\n                        // already nested inside\n                        bucket[col.name] = value;\n                    } else {\n                        tableCache[col.table] = {\n                            ...tableTemplate[col.table],\n                            [col.name]: value,\n                        };\n                    }\n                }\n\n                return result;\n            }, {});\n\n            _.forOwn(tableCache, (obj, table) => {\n                const nodePath = aliasMap[table];\n                _.set(rowObject, nodePath, obj);\n            });\n\n            const rowKey = rowObject[self.meta.keyField];\n            const existingRow = mainIndex[rowKey];\n            if (existingRow) {\n                return mergeRecord(existingRow, rowObject, hierarchy, []);\n            }\n\n            arrayOfObjs.push(rowObject);\n            mainIndex[rowKey] = {\n                rowObject,\n                subIndexes: buildSubIndexes(rowObject, hierarchy),\n            };\n        });\n\n        return arrayOfObjs;\n    }\n\n    /**\n     * Pre-process assoicated db operation\n     * @param {*} data\n     * @param {*} isNew - New record flag, true for creating, false for updating\n     * @returns {Array} [raw, assocs, refs];\n     */\n    static _extractAssociations(data, isNew) {\n        const raw = {};\n            const assocs = {};\n            const refs = {};\n        const meta = this.meta.associations;\n\n        _.forOwn(data, (v, k) => {\n            if (k[0] === ':') {\n                // cascade update\n                const anchor = k.substr(1);\n                const assocMeta = meta[anchor];\n                if (!assocMeta) {\n                    throw new ValidationError(\n                        `Unknown association \"${anchor}\" of entity \"${this.meta.name}\".`\n                    );\n                }\n\n                if (\n                    isNew &&\n                    (assocMeta.type === 'refersTo' ||\n                        assocMeta.type === 'belongsTo') &&\n                    anchor in data\n                ) {\n                    throw new ValidationError(\n                        `Association data \":${anchor}\" of entity \"${this.meta.name}\" conflicts with input value of field \"${anchor}\".`\n                    );\n                }\n\n                assocs[anchor] = v;\n            } else if (k[0] === '@') {\n                // update by reference\n                const anchor = k.substr(1);\n                const assocMeta = meta[anchor];\n                if (!assocMeta) {\n                    throw new ValidationError(\n                        `Unknown association \"${anchor}\" of entity \"${this.meta.name}\".`\n                    );\n                }\n\n                if (\n                    assocMeta.type !== 'refersTo' &&\n                    assocMeta.type !== 'belongsTo'\n                ) {\n                    throw new ValidationError(\n                        `Association type \"${assocMeta.type}\" cannot be used for update by reference.`,\n                        {\n                            entity: this.meta.name,\n                            data,\n                        }\n                    );\n                }\n\n                if (isNew && anchor in data) {\n                    throw new ValidationError(\n                        `Association reference \"@${anchor}\" of entity \"${this.meta.name}\" conflicts with input value of field \"${anchor}\".`\n                    );\n                }\n\n                const assocAnchor = ':' + anchor;\n                if (assocAnchor in data) {\n                    throw new ValidationError(\n                        `Association reference \"@${anchor}\" of entity \"${this.meta.name}\" conflicts with association data \"${assocAnchor}\".`\n                    );\n                }\n\n                if (v == null) {\n                    raw[anchor] = null;\n                } else {\n                    refs[anchor] = v;\n                }\n            } else {\n                raw[k] = v;\n            }\n        });\n\n        return [raw, assocs, refs];\n    }\n\n    static async _populateReferences_(context, references) {\n        const meta = this.meta.associations;\n\n        await eachAsync_(references, async (refQuery, anchor) => {\n            const assocMeta = meta[anchor];\n            const ReferencedEntity = this.db.model(assocMeta.entity);\n\n            const created = await ReferencedEntity.findOne_(\n                refQuery,\n                context.connOptions\n            );\n\n            if (!created) {\n                throw new ReferencedNotExistError(\n                    `Referenced entity \"${\n                        ReferencedEntity.meta.name\n                    }\" with ${JSON.stringify(refQuery)} not exist.`\n                );\n            }\n\n            context.raw[anchor] = created[assocMeta.field];\n        });\n    }\n\n    static async _createAssocs_(context, assocs, beforeEntityCreate) {\n        const meta = this.meta.associations;\n        let keyValue;\n\n        if (!beforeEntityCreate) {\n            keyValue = context.return[this.meta.keyField];\n\n            if (_.isNil(keyValue)) {\n                if (context.result.affectedRows === 0) {\n                    // insert ignored\n\n                    const query = this.getUniqueKeyValuePairsFrom(\n                        context.return\n                    );\n                    context.return = await this.findOne_(\n                        { $query: query },\n                        context.connOptions\n                    );\n                    if (!context.return) {\n                        throw new ApplicationError(\n                            'The parent entity is duplicated on unique keys different from the pair of keys used to query',\n                            {\n                                query,\n                                data: context.return,\n                                associations: assocs,\n                            }\n                        );\n                    }\n                }\n\n                keyValue = context.return[this.meta.keyField];\n\n                if (_.isNil(keyValue)) {\n                    throw new ApplicationError(\n                        'Missing required primary key field value. Entity: ' +\n                            this.meta.name,\n                        {\n                            data: context.return,\n                            associations: assocs,\n                        }\n                    );\n                }\n            }\n        }\n\n        const pendingAssocs = {};\n        const finished = {};\n\n        // todo: double check to ensure including all required options\n        const passOnOptions = _.pick(context.options, [\n            '$skipModifiers',\n            '$migration',\n            '$variables',\n            '$upsert',\n            '$dryRun'\n        ]);\n\n        await eachAsync_(assocs, async (data, anchor) => {\n            const assocMeta = meta[anchor];\n\n            if (\n                beforeEntityCreate &&\n                assocMeta.type !== 'refersTo' &&\n                assocMeta.type !== 'belongsTo'\n            ) {\n                pendingAssocs[anchor] = data;\n                return;\n            }\n\n            const assocModel = this.db.model(assocMeta.entity);\n\n            if (assocMeta.list) {\n                data = _.castArray(data);\n\n                if (!assocMeta.field) {\n                    throw new ApplicationError(\n                        `Missing \"field\" property in the metadata of association \"${anchor}\" of entity \"${this.meta.name}\".`\n                    );\n                }\n\n                return eachAsync_(data, (item) =>\n                    assocModel.create_(\n                        { ...item, [assocMeta.field]: keyValue },\n                        passOnOptions,\n                        context.connOptions\n                    )\n                );\n            } else if (!_.isPlainObject(data)) {\n                if (Array.isArray(data)) {\n                    throw new ApplicationError(\n                        `Invalid type of associated entity (${assocMeta.entity}) data triggered from \"${this.meta.name}\" entity. Singular value expected (${anchor}), but an array is given instead.`\n                    );\n                }\n\n                if (!assocMeta.assoc) {\n                    throw new ApplicationError(\n                        `The associated field of relation \"${anchor}\" does not exist in the entity meta data.`\n                    );\n                }\n\n                data = { [assocMeta.assoc]: data };\n            }\n\n            if (!beforeEntityCreate && assocMeta.field) {\n                // hasMany or hasOne\n                data = { ...data, [assocMeta.field]: keyValue };\n            }\n\n            passOnOptions.$retrieveDbResult = true;\n            let created = await assocModel.create_(\n                data,\n                passOnOptions,\n                context.connOptions\n            );\n\n            if (\n                passOnOptions.$result.affectedRows === 0 ||\n                (assocModel.hasAutoIncrement &&\n                    passOnOptions.$result.insertId === 0)\n            ) {\n                // insert ignored or upserted\n\n                const assocQuery = assocModel.getUniqueKeyValuePairsFrom(data);\n\n                created = await assocModel.findOne_(\n                    { $query: assocQuery },\n                    context.connOptions\n                );\n                if (!created) {\n                    throw new ApplicationError(\n                        'The assoicated entity is duplicated on unique keys different from the pair of keys used to query',\n                        {\n                            query: assocQuery,\n                            data,\n                        }\n                    );\n                }\n            }\n\n            finished[anchor] = beforeEntityCreate\n                ? created[assocMeta.field]\n                : created[assocMeta.key];\n        });\n\n        if (beforeEntityCreate) {\n            _.forOwn(finished, (refFieldValue, localField) => {\n                context.raw[localField] = refFieldValue;\n            });\n        }\n\n        return pendingAssocs;\n    }\n\n    static async _updateAssocs_(\n        context,\n        assocs,\n        beforeEntityUpdate,\n        forSingleRecord\n    ) {\n        const meta = this.meta.associations;\n\n        let currentKeyValue;\n\n        if (!beforeEntityUpdate) {\n            currentKeyValue = getValueFrom(\n                [context.options.$query, context.return],\n                this.meta.keyField\n            );\n            if (_.isNil(currentKeyValue)) {\n                // should have in updating\n                throw new ApplicationError(\n                    'Missing required primary key field value. Entity: ' +\n                        this.meta.name\n                );\n            }\n        }\n\n        const pendingAssocs = {};\n\n        // todo: double check to ensure including all required options\n        const passOnOptions = _.pick(context.options, [\n            '$skipModifiers',\n            '$migration',\n            '$variables',\n            '$upsert',\n        ]);\n\n        await eachAsync_(assocs, async (data, anchor) => {\n            const assocMeta = meta[anchor];\n\n            if (\n                beforeEntityUpdate &&\n                assocMeta.type !== 'refersTo' &&\n                assocMeta.type !== 'belongsTo'\n            ) {\n                pendingAssocs[anchor] = data;\n                return;\n            }\n\n            const assocModel = this.db.model(assocMeta.entity);\n\n            if (assocMeta.list) {\n                data = _.castArray(data);\n\n                if (!assocMeta.field) {\n                    throw new ApplicationError(\n                        `Missing \"field\" property in the metadata of association \"${anchor}\" of entity \"${this.meta.name}\".`\n                    );\n                }\n\n                const assocKeys = mapFilter(\n                    data,\n                    (record) => record[assocMeta.key] != null,\n                    (record) => record[assocMeta.key]\n                );\n                const assocRecordsToRemove = {\n                    [assocMeta.field]: currentKeyValue,\n                };\n                if (assocKeys.length > 0) {\n                    assocRecordsToRemove[assocMeta.key] = { $notIn: assocKeys };\n                }\n\n                await assocModel.deleteMany_(\n                    assocRecordsToRemove,\n                    context.connOptions\n                );\n\n                return eachAsync_(data, (item) =>\n                    item[assocMeta.key] != null\n                        ? assocModel.updateOne_(\n                              {\n                                  ..._.omit(item, [assocMeta.key]),\n                                  [assocMeta.field]: currentKeyValue,\n                              },\n                              {\n                                  $query: {\n                                      [assocMeta.key]: item[assocMeta.key],\n                                  },\n                                  ...passOnOptions,\n                              },\n                              context.connOptions\n                          )\n                        : assocModel.create_(\n                              { ...item, [assocMeta.field]: currentKeyValue },\n                              passOnOptions,\n                              context.connOptions\n                          )\n                );\n            } else if (!_.isPlainObject(data)) {\n                if (Array.isArray(data)) {\n                    throw new ApplicationError(\n                        `Invalid type of associated entity (${assocMeta.entity}) data triggered from \"${this.meta.name}\" entity. Singular value expected (${anchor}), but an array is given instead.`\n                    );\n                }\n\n                if (!assocMeta.assoc) {\n                    throw new ApplicationError(\n                        `The associated field of relation \"${anchor}\" does not exist in the entity meta data.`\n                    );\n                }\n\n                // connected by\n                data = { [assocMeta.assoc]: data };\n            }\n\n            if (beforeEntityUpdate) {\n                if (_.isEmpty(data)) return;\n\n                // refersTo or belongsTo\n                let destEntityId = getValueFrom(\n                    [context.existing, context.options.$query, context.raw],\n                    anchor\n                );\n\n                if (destEntityId == null) {\n                    if (_.isEmpty(context.existing)) {\n                        context.existing = await this.findOne_(\n                            context.options.$query,\n                            context.connOptions\n                        );\n                        if (!context.existing) {\n                            throw new ValidationError(\n                                `Specified \"${this.meta.name}\" not found.`,\n                                {\n                                    query: context.options.$query,\n                                }\n                            );\n                        }\n                        destEntityId = context.existing[anchor];\n                    }\n\n                    if (destEntityId == null) {\n                        if (!(anchor in context.existing)) {\n                            throw new ApplicationError(\n                                'Existing entity record does not contain the referenced entity id.',\n                                {\n                                    anchor,\n                                    data,\n                                    existing: context.existing,\n                                    query: context.options.$query,\n                                    raw: context.raw,\n                                }\n                            );\n                        }\n\n                        // to create the associated, existing is null\n\n                        passOnOptions.$retrieveDbResult = true;\n                        let created = await assocModel.create_(\n                            data,\n                            passOnOptions,\n                            context.connOptions\n                        );\n\n                        if (passOnOptions.$result.affectedRows === 0) {\n                            // insert ignored\n\n                            const assocQuery =\n                                assocModel.getUniqueKeyValuePairsFrom(data);\n                            created = await assocModel.findOne_(\n                                { $query: assocQuery },\n                                context.connOptions\n                            );\n                            if (!created) {\n                                throw new ApplicationError(\n                                    'The assoicated entity is duplicated on unique keys different from the pair of keys used to query',\n                                    {\n                                        query: assocQuery,\n                                        data,\n                                    }\n                                );\n                            }\n                        }\n\n                        context.raw[anchor] = created[assocMeta.field];\n                        return;\n                    }\n                }\n\n                if (destEntityId) {\n                    return assocModel.updateOne_(\n                        data,\n                        { [assocMeta.field]: destEntityId, ...passOnOptions },\n                        context.connOptions\n                    );\n                }\n\n                // nothing to do for null dest entity id\n                return;\n            }\n\n            await assocModel.deleteMany_(\n                { [assocMeta.field]: currentKeyValue },\n                context.connOptions\n            );\n\n            if (forSingleRecord) {\n                return assocModel.create_(\n                    { ...data, [assocMeta.field]: currentKeyValue },\n                    passOnOptions,\n                    context.connOptions\n                );\n            }\n\n            throw new Error(\n                'update associated data for multiple records not implemented'\n            );\n\n            // return assocModel.replaceOne_({ ...data, ...(assocMeta.field ? { [assocMeta.field]: keyValue } : {}) }, null, context.connOptions);\n        });\n\n        return pendingAssocs;\n    }\n}\n\nconst sugar = require('./mixin/sugar');\nfor (const key of Object.keys(sugar)) {\n    MySQLEntityModel[key] = sugar[key];\n}\n\nmodule.exports = MySQLEntityModel;\n"],"mappings":"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"}