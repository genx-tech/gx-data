"use strict";

require("source-map-support/register");

const {
  _
} = require('@genx/july');

const {
  DateTime
} = require('luxon');

const any = require('./any');

const {
  ValidationError
} = require('../utils/Errors');

module.exports = {
  name: 'datetime',
  typeObject: DateTime,
  alias: ['date', 'time', 'timestamp'],
  sanitize: (value, info, i18n) => {
    if (value == null) return null;
    let opts = {
      zone: (i18n === null || i18n === void 0 ? void 0 : i18n.timezone) || 'local'
    };
    let raw = value;

    if (value instanceof Date) {
      value = DateTime.fromJSDate(value, opts);
    } else {
      let type = typeof value;

      if (type === 'string' && !info.dontParse) {
        if (info.inputFormat) {
          value = DateTime.fromFormat(value, info.inputFormat, opts);
        } else {
          value = DateTime.fromISO(value, opts);
        }
      } else if (type === 'number') {
        value = DateTime.fromMillis(value, opts);
      } else if (type !== 'object' || !value.isLuxonDateTime) {
        throw new ValidationError('Invalid datetime object.', {
          value: raw,
          field: info
        });
      }
    }

    if (!value.isValid) {
      throw new ValidationError('Invalid datetime object.', {
        value: raw,
        field: info
      });
    }

    return value;
  },
  defaultValue: 0,
  generate: (info, i18n) => i18n ? i18n.now() : DateTime.local(),
  serialize: value => {
    if (value && value.toISO) {
      return value.toISO({
        includeOffset: false
      });
    }

    return value;
  },
  qualifiers: any.qualifiers.concat(['timezone', 'dateOnly', 'timeOnly', 'inputFormat', 'dontParse'])
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy90eXBlcy9kYXRldGltZS5qcyJdLCJuYW1lcyI6WyJfIiwicmVxdWlyZSIsIkRhdGVUaW1lIiwiYW55IiwiVmFsaWRhdGlvbkVycm9yIiwibW9kdWxlIiwiZXhwb3J0cyIsIm5hbWUiLCJ0eXBlT2JqZWN0IiwiYWxpYXMiLCJzYW5pdGl6ZSIsInZhbHVlIiwiaW5mbyIsImkxOG4iLCJvcHRzIiwiem9uZSIsInRpbWV6b25lIiwicmF3IiwiRGF0ZSIsImZyb21KU0RhdGUiLCJ0eXBlIiwiZG9udFBhcnNlIiwiaW5wdXRGb3JtYXQiLCJmcm9tRm9ybWF0IiwiZnJvbUlTTyIsImZyb21NaWxsaXMiLCJpc0x1eG9uRGF0ZVRpbWUiLCJmaWVsZCIsImlzVmFsaWQiLCJkZWZhdWx0VmFsdWUiLCJnZW5lcmF0ZSIsIm5vdyIsImxvY2FsIiwic2VyaWFsaXplIiwidG9JU08iLCJpbmNsdWRlT2Zmc2V0IiwicXVhbGlmaWVycyIsImNvbmNhdCJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7QUFFQSxNQUFNO0FBQUVBLEVBQUFBO0FBQUYsSUFBUUMsT0FBTyxDQUFDLFlBQUQsQ0FBckI7O0FBQ0EsTUFBTTtBQUFFQyxFQUFBQTtBQUFGLElBQWVELE9BQU8sQ0FBQyxPQUFELENBQTVCOztBQUNBLE1BQU1FLEdBQUcsR0FBR0YsT0FBTyxDQUFDLE9BQUQsQ0FBbkI7O0FBQ0EsTUFBTTtBQUFFRyxFQUFBQTtBQUFGLElBQXNCSCxPQUFPLENBQUMsaUJBQUQsQ0FBbkM7O0FBRUFJLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQjtBQUNiQyxFQUFBQSxJQUFJLEVBQUUsVUFETztBQUdiQyxFQUFBQSxVQUFVLEVBQUVOLFFBSEM7QUFLYk8sRUFBQUEsS0FBSyxFQUFFLENBQUUsTUFBRixFQUFVLE1BQVYsRUFBa0IsV0FBbEIsQ0FMTTtBQU9iQyxFQUFBQSxRQUFRLEVBQUUsQ0FBQ0MsS0FBRCxFQUFRQyxJQUFSLEVBQWNDLElBQWQsS0FBdUI7QUFDN0IsUUFBSUYsS0FBSyxJQUFJLElBQWIsRUFBbUIsT0FBTyxJQUFQO0FBRW5CLFFBQUlHLElBQUksR0FBRztBQUFFQyxNQUFBQSxJQUFJLEVBQUUsQ0FBQUYsSUFBSSxTQUFKLElBQUFBLElBQUksV0FBSixZQUFBQSxJQUFJLENBQUVHLFFBQU4sS0FBa0I7QUFBMUIsS0FBWDtBQUVBLFFBQUlDLEdBQUcsR0FBR04sS0FBVjs7QUFFQSxRQUFJQSxLQUFLLFlBQVlPLElBQXJCLEVBQTJCO0FBQ3ZCUCxNQUFBQSxLQUFLLEdBQUdULFFBQVEsQ0FBQ2lCLFVBQVQsQ0FBb0JSLEtBQXBCLEVBQTJCRyxJQUEzQixDQUFSO0FBQ0gsS0FGRCxNQUVPO0FBQ0gsVUFBSU0sSUFBSSxHQUFHLE9BQU9ULEtBQWxCOztBQUVBLFVBQUlTLElBQUksS0FBSyxRQUFULElBQXFCLENBQUNSLElBQUksQ0FBQ1MsU0FBL0IsRUFBMEM7QUFDdEMsWUFBSVQsSUFBSSxDQUFDVSxXQUFULEVBQXNCO0FBQ2xCWCxVQUFBQSxLQUFLLEdBQUdULFFBQVEsQ0FBQ3FCLFVBQVQsQ0FBb0JaLEtBQXBCLEVBQTJCQyxJQUFJLENBQUNVLFdBQWhDLEVBQTZDUixJQUE3QyxDQUFSO0FBQ0gsU0FGRCxNQUVPO0FBQ0hILFVBQUFBLEtBQUssR0FBR1QsUUFBUSxDQUFDc0IsT0FBVCxDQUFpQmIsS0FBakIsRUFBd0JHLElBQXhCLENBQVI7QUFDSDtBQUNKLE9BTkQsTUFNTyxJQUFJTSxJQUFJLEtBQUssUUFBYixFQUF1QjtBQUMxQlQsUUFBQUEsS0FBSyxHQUFHVCxRQUFRLENBQUN1QixVQUFULENBQW9CZCxLQUFwQixFQUEyQkcsSUFBM0IsQ0FBUjtBQUNILE9BRk0sTUFFQSxJQUFJTSxJQUFJLEtBQUssUUFBVCxJQUFxQixDQUFDVCxLQUFLLENBQUNlLGVBQWhDLEVBQWlEO0FBQ3BELGNBQU0sSUFBSXRCLGVBQUosQ0FBb0IsMEJBQXBCLEVBQWdEO0FBQUVPLFVBQUFBLEtBQUssRUFBRU0sR0FBVDtBQUFjVSxVQUFBQSxLQUFLLEVBQUVmO0FBQXJCLFNBQWhELENBQU47QUFDSDtBQUNKOztBQUVELFFBQUksQ0FBQ0QsS0FBSyxDQUFDaUIsT0FBWCxFQUFvQjtBQUNoQixZQUFNLElBQUl4QixlQUFKLENBQW9CLDBCQUFwQixFQUFnRDtBQUFFTyxRQUFBQSxLQUFLLEVBQUVNLEdBQVQ7QUFBY1UsUUFBQUEsS0FBSyxFQUFFZjtBQUFyQixPQUFoRCxDQUFOO0FBQ0g7O0FBRUQsV0FBT0QsS0FBUDtBQUNILEdBckNZO0FBdUNia0IsRUFBQUEsWUFBWSxFQUFFLENBdkNEO0FBeUNiQyxFQUFBQSxRQUFRLEVBQUUsQ0FBQ2xCLElBQUQsRUFBT0MsSUFBUCxLQUFnQkEsSUFBSSxHQUFHQSxJQUFJLENBQUNrQixHQUFMLEVBQUgsR0FBZ0I3QixRQUFRLENBQUM4QixLQUFULEVBekNqQztBQTJDYkMsRUFBQUEsU0FBUyxFQUFFdEIsS0FBSyxJQUFJO0FBQ2hCLFFBQUlBLEtBQUssSUFBSUEsS0FBSyxDQUFDdUIsS0FBbkIsRUFBMEI7QUFDdEIsYUFBT3ZCLEtBQUssQ0FBQ3VCLEtBQU4sQ0FBWTtBQUFFQyxRQUFBQSxhQUFhLEVBQUU7QUFBakIsT0FBWixDQUFQO0FBQ0g7O0FBRUQsV0FBT3hCLEtBQVA7QUFDSCxHQWpEWTtBQW1EYnlCLEVBQUFBLFVBQVUsRUFBRWpDLEdBQUcsQ0FBQ2lDLFVBQUosQ0FBZUMsTUFBZixDQUFzQixDQUM5QixVQUQ4QixFQUU5QixVQUY4QixFQUc5QixVQUg4QixFQUk5QixhQUo4QixFQUs5QixXQUw4QixDQUF0QjtBQW5EQyxDQUFqQiIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCB7IF8gfSA9IHJlcXVpcmUoJ0BnZW54L2p1bHknKTtcbmNvbnN0IHsgRGF0ZVRpbWUgfSA9IHJlcXVpcmUoJ2x1eG9uJyk7XG5jb25zdCBhbnkgPSByZXF1aXJlKCcuL2FueScpO1xuY29uc3QgeyBWYWxpZGF0aW9uRXJyb3IgfSA9IHJlcXVpcmUoJy4uL3V0aWxzL0Vycm9ycycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBuYW1lOiAnZGF0ZXRpbWUnLFxuXG4gICAgdHlwZU9iamVjdDogRGF0ZVRpbWUsXG5cbiAgICBhbGlhczogWyAnZGF0ZScsICd0aW1lJywgJ3RpbWVzdGFtcCcgXSxcblxuICAgIHNhbml0aXplOiAodmFsdWUsIGluZm8sIGkxOG4pID0+IHsgICBcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiBudWxsO1xuICAgICAgICBcbiAgICAgICAgbGV0IG9wdHMgPSB7IHpvbmU6IGkxOG4/LnRpbWV6b25lIHx8ICdsb2NhbCcgfTtcblxuICAgICAgICBsZXQgcmF3ID0gdmFsdWU7XG5cbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgdmFsdWUgPSBEYXRlVGltZS5mcm9tSlNEYXRlKHZhbHVlLCBvcHRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgICBcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiAhaW5mby5kb250UGFyc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5mby5pbnB1dEZvcm1hdCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IERhdGVUaW1lLmZyb21Gb3JtYXQodmFsdWUsIGluZm8uaW5wdXRGb3JtYXQsIG9wdHMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gRGF0ZVRpbWUuZnJvbUlTTyh2YWx1ZSwgb3B0cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gRGF0ZVRpbWUuZnJvbU1pbGxpcyh2YWx1ZSwgb3B0cyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgIT09ICdvYmplY3QnIHx8ICF2YWx1ZS5pc0x1eG9uRGF0ZVRpbWUpIHsgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcignSW52YWxpZCBkYXRldGltZSBvYmplY3QuJywgeyB2YWx1ZTogcmF3LCBmaWVsZDogaW5mbyB9KTtcbiAgICAgICAgICAgIH0gICAgICAgICAgICAgXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmICghdmFsdWUuaXNWYWxpZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcignSW52YWxpZCBkYXRldGltZSBvYmplY3QuJywgeyB2YWx1ZTogcmF3LCBmaWVsZDogaW5mbyB9KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG5cbiAgICBkZWZhdWx0VmFsdWU6IDAsXG5cbiAgICBnZW5lcmF0ZTogKGluZm8sIGkxOG4pID0+IGkxOG4gPyBpMThuLm5vdygpIDogRGF0ZVRpbWUubG9jYWwoKSxcblxuICAgIHNlcmlhbGl6ZTogdmFsdWUgPT4ge1xuICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWUudG9JU08pIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b0lTTyh7IGluY2x1ZGVPZmZzZXQ6IGZhbHNlIH0pOyBcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuXG4gICAgcXVhbGlmaWVyczogYW55LnF1YWxpZmllcnMuY29uY2F0KFtcbiAgICAgICAgJ3RpbWV6b25lJyxcbiAgICAgICAgJ2RhdGVPbmx5JyxcbiAgICAgICAgJ3RpbWVPbmx5JyxcbiAgICAgICAgJ2lucHV0Rm9ybWF0JyxcbiAgICAgICAgJ2RvbnRQYXJzZSdcbiAgICBdKVxufTsiXX0=