"use strict";

require("source-map-support/register");

const {
  _
} = require('rk-utils');

const Rules = require('../../enum/Rules');

const {
  DATETIME
} = require('../types');

const {
  OolongUsageError
} = require('../Errors');

function getConnector(entityModel, feature) {
  let app = entityModel.db.app;

  if (!app) {
    entityModel.db.connector.log('warn', `"changeLog" feature does not work when used without a service container app.`);
    return true;
  }

  return app.getService(feature.dataSource);
}

async function createLogEntry_(entityModel, feature, context, operation) {
  let logEntry = {
    entity: entityModel.meta.name,
    operation,
    which: context.queryKey,
    changedAt: DATETIME.typeObject.local()
  };

  if (operation !== 'delete') {
    logEntry.data = context.latest;
  } else {
    logEntry.data = context.existing;
  }

  if (feature.withUser) {
    let user = entityModel.getValueFromContext(context, feature.withUser);

    if (_.isNil(user)) {
      throw new OolongUsageError(`Cannot get value of [${feature.withUser}] from context. Entity: ${entityModel.meta.name}, operation: ${operation}`);
    }

    logEntry.changedBy = user;
  }

  let clConnector = getConnector(entityModel, feature);
  await clConnector.insertOne_(feature.storeEntity, logEntry);
}

module.exports = {
  [Rules.RULE_AFTER_CREATE]: (feature, entityModel, context) => createLogEntry_(entityModel, feature, context, 'create'),
  [Rules.RULE_AFTER_UPDATE]: (feature, entityModel, context) => createLogEntry_(entityModel, feature, context, 'update'),
  [Rules.RULE_AFTER_DELETE]: (feature, entityModel, context) => createLogEntry_(entityModel, feature, context, 'delete')
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9ydW50aW1lL2VudGl0eUZlYXR1cmVzL2NoYW5nZUxvZy5qcyJdLCJuYW1lcyI6WyJfIiwicmVxdWlyZSIsIlJ1bGVzIiwiREFURVRJTUUiLCJPb2xvbmdVc2FnZUVycm9yIiwiZ2V0Q29ubmVjdG9yIiwiZW50aXR5TW9kZWwiLCJmZWF0dXJlIiwiYXBwIiwiZGIiLCJjb25uZWN0b3IiLCJsb2ciLCJnZXRTZXJ2aWNlIiwiZGF0YVNvdXJjZSIsImNyZWF0ZUxvZ0VudHJ5XyIsImNvbnRleHQiLCJvcGVyYXRpb24iLCJsb2dFbnRyeSIsImVudGl0eSIsIm1ldGEiLCJuYW1lIiwid2hpY2giLCJxdWVyeUtleSIsImNoYW5nZWRBdCIsInR5cGVPYmplY3QiLCJsb2NhbCIsImRhdGEiLCJsYXRlc3QiLCJleGlzdGluZyIsIndpdGhVc2VyIiwidXNlciIsImdldFZhbHVlRnJvbUNvbnRleHQiLCJpc05pbCIsImNoYW5nZWRCeSIsImNsQ29ubmVjdG9yIiwiaW5zZXJ0T25lXyIsInN0b3JlRW50aXR5IiwibW9kdWxlIiwiZXhwb3J0cyIsIlJVTEVfQUZURVJfQ1JFQVRFIiwiUlVMRV9BRlRFUl9VUERBVEUiLCJSVUxFX0FGVEVSX0RFTEVURSJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7QUFFQSxNQUFNO0FBQUVBLEVBQUFBO0FBQUYsSUFBUUMsT0FBTyxDQUFDLFVBQUQsQ0FBckI7O0FBQ0EsTUFBTUMsS0FBSyxHQUFHRCxPQUFPLENBQUMsa0JBQUQsQ0FBckI7O0FBQ0EsTUFBTTtBQUFFRSxFQUFBQTtBQUFGLElBQWVGLE9BQU8sQ0FBQyxVQUFELENBQTVCOztBQUNBLE1BQU07QUFBRUcsRUFBQUE7QUFBRixJQUF1QkgsT0FBTyxDQUFDLFdBQUQsQ0FBcEM7O0FBRUEsU0FBU0ksWUFBVCxDQUFzQkMsV0FBdEIsRUFBbUNDLE9BQW5DLEVBQTRDO0FBQ3hDLE1BQUlDLEdBQUcsR0FBR0YsV0FBVyxDQUFDRyxFQUFaLENBQWVELEdBQXpCOztBQUVBLE1BQUksQ0FBQ0EsR0FBTCxFQUFVO0FBQ05GLElBQUFBLFdBQVcsQ0FBQ0csRUFBWixDQUFlQyxTQUFmLENBQXlCQyxHQUF6QixDQUE2QixNQUE3QixFQUFzQyw4RUFBdEM7QUFDQSxXQUFPLElBQVA7QUFDSDs7QUFFRCxTQUFPSCxHQUFHLENBQUNJLFVBQUosQ0FBZUwsT0FBTyxDQUFDTSxVQUF2QixDQUFQO0FBQ0g7O0FBRUQsZUFBZUMsZUFBZixDQUErQlIsV0FBL0IsRUFBNENDLE9BQTVDLEVBQXFEUSxPQUFyRCxFQUE4REMsU0FBOUQsRUFBeUU7QUFDckUsTUFBSUMsUUFBUSxHQUFHO0FBQ1hDLElBQUFBLE1BQU0sRUFBRVosV0FBVyxDQUFDYSxJQUFaLENBQWlCQyxJQURkO0FBRVhKLElBQUFBLFNBRlc7QUFHWEssSUFBQUEsS0FBSyxFQUFFTixPQUFPLENBQUNPLFFBSEo7QUFJWEMsSUFBQUEsU0FBUyxFQUFFcEIsUUFBUSxDQUFDcUIsVUFBVCxDQUFvQkMsS0FBcEI7QUFKQSxHQUFmOztBQU9BLE1BQUlULFNBQVMsS0FBSyxRQUFsQixFQUE0QjtBQUN4QkMsSUFBQUEsUUFBUSxDQUFDUyxJQUFULEdBQWdCWCxPQUFPLENBQUNZLE1BQXhCO0FBQ0gsR0FGRCxNQUVPO0FBQ0hWLElBQUFBLFFBQVEsQ0FBQ1MsSUFBVCxHQUFnQlgsT0FBTyxDQUFDYSxRQUF4QjtBQUNIOztBQUVELE1BQUlyQixPQUFPLENBQUNzQixRQUFaLEVBQXNCO0FBQ2xCLFFBQUlDLElBQUksR0FBR3hCLFdBQVcsQ0FBQ3lCLG1CQUFaLENBQWdDaEIsT0FBaEMsRUFBeUNSLE9BQU8sQ0FBQ3NCLFFBQWpELENBQVg7O0FBQ0EsUUFBSTdCLENBQUMsQ0FBQ2dDLEtBQUYsQ0FBUUYsSUFBUixDQUFKLEVBQW1CO0FBQ2YsWUFBTSxJQUFJMUIsZ0JBQUosQ0FBc0Isd0JBQXVCRyxPQUFPLENBQUNzQixRQUFTLDJCQUEwQnZCLFdBQVcsQ0FBQ2EsSUFBWixDQUFpQkMsSUFBSyxnQkFBZUosU0FBVSxFQUF2SSxDQUFOO0FBQ0g7O0FBRURDLElBQUFBLFFBQVEsQ0FBQ2dCLFNBQVQsR0FBcUJILElBQXJCO0FBQ0g7O0FBRUQsTUFBSUksV0FBVyxHQUFHN0IsWUFBWSxDQUFDQyxXQUFELEVBQWNDLE9BQWQsQ0FBOUI7QUFDQSxRQUFNMkIsV0FBVyxDQUFDQyxVQUFaLENBQXVCNUIsT0FBTyxDQUFDNkIsV0FBL0IsRUFBNENuQixRQUE1QyxDQUFOO0FBQ0g7O0FBT0RvQixNQUFNLENBQUNDLE9BQVAsR0FBaUI7QUFDYixHQUFDcEMsS0FBSyxDQUFDcUMsaUJBQVAsR0FBMkIsQ0FBQ2hDLE9BQUQsRUFBVUQsV0FBVixFQUF1QlMsT0FBdkIsS0FBbUNELGVBQWUsQ0FBQ1IsV0FBRCxFQUFjQyxPQUFkLEVBQXVCUSxPQUF2QixFQUFnQyxRQUFoQyxDQURoRTtBQUViLEdBQUNiLEtBQUssQ0FBQ3NDLGlCQUFQLEdBQTJCLENBQUNqQyxPQUFELEVBQVVELFdBQVYsRUFBdUJTLE9BQXZCLEtBQW1DRCxlQUFlLENBQUNSLFdBQUQsRUFBY0MsT0FBZCxFQUF1QlEsT0FBdkIsRUFBZ0MsUUFBaEMsQ0FGaEU7QUFHYixHQUFDYixLQUFLLENBQUN1QyxpQkFBUCxHQUEyQixDQUFDbEMsT0FBRCxFQUFVRCxXQUFWLEVBQXVCUyxPQUF2QixLQUFtQ0QsZUFBZSxDQUFDUixXQUFELEVBQWNDLE9BQWQsRUFBdUJRLE9BQXZCLEVBQWdDLFFBQWhDO0FBSGhFLENBQWpCIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmNvbnN0IHsgXyB9ID0gcmVxdWlyZSgncmstdXRpbHMnKTtcbmNvbnN0IFJ1bGVzID0gcmVxdWlyZSgnLi4vLi4vZW51bS9SdWxlcycpO1xuY29uc3QgeyBEQVRFVElNRSB9ID0gcmVxdWlyZSgnLi4vdHlwZXMnKTtcbmNvbnN0IHsgT29sb25nVXNhZ2VFcnJvciB9ID0gcmVxdWlyZSgnLi4vRXJyb3JzJylcblxuZnVuY3Rpb24gZ2V0Q29ubmVjdG9yKGVudGl0eU1vZGVsLCBmZWF0dXJlKSB7XG4gICAgbGV0IGFwcCA9IGVudGl0eU1vZGVsLmRiLmFwcDtcbiAgICAgICAgXG4gICAgaWYgKCFhcHApIHtcbiAgICAgICAgZW50aXR5TW9kZWwuZGIuY29ubmVjdG9yLmxvZygnd2FybicsIGBcImNoYW5nZUxvZ1wiIGZlYXR1cmUgZG9lcyBub3Qgd29yayB3aGVuIHVzZWQgd2l0aG91dCBhIHNlcnZpY2UgY29udGFpbmVyIGFwcC5gKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXBwLmdldFNlcnZpY2UoZmVhdHVyZS5kYXRhU291cmNlKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gY3JlYXRlTG9nRW50cnlfKGVudGl0eU1vZGVsLCBmZWF0dXJlLCBjb250ZXh0LCBvcGVyYXRpb24pIHtcbiAgICBsZXQgbG9nRW50cnkgPSB7XG4gICAgICAgIGVudGl0eTogZW50aXR5TW9kZWwubWV0YS5uYW1lLFxuICAgICAgICBvcGVyYXRpb24sXG4gICAgICAgIHdoaWNoOiBjb250ZXh0LnF1ZXJ5S2V5LCBcbiAgICAgICAgY2hhbmdlZEF0OiBEQVRFVElNRS50eXBlT2JqZWN0LmxvY2FsKClcbiAgICB9O1xuXG4gICAgaWYgKG9wZXJhdGlvbiAhPT0gJ2RlbGV0ZScpIHtcbiAgICAgICAgbG9nRW50cnkuZGF0YSA9IGNvbnRleHQubGF0ZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZ0VudHJ5LmRhdGEgPSBjb250ZXh0LmV4aXN0aW5nO1xuICAgIH1cblxuICAgIGlmIChmZWF0dXJlLndpdGhVc2VyKSB7XG4gICAgICAgIGxldCB1c2VyID0gZW50aXR5TW9kZWwuZ2V0VmFsdWVGcm9tQ29udGV4dChjb250ZXh0LCBmZWF0dXJlLndpdGhVc2VyKTtcbiAgICAgICAgaWYgKF8uaXNOaWwodXNlcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPb2xvbmdVc2FnZUVycm9yKGBDYW5ub3QgZ2V0IHZhbHVlIG9mIFske2ZlYXR1cmUud2l0aFVzZXJ9XSBmcm9tIGNvbnRleHQuIEVudGl0eTogJHtlbnRpdHlNb2RlbC5tZXRhLm5hbWV9LCBvcGVyYXRpb246ICR7b3BlcmF0aW9ufWApO1xuICAgICAgICB9XG5cbiAgICAgICAgbG9nRW50cnkuY2hhbmdlZEJ5ID0gdXNlcjtcbiAgICB9XG5cbiAgICBsZXQgY2xDb25uZWN0b3IgPSBnZXRDb25uZWN0b3IoZW50aXR5TW9kZWwsIGZlYXR1cmUpO1xuICAgIGF3YWl0IGNsQ29ubmVjdG9yLmluc2VydE9uZV8oZmVhdHVyZS5zdG9yZUVudGl0eSwgbG9nRW50cnkpO1xufVxuXG4vKipcbiAqIEEgcnVsZSBzcGVjaWZpZXMgdGhlIGNoYW5nZSBvZiBzdGF0ZSB3aWxsIGJlIHRyYWNrZWQgYXV0b21hdGljYWxseS5cbiAqIEBtb2R1bGUgRW50aXR5RmVhdHVyZVJ1bnRpbWVfQ2hhbmdlTG9nXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgW1J1bGVzLlJVTEVfQUZURVJfQ1JFQVRFXTogKGZlYXR1cmUsIGVudGl0eU1vZGVsLCBjb250ZXh0KSA9PiBjcmVhdGVMb2dFbnRyeV8oZW50aXR5TW9kZWwsIGZlYXR1cmUsIGNvbnRleHQsICdjcmVhdGUnKSxcbiAgICBbUnVsZXMuUlVMRV9BRlRFUl9VUERBVEVdOiAoZmVhdHVyZSwgZW50aXR5TW9kZWwsIGNvbnRleHQpID0+IGNyZWF0ZUxvZ0VudHJ5XyhlbnRpdHlNb2RlbCwgZmVhdHVyZSwgY29udGV4dCwgJ3VwZGF0ZScpLFxuICAgIFtSdWxlcy5SVUxFX0FGVEVSX0RFTEVURV06IChmZWF0dXJlLCBlbnRpdHlNb2RlbCwgY29udGV4dCkgPT4gY3JlYXRlTG9nRW50cnlfKGVudGl0eU1vZGVsLCBmZWF0dXJlLCBjb250ZXh0LCAnZGVsZXRlJylcbn07Il19