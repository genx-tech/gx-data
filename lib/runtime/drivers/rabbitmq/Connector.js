"use strict";

require("source-map-support/register");

const {
  Promise
} = require('rk-utils');

const {
  tryRequire
} = require('@k-suite/app/lib/utils/Helpers');

const AmqpNode = tryRequire('amqplib');

const Connector = require('../../Connector');

class RabbitmqConnector extends Connector {
  constructor(connectionString, options) {
    super('rabbitmq', connectionString, options);
  }

  async end_() {
    if (this.ch) {
      await this.ch.close();
    }

    delete this.ch;

    if (this.conn) {
      await this.conn.close();
    }

    delete this.conn;
  }

  async connect_() {
    if (!this.conn) {
      this.conn = await AmqpNode.connect(this.connectionString);
      this.conn.on('close', () => {
        delete this.ch;
        delete this.conn;
      });
      this.conn.on('error', () => {
        delete this.ch;
        delete this.conn;
      });
    }

    if (!this.ch) {
      this.ch = await this.conn.createChannel();
      this.ch.on('close', () => {
        delete this.ch;
      });
    }

    return this.ch;
  }

  async disconnect_(conn) {}

  async sendToQueue_(queueName, obj, options) {
    if (typeof obj !== 'string') {
      obj = JSON.stringify(obj);
    }

    let ch = await this.connect_();
    await ch.assertQueue(queueName);
    let ret = ch.sendToQueue(queueName, Buffer.from(obj), options);
    this.log('info', `Sent to MQ[${queueName}]`, {
      msg: obj
    });
    return ret;
  }

  async consume_(queueName, consumerMethod, options) {
    let ch = await this.connect_();
    await ch.assertQueue(queueName);
    return ch.consume(queueName, msg => consumerMethod(ch, msg), options);
  }

}

module.exports = RabbitmqConnector;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9ydW50aW1lL2RyaXZlcnMvcmFiYml0bXEvQ29ubmVjdG9yLmpzIl0sIm5hbWVzIjpbIlByb21pc2UiLCJyZXF1aXJlIiwidHJ5UmVxdWlyZSIsIkFtcXBOb2RlIiwiQ29ubmVjdG9yIiwiUmFiYml0bXFDb25uZWN0b3IiLCJjb25zdHJ1Y3RvciIsImNvbm5lY3Rpb25TdHJpbmciLCJvcHRpb25zIiwiZW5kXyIsImNoIiwiY2xvc2UiLCJjb25uIiwiY29ubmVjdF8iLCJjb25uZWN0Iiwib24iLCJjcmVhdGVDaGFubmVsIiwiZGlzY29ubmVjdF8iLCJzZW5kVG9RdWV1ZV8iLCJxdWV1ZU5hbWUiLCJvYmoiLCJKU09OIiwic3RyaW5naWZ5IiwiYXNzZXJ0UXVldWUiLCJyZXQiLCJzZW5kVG9RdWV1ZSIsIkJ1ZmZlciIsImZyb20iLCJsb2ciLCJtc2ciLCJjb25zdW1lXyIsImNvbnN1bWVyTWV0aG9kIiwiY29uc3VtZSIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxNQUFNO0FBQUVBLEVBQUFBO0FBQUYsSUFBY0MsT0FBTyxDQUFDLFVBQUQsQ0FBM0I7O0FBQ0EsTUFBTTtBQUFFQyxFQUFBQTtBQUFGLElBQWlCRCxPQUFPLENBQUMsZ0NBQUQsQ0FBOUI7O0FBQ0EsTUFBTUUsUUFBUSxHQUFHRCxVQUFVLENBQUMsU0FBRCxDQUEzQjs7QUFDQSxNQUFNRSxTQUFTLEdBQUdILE9BQU8sQ0FBQyxpQkFBRCxDQUF6Qjs7QUFPQSxNQUFNSSxpQkFBTixTQUFnQ0QsU0FBaEMsQ0FBMEM7QUFNdENFLEVBQUFBLFdBQVcsQ0FBQ0MsZ0JBQUQsRUFBbUJDLE9BQW5CLEVBQTRCO0FBQ25DLFVBQU0sVUFBTixFQUFrQkQsZ0JBQWxCLEVBQW9DQyxPQUFwQztBQUNIOztBQUtELFFBQU1DLElBQU4sR0FBYTtBQUNULFFBQUksS0FBS0MsRUFBVCxFQUFhO0FBQ1QsWUFBTSxLQUFLQSxFQUFMLENBQVFDLEtBQVIsRUFBTjtBQUNIOztBQUVELFdBQU8sS0FBS0QsRUFBWjs7QUFFQSxRQUFJLEtBQUtFLElBQVQsRUFBZTtBQUNYLFlBQU0sS0FBS0EsSUFBTCxDQUFVRCxLQUFWLEVBQU47QUFDSDs7QUFFRCxXQUFPLEtBQUtDLElBQVo7QUFDSDs7QUFTRCxRQUFNQyxRQUFOLEdBQWlCO0FBQ2IsUUFBSSxDQUFDLEtBQUtELElBQVYsRUFBZ0I7QUFDWixXQUFLQSxJQUFMLEdBQVksTUFBTVQsUUFBUSxDQUFDVyxPQUFULENBQWlCLEtBQUtQLGdCQUF0QixDQUFsQjtBQUNBLFdBQUtLLElBQUwsQ0FBVUcsRUFBVixDQUFhLE9BQWIsRUFBc0IsTUFBTTtBQUN4QixlQUFPLEtBQUtMLEVBQVo7QUFDQSxlQUFPLEtBQUtFLElBQVo7QUFDSCxPQUhEO0FBS0EsV0FBS0EsSUFBTCxDQUFVRyxFQUFWLENBQWEsT0FBYixFQUFzQixNQUFNO0FBQ3hCLGVBQU8sS0FBS0wsRUFBWjtBQUNBLGVBQU8sS0FBS0UsSUFBWjtBQUNILE9BSEQ7QUFJSDs7QUFFRCxRQUFJLENBQUMsS0FBS0YsRUFBVixFQUFjO0FBQ1YsV0FBS0EsRUFBTCxHQUFVLE1BQU0sS0FBS0UsSUFBTCxDQUFVSSxhQUFWLEVBQWhCO0FBQ0EsV0FBS04sRUFBTCxDQUFRSyxFQUFSLENBQVcsT0FBWCxFQUFvQixNQUFNO0FBQ3RCLGVBQU8sS0FBS0wsRUFBWjtBQUNILE9BRkQ7QUFHSDs7QUFFRCxXQUFPLEtBQUtBLEVBQVo7QUFDSDs7QUFNRCxRQUFNTyxXQUFOLENBQWtCTCxJQUFsQixFQUF3QixDQUN2Qjs7QUFFRCxRQUFNTSxZQUFOLENBQW1CQyxTQUFuQixFQUE4QkMsR0FBOUIsRUFBbUNaLE9BQW5DLEVBQTRDO0FBQ3hDLFFBQUksT0FBT1ksR0FBUCxLQUFlLFFBQW5CLEVBQTZCO0FBQ3pCQSxNQUFBQSxHQUFHLEdBQUdDLElBQUksQ0FBQ0MsU0FBTCxDQUFlRixHQUFmLENBQU47QUFDSDs7QUFFRCxRQUFJVixFQUFFLEdBQUcsTUFBTSxLQUFLRyxRQUFMLEVBQWY7QUFDQSxVQUFNSCxFQUFFLENBQUNhLFdBQUgsQ0FBZUosU0FBZixDQUFOO0FBQ0EsUUFBSUssR0FBRyxHQUFHZCxFQUFFLENBQUNlLFdBQUgsQ0FBZU4sU0FBZixFQUEwQk8sTUFBTSxDQUFDQyxJQUFQLENBQVlQLEdBQVosQ0FBMUIsRUFBNENaLE9BQTVDLENBQVY7QUFFQSxTQUFLb0IsR0FBTCxDQUFTLE1BQVQsRUFBa0IsY0FBYVQsU0FBVSxHQUF6QyxFQUE2QztBQUFFVSxNQUFBQSxHQUFHLEVBQUVUO0FBQVAsS0FBN0M7QUFFQSxXQUFPSSxHQUFQO0FBQ0g7O0FBRUQsUUFBTU0sUUFBTixDQUFlWCxTQUFmLEVBQTBCWSxjQUExQixFQUEwQ3ZCLE9BQTFDLEVBQW1EO0FBQy9DLFFBQUlFLEVBQUUsR0FBRyxNQUFNLEtBQUtHLFFBQUwsRUFBZjtBQUNBLFVBQU1ILEVBQUUsQ0FBQ2EsV0FBSCxDQUFlSixTQUFmLENBQU47QUFFQSxXQUFPVCxFQUFFLENBQUNzQixPQUFILENBQVdiLFNBQVgsRUFBdUJVLEdBQUQsSUFBU0UsY0FBYyxDQUFDckIsRUFBRCxFQUFLbUIsR0FBTCxDQUE3QyxFQUF3RHJCLE9BQXhELENBQVA7QUFDSDs7QUFwRnFDOztBQXVGMUN5QixNQUFNLENBQUNDLE9BQVAsR0FBaUI3QixpQkFBakIiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB7IFByb21pc2UgfSA9IHJlcXVpcmUoJ3JrLXV0aWxzJyk7XG5jb25zdCB7IHRyeVJlcXVpcmUgfSA9IHJlcXVpcmUoJ0BrLXN1aXRlL2FwcC9saWIvdXRpbHMvSGVscGVycycpO1xuY29uc3QgQW1xcE5vZGUgPSB0cnlSZXF1aXJlKCdhbXFwbGliJyk7XG5jb25zdCBDb25uZWN0b3IgPSByZXF1aXJlKCcuLi8uLi9Db25uZWN0b3InKTtcblxuLyoqXG4gKiBSYWJiaXRtcSBkYXRhIHN0b3JhZ2UgY29ubmVjdG9yLlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBDb25uZWN0b3JcbiAqL1xuY2xhc3MgUmFiYml0bXFDb25uZWN0b3IgZXh0ZW5kcyBDb25uZWN0b3Ige1xuICAgIC8qKiAgICAgICAgICBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtvcHRpb25zLnVzZVByZXBhcmVkU3RhdGVtZW50XSAtIFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbm5lY3Rpb25TdHJpbmcsIG9wdGlvbnMpIHsgICAgICAgIFxuICAgICAgICBzdXBlcigncmFiYml0bXEnLCBjb25uZWN0aW9uU3RyaW5nLCBvcHRpb25zKTsgICAgICAgICBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbG9zZSBhbGwgY29ubmVjdGlvbiBpbml0aWF0ZWQgYnkgdGhpcyBjb25uZWN0b3IuXG4gICAgICovXG4gICAgYXN5bmMgZW5kXygpIHtcbiAgICAgICAgaWYgKHRoaXMuY2gpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY2guY2xvc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlbGV0ZSB0aGlzLmNoO1xuXG4gICAgICAgIGlmICh0aGlzLmNvbm4pIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY29ubi5jbG9zZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVsZXRlIHRoaXMuY29ubjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBkYXRhYmFzZSBjb25uZWN0aW9uIGJhc2VkIG9uIHRoZSBkZWZhdWx0IGNvbm5lY3Rpb24gc3RyaW5nIG9mIHRoZSBjb25uZWN0b3IgYW5kIGdpdmVuIG9wdGlvbnMuICAgICBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gRXh0cmEgb3B0aW9ucyBmb3IgdGhlIGNvbm5lY3Rpb24sIG9wdGlvbmFsLlxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbH0gW29wdGlvbnMubXVsdGlwbGVTdGF0ZW1lbnRzPWZhbHNlXSAtIEFsbG93IHJ1bm5pbmcgbXVsdGlwbGUgc3RhdGVtZW50cyBhdCBhIHRpbWUuXG4gICAgICogQHByb3BlcnR5IHtib29sfSBbb3B0aW9ucy5jcmVhdGVEYXRhYmFzZT1mYWxzZV0gLSBGbGFnIHRvIHVzZWQgd2hlbiBjcmVhdGluZyBhIGRhdGFiYXNlLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlLjxEYj59XG4gICAgICovXG4gICAgYXN5bmMgY29ubmVjdF8oKSB7XG4gICAgICAgIGlmICghdGhpcy5jb25uKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm4gPSBhd2FpdCBBbXFwTm9kZS5jb25uZWN0KHRoaXMuY29ubmVjdGlvblN0cmluZyk7XG4gICAgICAgICAgICB0aGlzLmNvbm4ub24oJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNoO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNvbm47XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5jb25uLm9uKCdlcnJvcicsICgpID0+IHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5jaDtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5jb25uO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gICAgICAgIFxuXG4gICAgICAgIGlmICghdGhpcy5jaCkge1xuICAgICAgICAgICAgdGhpcy5jaCA9IGF3YWl0IHRoaXMuY29ubi5jcmVhdGVDaGFubmVsKCk7XG4gICAgICAgICAgICB0aGlzLmNoLm9uKCdjbG9zZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5jaDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY2g7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xvc2UgYSBkYXRhYmFzZSBjb25uZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7RGJ9IGNvbm4gLSBNeVNRTCBjb25uZWN0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIGRpc2Nvbm5lY3RfKGNvbm4pIHtcbiAgICB9XG4gIFxuICAgIGFzeW5jIHNlbmRUb1F1ZXVlXyhxdWV1ZU5hbWUsIG9iaiwgb3B0aW9ucykge1xuICAgICAgICBpZiAodHlwZW9mIG9iaiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG9iaiA9IEpTT04uc3RyaW5naWZ5KG9iaik7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY2ggPSBhd2FpdCB0aGlzLmNvbm5lY3RfKCk7ICAgICAgICBcbiAgICAgICAgYXdhaXQgY2guYXNzZXJ0UXVldWUocXVldWVOYW1lKTtcbiAgICAgICAgbGV0IHJldCA9IGNoLnNlbmRUb1F1ZXVlKHF1ZXVlTmFtZSwgQnVmZmVyLmZyb20ob2JqKSwgb3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5sb2coJ2luZm8nLCBgU2VudCB0byBNUVske3F1ZXVlTmFtZX1dYCwgeyBtc2c6IG9iaiB9KTtcblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH0gICBcblxuICAgIGFzeW5jIGNvbnN1bWVfKHF1ZXVlTmFtZSwgY29uc3VtZXJNZXRob2QsIG9wdGlvbnMpIHsgICAgICAgIFxuICAgICAgICBsZXQgY2ggPSBhd2FpdCB0aGlzLmNvbm5lY3RfKCk7XG4gICAgICAgIGF3YWl0IGNoLmFzc2VydFF1ZXVlKHF1ZXVlTmFtZSk7XG5cbiAgICAgICAgcmV0dXJuIGNoLmNvbnN1bWUocXVldWVOYW1lLCAobXNnKSA9PiBjb25zdW1lck1ldGhvZChjaCwgbXNnKSwgb3B0aW9ucyk7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJhYmJpdG1xQ29ubmVjdG9yOyJdfQ==