"use strict";

require("source-map-support/register");

const {
  _
} = require('rk-utils');

const Rules = require('../enum/Rules');

const {
  DATETIME
} = require('../types');

const {
  ApplicationError
} = require('../utils/Errors');

function getConnector(entityModel, feature) {
  let app = entityModel.db.app;

  if (!app) {
    entityModel.db.connector.log('warn', `"changeLog" feature does not work when used without a service container app.`);
    return true;
  }

  return app.getService(feature.dataSource);
}

async function createLogEntry_(entityModel, feature, context, operation) {
  let logEntry = {
    entity: entityModel.meta.name,
    operation,
    which: context.queryKey,
    changedAt: DATETIME.typeObject.local()
  };

  if (operation !== 'delete') {
    logEntry.data = context.latest;
  } else {
    logEntry.data = context.existing;
  }

  if (feature.withUser) {
    let user = entityModel.getValueFromContext(context, feature.withUser);

    if (_.isNil(user)) {
      throw new ApplicationError(`Cannot get value of [${feature.withUser}] from context. Entity: ${entityModel.meta.name}, operation: ${operation}`);
    }

    logEntry.changedBy = user;
  }

  let clConnector = getConnector(entityModel, feature);
  await clConnector.insertOne_(feature.storeEntity, logEntry);
}

module.exports = {
  [Rules.RULE_AFTER_CREATE]: (feature, entityModel, context) => createLogEntry_(entityModel, feature, context, 'create'),
  [Rules.RULE_AFTER_UPDATE]: (feature, entityModel, context) => createLogEntry_(entityModel, feature, context, 'update'),
  [Rules.RULE_AFTER_DELETE]: (feature, entityModel, context) => createLogEntry_(entityModel, feature, context, 'delete')
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9lbnRpdHlGZWF0dXJlcy9jaGFuZ2VMb2cuanMiXSwibmFtZXMiOlsiXyIsInJlcXVpcmUiLCJSdWxlcyIsIkRBVEVUSU1FIiwiQXBwbGljYXRpb25FcnJvciIsImdldENvbm5lY3RvciIsImVudGl0eU1vZGVsIiwiZmVhdHVyZSIsImFwcCIsImRiIiwiY29ubmVjdG9yIiwibG9nIiwiZ2V0U2VydmljZSIsImRhdGFTb3VyY2UiLCJjcmVhdGVMb2dFbnRyeV8iLCJjb250ZXh0Iiwib3BlcmF0aW9uIiwibG9nRW50cnkiLCJlbnRpdHkiLCJtZXRhIiwibmFtZSIsIndoaWNoIiwicXVlcnlLZXkiLCJjaGFuZ2VkQXQiLCJ0eXBlT2JqZWN0IiwibG9jYWwiLCJkYXRhIiwibGF0ZXN0IiwiZXhpc3RpbmciLCJ3aXRoVXNlciIsInVzZXIiLCJnZXRWYWx1ZUZyb21Db250ZXh0IiwiaXNOaWwiLCJjaGFuZ2VkQnkiLCJjbENvbm5lY3RvciIsImluc2VydE9uZV8iLCJzdG9yZUVudGl0eSIsIm1vZHVsZSIsImV4cG9ydHMiLCJSVUxFX0FGVEVSX0NSRUFURSIsIlJVTEVfQUZURVJfVVBEQVRFIiwiUlVMRV9BRlRFUl9ERUxFVEUiXSwibWFwcGluZ3MiOiJBQUFBOzs7O0FBRUEsTUFBTTtBQUFFQSxFQUFBQTtBQUFGLElBQVFDLE9BQU8sQ0FBQyxVQUFELENBQXJCOztBQUNBLE1BQU1DLEtBQUssR0FBR0QsT0FBTyxDQUFDLGVBQUQsQ0FBckI7O0FBQ0EsTUFBTTtBQUFFRSxFQUFBQTtBQUFGLElBQWVGLE9BQU8sQ0FBQyxVQUFELENBQTVCOztBQUNBLE1BQU07QUFBRUcsRUFBQUE7QUFBRixJQUF1QkgsT0FBTyxDQUFDLGlCQUFELENBQXBDOztBQUVBLFNBQVNJLFlBQVQsQ0FBc0JDLFdBQXRCLEVBQW1DQyxPQUFuQyxFQUE0QztBQUN4QyxNQUFJQyxHQUFHLEdBQUdGLFdBQVcsQ0FBQ0csRUFBWixDQUFlRCxHQUF6Qjs7QUFFQSxNQUFJLENBQUNBLEdBQUwsRUFBVTtBQUNORixJQUFBQSxXQUFXLENBQUNHLEVBQVosQ0FBZUMsU0FBZixDQUF5QkMsR0FBekIsQ0FBNkIsTUFBN0IsRUFBc0MsOEVBQXRDO0FBQ0EsV0FBTyxJQUFQO0FBQ0g7O0FBRUQsU0FBT0gsR0FBRyxDQUFDSSxVQUFKLENBQWVMLE9BQU8sQ0FBQ00sVUFBdkIsQ0FBUDtBQUNIOztBQUVELGVBQWVDLGVBQWYsQ0FBK0JSLFdBQS9CLEVBQTRDQyxPQUE1QyxFQUFxRFEsT0FBckQsRUFBOERDLFNBQTlELEVBQXlFO0FBQ3JFLE1BQUlDLFFBQVEsR0FBRztBQUNYQyxJQUFBQSxNQUFNLEVBQUVaLFdBQVcsQ0FBQ2EsSUFBWixDQUFpQkMsSUFEZDtBQUVYSixJQUFBQSxTQUZXO0FBR1hLLElBQUFBLEtBQUssRUFBRU4sT0FBTyxDQUFDTyxRQUhKO0FBSVhDLElBQUFBLFNBQVMsRUFBRXBCLFFBQVEsQ0FBQ3FCLFVBQVQsQ0FBb0JDLEtBQXBCO0FBSkEsR0FBZjs7QUFPQSxNQUFJVCxTQUFTLEtBQUssUUFBbEIsRUFBNEI7QUFDeEJDLElBQUFBLFFBQVEsQ0FBQ1MsSUFBVCxHQUFnQlgsT0FBTyxDQUFDWSxNQUF4QjtBQUNILEdBRkQsTUFFTztBQUNIVixJQUFBQSxRQUFRLENBQUNTLElBQVQsR0FBZ0JYLE9BQU8sQ0FBQ2EsUUFBeEI7QUFDSDs7QUFFRCxNQUFJckIsT0FBTyxDQUFDc0IsUUFBWixFQUFzQjtBQUNsQixRQUFJQyxJQUFJLEdBQUd4QixXQUFXLENBQUN5QixtQkFBWixDQUFnQ2hCLE9BQWhDLEVBQXlDUixPQUFPLENBQUNzQixRQUFqRCxDQUFYOztBQUNBLFFBQUk3QixDQUFDLENBQUNnQyxLQUFGLENBQVFGLElBQVIsQ0FBSixFQUFtQjtBQUNmLFlBQU0sSUFBSTFCLGdCQUFKLENBQXNCLHdCQUF1QkcsT0FBTyxDQUFDc0IsUUFBUywyQkFBMEJ2QixXQUFXLENBQUNhLElBQVosQ0FBaUJDLElBQUssZ0JBQWVKLFNBQVUsRUFBdkksQ0FBTjtBQUNIOztBQUVEQyxJQUFBQSxRQUFRLENBQUNnQixTQUFULEdBQXFCSCxJQUFyQjtBQUNIOztBQUVELE1BQUlJLFdBQVcsR0FBRzdCLFlBQVksQ0FBQ0MsV0FBRCxFQUFjQyxPQUFkLENBQTlCO0FBQ0EsUUFBTTJCLFdBQVcsQ0FBQ0MsVUFBWixDQUF1QjVCLE9BQU8sQ0FBQzZCLFdBQS9CLEVBQTRDbkIsUUFBNUMsQ0FBTjtBQUNIOztBQU9Eb0IsTUFBTSxDQUFDQyxPQUFQLEdBQWlCO0FBQ2IsR0FBQ3BDLEtBQUssQ0FBQ3FDLGlCQUFQLEdBQTJCLENBQUNoQyxPQUFELEVBQVVELFdBQVYsRUFBdUJTLE9BQXZCLEtBQW1DRCxlQUFlLENBQUNSLFdBQUQsRUFBY0MsT0FBZCxFQUF1QlEsT0FBdkIsRUFBZ0MsUUFBaEMsQ0FEaEU7QUFFYixHQUFDYixLQUFLLENBQUNzQyxpQkFBUCxHQUEyQixDQUFDakMsT0FBRCxFQUFVRCxXQUFWLEVBQXVCUyxPQUF2QixLQUFtQ0QsZUFBZSxDQUFDUixXQUFELEVBQWNDLE9BQWQsRUFBdUJRLE9BQXZCLEVBQWdDLFFBQWhDLENBRmhFO0FBR2IsR0FBQ2IsS0FBSyxDQUFDdUMsaUJBQVAsR0FBMkIsQ0FBQ2xDLE9BQUQsRUFBVUQsV0FBVixFQUF1QlMsT0FBdkIsS0FBbUNELGVBQWUsQ0FBQ1IsV0FBRCxFQUFjQyxPQUFkLEVBQXVCUSxPQUF2QixFQUFnQyxRQUFoQztBQUhoRSxDQUFqQiIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5jb25zdCB7IF8gfSA9IHJlcXVpcmUoJ3JrLXV0aWxzJyk7XG5jb25zdCBSdWxlcyA9IHJlcXVpcmUoJy4uL2VudW0vUnVsZXMnKTtcbmNvbnN0IHsgREFURVRJTUUgfSA9IHJlcXVpcmUoJy4uL3R5cGVzJyk7XG5jb25zdCB7IEFwcGxpY2F0aW9uRXJyb3IgfSA9IHJlcXVpcmUoJy4uL3V0aWxzL0Vycm9ycycpXG5cbmZ1bmN0aW9uIGdldENvbm5lY3RvcihlbnRpdHlNb2RlbCwgZmVhdHVyZSkge1xuICAgIGxldCBhcHAgPSBlbnRpdHlNb2RlbC5kYi5hcHA7XG4gICAgICAgIFxuICAgIGlmICghYXBwKSB7XG4gICAgICAgIGVudGl0eU1vZGVsLmRiLmNvbm5lY3Rvci5sb2coJ3dhcm4nLCBgXCJjaGFuZ2VMb2dcIiBmZWF0dXJlIGRvZXMgbm90IHdvcmsgd2hlbiB1c2VkIHdpdGhvdXQgYSBzZXJ2aWNlIGNvbnRhaW5lciBhcHAuYClcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFwcC5nZXRTZXJ2aWNlKGZlYXR1cmUuZGF0YVNvdXJjZSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUxvZ0VudHJ5XyhlbnRpdHlNb2RlbCwgZmVhdHVyZSwgY29udGV4dCwgb3BlcmF0aW9uKSB7XG4gICAgbGV0IGxvZ0VudHJ5ID0ge1xuICAgICAgICBlbnRpdHk6IGVudGl0eU1vZGVsLm1ldGEubmFtZSxcbiAgICAgICAgb3BlcmF0aW9uLFxuICAgICAgICB3aGljaDogY29udGV4dC5xdWVyeUtleSwgXG4gICAgICAgIGNoYW5nZWRBdDogREFURVRJTUUudHlwZU9iamVjdC5sb2NhbCgpXG4gICAgfTtcblxuICAgIGlmIChvcGVyYXRpb24gIT09ICdkZWxldGUnKSB7XG4gICAgICAgIGxvZ0VudHJ5LmRhdGEgPSBjb250ZXh0LmxhdGVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsb2dFbnRyeS5kYXRhID0gY29udGV4dC5leGlzdGluZztcbiAgICB9XG5cbiAgICBpZiAoZmVhdHVyZS53aXRoVXNlcikge1xuICAgICAgICBsZXQgdXNlciA9IGVudGl0eU1vZGVsLmdldFZhbHVlRnJvbUNvbnRleHQoY29udGV4dCwgZmVhdHVyZS53aXRoVXNlcik7XG4gICAgICAgIGlmIChfLmlzTmlsKHVzZXIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwbGljYXRpb25FcnJvcihgQ2Fubm90IGdldCB2YWx1ZSBvZiBbJHtmZWF0dXJlLndpdGhVc2VyfV0gZnJvbSBjb250ZXh0LiBFbnRpdHk6ICR7ZW50aXR5TW9kZWwubWV0YS5uYW1lfSwgb3BlcmF0aW9uOiAke29wZXJhdGlvbn1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxvZ0VudHJ5LmNoYW5nZWRCeSA9IHVzZXI7XG4gICAgfVxuXG4gICAgbGV0IGNsQ29ubmVjdG9yID0gZ2V0Q29ubmVjdG9yKGVudGl0eU1vZGVsLCBmZWF0dXJlKTtcbiAgICBhd2FpdCBjbENvbm5lY3Rvci5pbnNlcnRPbmVfKGZlYXR1cmUuc3RvcmVFbnRpdHksIGxvZ0VudHJ5KTtcbn1cblxuLyoqXG4gKiBBIHJ1bGUgc3BlY2lmaWVzIHRoZSBjaGFuZ2Ugb2Ygc3RhdGUgd2lsbCBiZSB0cmFja2VkIGF1dG9tYXRpY2FsbHkuXG4gKiBAbW9kdWxlIEVudGl0eUZlYXR1cmVSdW50aW1lX0NoYW5nZUxvZ1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIFtSdWxlcy5SVUxFX0FGVEVSX0NSRUFURV06IChmZWF0dXJlLCBlbnRpdHlNb2RlbCwgY29udGV4dCkgPT4gY3JlYXRlTG9nRW50cnlfKGVudGl0eU1vZGVsLCBmZWF0dXJlLCBjb250ZXh0LCAnY3JlYXRlJyksXG4gICAgW1J1bGVzLlJVTEVfQUZURVJfVVBEQVRFXTogKGZlYXR1cmUsIGVudGl0eU1vZGVsLCBjb250ZXh0KSA9PiBjcmVhdGVMb2dFbnRyeV8oZW50aXR5TW9kZWwsIGZlYXR1cmUsIGNvbnRleHQsICd1cGRhdGUnKSxcbiAgICBbUnVsZXMuUlVMRV9BRlRFUl9ERUxFVEVdOiAoZmVhdHVyZSwgZW50aXR5TW9kZWwsIGNvbnRleHQpID0+IGNyZWF0ZUxvZ0VudHJ5XyhlbnRpdHlNb2RlbCwgZmVhdHVyZSwgY29udGV4dCwgJ2RlbGV0ZScpXG59OyJdfQ==