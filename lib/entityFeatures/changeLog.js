"use strict";

require("source-map-support/register");

const {
  _
} = require('rk-utils');

const Rules = require('../enum/Rules');

const {
  DATETIME
} = require('../types');

const {
  ApplicationError
} = require('../utils/Errors');

function getConnector(entityModel, feature) {
  let app = entityModel.db.app;

  if (!app) {
    entityModel.db.connector.log('warn', `"changeLog" feature does not work when used without a service container app.`);
    return true;
  }

  return app.getService(feature.dataSource);
}

async function createLogEntry_(entityModel, feature, context, operation) {
  let logEntry = {
    entity: entityModel.meta.name,
    operation,
    which: context.queryKey,
    changedAt: DATETIME.typeObject.local()
  };

  if (operation !== 'delete') {
    logEntry.data = context.latest;
  } else {
    logEntry.data = context.existing;
  }

  if (feature.withUser) {
    let user = entityModel.getValueFromContext(context, feature.withUser);

    if (_.isNil(user)) {
      throw new ApplicationError(`Cannot get value of [${feature.withUser}] from context. Entity: ${entityModel.meta.name}, operation: ${operation}`);
    }

    logEntry.changedBy = user;
  }

  let clConnector = getConnector(entityModel, feature);
  await clConnector.insertOne_(feature.storeEntity, logEntry, context.connOptions);
}

module.exports = {
  [Rules.RULE_AFTER_CREATE]: (feature, entityModel, context) => createLogEntry_(entityModel, feature, context, 'create'),
  [Rules.RULE_AFTER_UPDATE]: (feature, entityModel, context) => createLogEntry_(entityModel, feature, context, 'update'),
  [Rules.RULE_AFTER_DELETE]: (feature, entityModel, context) => createLogEntry_(entityModel, feature, context, 'delete')
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9lbnRpdHlGZWF0dXJlcy9jaGFuZ2VMb2cuanMiXSwibmFtZXMiOlsiXyIsInJlcXVpcmUiLCJSdWxlcyIsIkRBVEVUSU1FIiwiQXBwbGljYXRpb25FcnJvciIsImdldENvbm5lY3RvciIsImVudGl0eU1vZGVsIiwiZmVhdHVyZSIsImFwcCIsImRiIiwiY29ubmVjdG9yIiwibG9nIiwiZ2V0U2VydmljZSIsImRhdGFTb3VyY2UiLCJjcmVhdGVMb2dFbnRyeV8iLCJjb250ZXh0Iiwib3BlcmF0aW9uIiwibG9nRW50cnkiLCJlbnRpdHkiLCJtZXRhIiwibmFtZSIsIndoaWNoIiwicXVlcnlLZXkiLCJjaGFuZ2VkQXQiLCJ0eXBlT2JqZWN0IiwibG9jYWwiLCJkYXRhIiwibGF0ZXN0IiwiZXhpc3RpbmciLCJ3aXRoVXNlciIsInVzZXIiLCJnZXRWYWx1ZUZyb21Db250ZXh0IiwiaXNOaWwiLCJjaGFuZ2VkQnkiLCJjbENvbm5lY3RvciIsImluc2VydE9uZV8iLCJzdG9yZUVudGl0eSIsImNvbm5PcHRpb25zIiwibW9kdWxlIiwiZXhwb3J0cyIsIlJVTEVfQUZURVJfQ1JFQVRFIiwiUlVMRV9BRlRFUl9VUERBVEUiLCJSVUxFX0FGVEVSX0RFTEVURSJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7QUFFQSxNQUFNO0FBQUVBLEVBQUFBO0FBQUYsSUFBUUMsT0FBTyxDQUFDLFVBQUQsQ0FBckI7O0FBQ0EsTUFBTUMsS0FBSyxHQUFHRCxPQUFPLENBQUMsZUFBRCxDQUFyQjs7QUFDQSxNQUFNO0FBQUVFLEVBQUFBO0FBQUYsSUFBZUYsT0FBTyxDQUFDLFVBQUQsQ0FBNUI7O0FBQ0EsTUFBTTtBQUFFRyxFQUFBQTtBQUFGLElBQXVCSCxPQUFPLENBQUMsaUJBQUQsQ0FBcEM7O0FBRUEsU0FBU0ksWUFBVCxDQUFzQkMsV0FBdEIsRUFBbUNDLE9BQW5DLEVBQTRDO0FBQ3hDLE1BQUlDLEdBQUcsR0FBR0YsV0FBVyxDQUFDRyxFQUFaLENBQWVELEdBQXpCOztBQUVBLE1BQUksQ0FBQ0EsR0FBTCxFQUFVO0FBQ05GLElBQUFBLFdBQVcsQ0FBQ0csRUFBWixDQUFlQyxTQUFmLENBQXlCQyxHQUF6QixDQUE2QixNQUE3QixFQUFzQyw4RUFBdEM7QUFDQSxXQUFPLElBQVA7QUFDSDs7QUFFRCxTQUFPSCxHQUFHLENBQUNJLFVBQUosQ0FBZUwsT0FBTyxDQUFDTSxVQUF2QixDQUFQO0FBQ0g7O0FBRUQsZUFBZUMsZUFBZixDQUErQlIsV0FBL0IsRUFBNENDLE9BQTVDLEVBQXFEUSxPQUFyRCxFQUE4REMsU0FBOUQsRUFBeUU7QUFDckUsTUFBSUMsUUFBUSxHQUFHO0FBQ1hDLElBQUFBLE1BQU0sRUFBRVosV0FBVyxDQUFDYSxJQUFaLENBQWlCQyxJQURkO0FBRVhKLElBQUFBLFNBRlc7QUFHWEssSUFBQUEsS0FBSyxFQUFFTixPQUFPLENBQUNPLFFBSEo7QUFJWEMsSUFBQUEsU0FBUyxFQUFFcEIsUUFBUSxDQUFDcUIsVUFBVCxDQUFvQkMsS0FBcEI7QUFKQSxHQUFmOztBQU9BLE1BQUlULFNBQVMsS0FBSyxRQUFsQixFQUE0QjtBQUN4QkMsSUFBQUEsUUFBUSxDQUFDUyxJQUFULEdBQWdCWCxPQUFPLENBQUNZLE1BQXhCO0FBQ0gsR0FGRCxNQUVPO0FBQ0hWLElBQUFBLFFBQVEsQ0FBQ1MsSUFBVCxHQUFnQlgsT0FBTyxDQUFDYSxRQUF4QjtBQUNIOztBQUVELE1BQUlyQixPQUFPLENBQUNzQixRQUFaLEVBQXNCO0FBQ2xCLFFBQUlDLElBQUksR0FBR3hCLFdBQVcsQ0FBQ3lCLG1CQUFaLENBQWdDaEIsT0FBaEMsRUFBeUNSLE9BQU8sQ0FBQ3NCLFFBQWpELENBQVg7O0FBQ0EsUUFBSTdCLENBQUMsQ0FBQ2dDLEtBQUYsQ0FBUUYsSUFBUixDQUFKLEVBQW1CO0FBQ2YsWUFBTSxJQUFJMUIsZ0JBQUosQ0FBc0Isd0JBQXVCRyxPQUFPLENBQUNzQixRQUFTLDJCQUEwQnZCLFdBQVcsQ0FBQ2EsSUFBWixDQUFpQkMsSUFBSyxnQkFBZUosU0FBVSxFQUF2SSxDQUFOO0FBQ0g7O0FBRURDLElBQUFBLFFBQVEsQ0FBQ2dCLFNBQVQsR0FBcUJILElBQXJCO0FBQ0g7O0FBRUQsTUFBSUksV0FBVyxHQUFHN0IsWUFBWSxDQUFDQyxXQUFELEVBQWNDLE9BQWQsQ0FBOUI7QUFDQSxRQUFNMkIsV0FBVyxDQUFDQyxVQUFaLENBQXVCNUIsT0FBTyxDQUFDNkIsV0FBL0IsRUFBNENuQixRQUE1QyxFQUFzREYsT0FBTyxDQUFDc0IsV0FBOUQsQ0FBTjtBQUNIOztBQU9EQyxNQUFNLENBQUNDLE9BQVAsR0FBaUI7QUFDYixHQUFDckMsS0FBSyxDQUFDc0MsaUJBQVAsR0FBMkIsQ0FBQ2pDLE9BQUQsRUFBVUQsV0FBVixFQUF1QlMsT0FBdkIsS0FBbUNELGVBQWUsQ0FBQ1IsV0FBRCxFQUFjQyxPQUFkLEVBQXVCUSxPQUF2QixFQUFnQyxRQUFoQyxDQURoRTtBQUViLEdBQUNiLEtBQUssQ0FBQ3VDLGlCQUFQLEdBQTJCLENBQUNsQyxPQUFELEVBQVVELFdBQVYsRUFBdUJTLE9BQXZCLEtBQW1DRCxlQUFlLENBQUNSLFdBQUQsRUFBY0MsT0FBZCxFQUF1QlEsT0FBdkIsRUFBZ0MsUUFBaEMsQ0FGaEU7QUFHYixHQUFDYixLQUFLLENBQUN3QyxpQkFBUCxHQUEyQixDQUFDbkMsT0FBRCxFQUFVRCxXQUFWLEVBQXVCUyxPQUF2QixLQUFtQ0QsZUFBZSxDQUFDUixXQUFELEVBQWNDLE9BQWQsRUFBdUJRLE9BQXZCLEVBQWdDLFFBQWhDO0FBSGhFLENBQWpCIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmNvbnN0IHsgXyB9ID0gcmVxdWlyZSgncmstdXRpbHMnKTtcbmNvbnN0IFJ1bGVzID0gcmVxdWlyZSgnLi4vZW51bS9SdWxlcycpO1xuY29uc3QgeyBEQVRFVElNRSB9ID0gcmVxdWlyZSgnLi4vdHlwZXMnKTtcbmNvbnN0IHsgQXBwbGljYXRpb25FcnJvciB9ID0gcmVxdWlyZSgnLi4vdXRpbHMvRXJyb3JzJylcblxuZnVuY3Rpb24gZ2V0Q29ubmVjdG9yKGVudGl0eU1vZGVsLCBmZWF0dXJlKSB7XG4gICAgbGV0IGFwcCA9IGVudGl0eU1vZGVsLmRiLmFwcDtcbiAgICAgICAgXG4gICAgaWYgKCFhcHApIHtcbiAgICAgICAgZW50aXR5TW9kZWwuZGIuY29ubmVjdG9yLmxvZygnd2FybicsIGBcImNoYW5nZUxvZ1wiIGZlYXR1cmUgZG9lcyBub3Qgd29yayB3aGVuIHVzZWQgd2l0aG91dCBhIHNlcnZpY2UgY29udGFpbmVyIGFwcC5gKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXBwLmdldFNlcnZpY2UoZmVhdHVyZS5kYXRhU291cmNlKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gY3JlYXRlTG9nRW50cnlfKGVudGl0eU1vZGVsLCBmZWF0dXJlLCBjb250ZXh0LCBvcGVyYXRpb24pIHtcbiAgICBsZXQgbG9nRW50cnkgPSB7XG4gICAgICAgIGVudGl0eTogZW50aXR5TW9kZWwubWV0YS5uYW1lLFxuICAgICAgICBvcGVyYXRpb24sXG4gICAgICAgIHdoaWNoOiBjb250ZXh0LnF1ZXJ5S2V5LCBcbiAgICAgICAgY2hhbmdlZEF0OiBEQVRFVElNRS50eXBlT2JqZWN0LmxvY2FsKClcbiAgICB9O1xuXG4gICAgaWYgKG9wZXJhdGlvbiAhPT0gJ2RlbGV0ZScpIHtcbiAgICAgICAgbG9nRW50cnkuZGF0YSA9IGNvbnRleHQubGF0ZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZ0VudHJ5LmRhdGEgPSBjb250ZXh0LmV4aXN0aW5nO1xuICAgIH1cblxuICAgIGlmIChmZWF0dXJlLndpdGhVc2VyKSB7XG4gICAgICAgIGxldCB1c2VyID0gZW50aXR5TW9kZWwuZ2V0VmFsdWVGcm9tQ29udGV4dChjb250ZXh0LCBmZWF0dXJlLndpdGhVc2VyKTtcbiAgICAgICAgaWYgKF8uaXNOaWwodXNlcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHBsaWNhdGlvbkVycm9yKGBDYW5ub3QgZ2V0IHZhbHVlIG9mIFske2ZlYXR1cmUud2l0aFVzZXJ9XSBmcm9tIGNvbnRleHQuIEVudGl0eTogJHtlbnRpdHlNb2RlbC5tZXRhLm5hbWV9LCBvcGVyYXRpb246ICR7b3BlcmF0aW9ufWApO1xuICAgICAgICB9XG5cbiAgICAgICAgbG9nRW50cnkuY2hhbmdlZEJ5ID0gdXNlcjtcbiAgICB9XG5cbiAgICBsZXQgY2xDb25uZWN0b3IgPSBnZXRDb25uZWN0b3IoZW50aXR5TW9kZWwsIGZlYXR1cmUpO1xuICAgIGF3YWl0IGNsQ29ubmVjdG9yLmluc2VydE9uZV8oZmVhdHVyZS5zdG9yZUVudGl0eSwgbG9nRW50cnksIGNvbnRleHQuY29ubk9wdGlvbnMpO1xufVxuXG4vKipcbiAqIEEgcnVsZSBzcGVjaWZpZXMgdGhlIGNoYW5nZSBvZiBzdGF0ZSB3aWxsIGJlIHRyYWNrZWQgYXV0b21hdGljYWxseS5cbiAqIEBtb2R1bGUgRW50aXR5RmVhdHVyZVJ1bnRpbWVfQ2hhbmdlTG9nXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgW1J1bGVzLlJVTEVfQUZURVJfQ1JFQVRFXTogKGZlYXR1cmUsIGVudGl0eU1vZGVsLCBjb250ZXh0KSA9PiBjcmVhdGVMb2dFbnRyeV8oZW50aXR5TW9kZWwsIGZlYXR1cmUsIGNvbnRleHQsICdjcmVhdGUnKSxcbiAgICBbUnVsZXMuUlVMRV9BRlRFUl9VUERBVEVdOiAoZmVhdHVyZSwgZW50aXR5TW9kZWwsIGNvbnRleHQpID0+IGNyZWF0ZUxvZ0VudHJ5XyhlbnRpdHlNb2RlbCwgZmVhdHVyZSwgY29udGV4dCwgJ3VwZGF0ZScpLFxuICAgIFtSdWxlcy5SVUxFX0FGVEVSX0RFTEVURV06IChmZWF0dXJlLCBlbnRpdHlNb2RlbCwgY29udGV4dCkgPT4gY3JlYXRlTG9nRW50cnlfKGVudGl0eU1vZGVsLCBmZWF0dXJlLCBjb250ZXh0LCAnZGVsZXRlJylcbn07Il19