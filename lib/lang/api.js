"use strict";

require("source-map-support/register");

const path = require('path');

const Util = require('rk-utils');

const {
  _,
  fs,
  eachAsync_
} = Util;

const Linker = require('./Linker');

const Connector = require('../runtime/Connector');

const Validators = require('../runtime/Validators');

function createConnector(context, schemaName) {
  let deployment = context.schemaDeployment[schemaName];

  if (!deployment) {
    throw new Error(`Schema "${schemaName}" has no configured deployment and is ignored in modeling.`);
  }

  let {
    dataSource,
    connectionString,
    options
  } = deployment;
  let [driver] = dataSource.split('.');
  return Connector.createConnector(driver, connectionString, {
    logger: context.logger,
    ...options
  });
}

async function importDataFilesByList(migrator, dataSetPath, dataListFile) {
  let dataList = fs.readFileSync(dataListFile).toString().match(/^.+$/gm);

  if (!dataList) {
    return;
  }

  return eachAsync_(dataList, async line => {
    line = line.trim();

    if (line.length > 0 && line[0] !== '#') {
      let dataFile = path.join(dataSetPath, line);

      if (!fs.existsSync(dataFile)) {
        throw new Error(`Data file "${dataFile}" not found.`);
      }

      await migrator.load_(dataFile);
    }
  });
}

async function importDataFiles(migrator, folderName) {
  let dataSetPath = path.join(migrator.dbScriptPath, 'data', folderName);
  let dataListFile = path.join(dataSetPath, 'index.list');
  let runtimeDataSetPath,
      runtimeDataSetFile,
      imported = false;

  if (migrator.appModule.runtimeEnv) {
    runtimeDataSetPath = path.join(dataSetPath, migrator.appModule.runtimeEnv);
    runtimeDataSetFile = path.join(runtimeDataSetPath, 'index.list');
  }

  if (fs.existsSync(dataListFile)) {
    await importDataFilesByList(migrator, dataSetPath, dataListFile);
    imported = true;
  } else {
    migrator.appModule.log('warn', `Dataset index file "${dataListFile}" not exist.`);
  }

  if (runtimeDataSetFile && fs.existsSync(runtimeDataSetFile)) {
    await importDataFilesByList(migrator, runtimeDataSetPath, runtimeDataSetFile);
    imported = true;
  } else if (migrator.appModule.runtimeEnv) {
    migrator.appModule.log(imported ? 'info' : 'warn', `Dataset index file of "${migrator.appModule.runtimeEnv}" env "${runtimeDataSetFile}" not exist.`);
  }

  if (!imported) {
    throw new Error(`Entry file of dataset "${folderName}" not found.`);
  }
}

exports.build_ = async context => {
  context.logger.log('verbose', 'Start building models ...');
  let linker = new Linker(context);
  context.linker = linker;
  let schemaFiles = Linker.getOolongFiles(context.dslSourcePath, context.useJsonSource);
  schemaFiles.forEach(schemaFile => linker.link(schemaFile));

  let schemaToConnector = _.mapValues(linker.schemas, (_, schemaName) => {
    let connector = createConnector(context, schemaName);

    if (!connector) {
      throw new Error("Assertion failed: connector");
    }

    return connector;
  });

  return eachAsync_(context.schemaDeployment, async (deploymentSetting, schemaName) => {
    context.logger.log('verbose', `Processing schema "${schemaName}" ...`);
    let schema = linker.schemas[schemaName];

    if (!schema) {
      throw new Error(`Schema "${schemaName}" not found in model source."`);
    }

    let connector = schemaToConnector[schemaName];

    try {
      let DbModeler = require(`../modeler/database/${connector.driver}/Modeler`);

      let dbModeler = new DbModeler(context, connector, deploymentSetting.extraOptions);
      let refinedSchema = dbModeler.modeling(schema, schemaToConnector);

      const DaoModeler = require('../modeler/Dao');

      let daoModeler = new DaoModeler(context, connector);
      await daoModeler.modeling_(refinedSchema);
    } catch (error) {
      throw error;
    } finally {
      await connector.end_();
    }
  });
};

exports.migrate_ = async (context, reset = false) => {
  context.logger.log('verbose', 'Start deploying models ...');

  if (reset) {
    await eachAsync_(Object.keys(context.schemaDeployment).reverse(), async schemaName => {
      let connector = createConnector(context, schemaName);

      if (!connector) {
        throw new Error("Assertion failed: connector");
      }

      try {
        let Migration = require(`../migration/${connector.driver}`);

        let migration = new Migration(context, schemaName, connector);
        await migration.reset_();
      } catch (error) {
        throw error;
      } finally {
        await connector.end_();
      }
    });
  }

  return eachAsync_(context.schemaDeployment, async (deployment, schemaName) => {
    let connector = createConnector(context, schemaName);

    if (!connector) {
      throw new Error("Assertion failed: connector");
    }

    try {
      let Migration = require(`../migration/${connector.driver}`);

      let migration = new Migration(context, schemaName, connector);
      await migration.create_(deployment.extraOptions);
      await importDataFiles(migration, '_init');
    } catch (error) {
      throw error;
    } finally {
      await connector.end_();
    }
  });
};

exports.dataset_ = async (context, schemaName) => {
  let connector = createConnector(context, schemaName);

  if (!connector) {
    throw new Error("Assertion failed: connector");
  }

  let dataSetPath = path.join(context.scriptSourcePath, connector.driver, connector.database, 'data');

  if (!fs.existsSync(dataSetPath)) {
    return [];
  } else {
    let dataSets = fs.readdirSync(dataSetPath);
    let validDs = [];
    dataSets.forEach(ds => {
      let indexFile = path.join(dataSetPath, ds, 'index.list');

      if (fs.existsSync(indexFile)) {
        validDs.push(ds);
      }
    });
    return validDs;
  }
};

exports.import_ = async (context, schemaName, datasetName) => {
  let connector = createConnector(context, schemaName);

  if (!connector) {
    throw new Error("Assertion failed: connector");
  }

  try {
    let Migration = require(`../migration/${connector.driver}`);

    let migration = new Migration(context, schemaName, connector);
    await importDataFiles(migration, datasetName);
  } catch (error) {
    throw error;
  } finally {
    await connector.end_();
  }
};

exports.reverse_ = async context => {
  let ReserveEngineering = require(`../modeler/database/${context.driver}/ReverseEngineering`);

  let {
    connection: connectionString,
    ...options
  } = context.connOptions;
  let connector = Connector.createConnector(context.driver, connectionString, {
    logger: context.logger,
    ...options
  });

  if (!connector) {
    throw new Error("Assertion failed: connector");
  }

  try {
    let modeler = new ReserveEngineering(context, connector);
    await modeler.reverse_(context.dslReverseOutputPath);
  } catch (error) {
    throw error;
  } finally {
    await connector.end_();
  }
};

exports.getValidatorList = () => {
  return Object.keys(Validators);
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9sYW5nL2FwaS5qcyJdLCJuYW1lcyI6WyJwYXRoIiwicmVxdWlyZSIsIlV0aWwiLCJfIiwiZnMiLCJlYWNoQXN5bmNfIiwiTGlua2VyIiwiQ29ubmVjdG9yIiwiVmFsaWRhdG9ycyIsImNyZWF0ZUNvbm5lY3RvciIsImNvbnRleHQiLCJzY2hlbWFOYW1lIiwiZGVwbG95bWVudCIsInNjaGVtYURlcGxveW1lbnQiLCJFcnJvciIsImRhdGFTb3VyY2UiLCJjb25uZWN0aW9uU3RyaW5nIiwib3B0aW9ucyIsImRyaXZlciIsInNwbGl0IiwibG9nZ2VyIiwiaW1wb3J0RGF0YUZpbGVzQnlMaXN0IiwibWlncmF0b3IiLCJkYXRhU2V0UGF0aCIsImRhdGFMaXN0RmlsZSIsImRhdGFMaXN0IiwicmVhZEZpbGVTeW5jIiwidG9TdHJpbmciLCJtYXRjaCIsImxpbmUiLCJ0cmltIiwibGVuZ3RoIiwiZGF0YUZpbGUiLCJqb2luIiwiZXhpc3RzU3luYyIsImxvYWRfIiwiaW1wb3J0RGF0YUZpbGVzIiwiZm9sZGVyTmFtZSIsImRiU2NyaXB0UGF0aCIsInJ1bnRpbWVEYXRhU2V0UGF0aCIsInJ1bnRpbWVEYXRhU2V0RmlsZSIsImltcG9ydGVkIiwiYXBwTW9kdWxlIiwicnVudGltZUVudiIsImxvZyIsImV4cG9ydHMiLCJidWlsZF8iLCJsaW5rZXIiLCJzY2hlbWFGaWxlcyIsImdldE9vbG9uZ0ZpbGVzIiwiZHNsU291cmNlUGF0aCIsInVzZUpzb25Tb3VyY2UiLCJmb3JFYWNoIiwic2NoZW1hRmlsZSIsImxpbmsiLCJzY2hlbWFUb0Nvbm5lY3RvciIsIm1hcFZhbHVlcyIsInNjaGVtYXMiLCJjb25uZWN0b3IiLCJkZXBsb3ltZW50U2V0dGluZyIsInNjaGVtYSIsIkRiTW9kZWxlciIsImRiTW9kZWxlciIsImV4dHJhT3B0aW9ucyIsInJlZmluZWRTY2hlbWEiLCJtb2RlbGluZyIsIkRhb01vZGVsZXIiLCJkYW9Nb2RlbGVyIiwibW9kZWxpbmdfIiwiZXJyb3IiLCJlbmRfIiwibWlncmF0ZV8iLCJyZXNldCIsIk9iamVjdCIsImtleXMiLCJyZXZlcnNlIiwiTWlncmF0aW9uIiwibWlncmF0aW9uIiwicmVzZXRfIiwiY3JlYXRlXyIsImRhdGFzZXRfIiwic2NyaXB0U291cmNlUGF0aCIsImRhdGFiYXNlIiwiZGF0YVNldHMiLCJyZWFkZGlyU3luYyIsInZhbGlkRHMiLCJkcyIsImluZGV4RmlsZSIsInB1c2giLCJpbXBvcnRfIiwiZGF0YXNldE5hbWUiLCJyZXZlcnNlXyIsIlJlc2VydmVFbmdpbmVlcmluZyIsImNvbm5lY3Rpb24iLCJjb25uT3B0aW9ucyIsIm1vZGVsZXIiLCJkc2xSZXZlcnNlT3V0cHV0UGF0aCIsImdldFZhbGlkYXRvckxpc3QiXSwibWFwcGluZ3MiOiJBQUFBOzs7O0FBRUEsTUFBTUEsSUFBSSxHQUFHQyxPQUFPLENBQUMsTUFBRCxDQUFwQjs7QUFFQSxNQUFNQyxJQUFJLEdBQUdELE9BQU8sQ0FBQyxVQUFELENBQXBCOztBQUNBLE1BQU07QUFBRUUsRUFBQUEsQ0FBRjtBQUFLQyxFQUFBQSxFQUFMO0FBQVNDLEVBQUFBO0FBQVQsSUFBd0JILElBQTlCOztBQUVBLE1BQU1JLE1BQU0sR0FBR0wsT0FBTyxDQUFDLFVBQUQsQ0FBdEI7O0FBQ0EsTUFBTU0sU0FBUyxHQUFHTixPQUFPLENBQUMsc0JBQUQsQ0FBekI7O0FBQ0EsTUFBTU8sVUFBVSxHQUFHUCxPQUFPLENBQUMsdUJBQUQsQ0FBMUI7O0FBT0MsU0FBU1EsZUFBVCxDQUF5QkMsT0FBekIsRUFBa0NDLFVBQWxDLEVBQThDO0FBQzNDLE1BQUlDLFVBQVUsR0FBR0YsT0FBTyxDQUFDRyxnQkFBUixDQUF5QkYsVUFBekIsQ0FBakI7O0FBRUEsTUFBSSxDQUFDQyxVQUFMLEVBQWlCO0FBQ2IsVUFBTSxJQUFJRSxLQUFKLENBQVcsV0FBVUgsVUFBVyw0REFBaEMsQ0FBTjtBQUNIOztBQUVELE1BQUk7QUFBRUksSUFBQUEsVUFBRjtBQUFjQyxJQUFBQSxnQkFBZDtBQUFnQ0MsSUFBQUE7QUFBaEMsTUFBNENMLFVBQWhEO0FBQ0EsTUFBSSxDQUFFTSxNQUFGLElBQWFILFVBQVUsQ0FBQ0ksS0FBWCxDQUFpQixHQUFqQixDQUFqQjtBQUVBLFNBQU9aLFNBQVMsQ0FBQ0UsZUFBVixDQUEwQlMsTUFBMUIsRUFBa0NGLGdCQUFsQyxFQUFvRDtBQUFFSSxJQUFBQSxNQUFNLEVBQUVWLE9BQU8sQ0FBQ1UsTUFBbEI7QUFBMEIsT0FBR0g7QUFBN0IsR0FBcEQsQ0FBUDtBQUNGOztBQUVELGVBQWVJLHFCQUFmLENBQXFDQyxRQUFyQyxFQUErQ0MsV0FBL0MsRUFBNERDLFlBQTVELEVBQTBFO0FBQ3ZFLE1BQUlDLFFBQVEsR0FBR3JCLEVBQUUsQ0FBQ3NCLFlBQUgsQ0FBZ0JGLFlBQWhCLEVBQThCRyxRQUE5QixHQUF5Q0MsS0FBekMsQ0FBK0MsUUFBL0MsQ0FBZjs7QUFFQSxNQUFJLENBQUNILFFBQUwsRUFBZTtBQUNYO0FBQ0g7O0FBRUQsU0FBT3BCLFVBQVUsQ0FBQ29CLFFBQUQsRUFBVyxNQUFNSSxJQUFOLElBQWM7QUFDdENBLElBQUFBLElBQUksR0FBR0EsSUFBSSxDQUFDQyxJQUFMLEVBQVA7O0FBRUEsUUFBSUQsSUFBSSxDQUFDRSxNQUFMLEdBQWMsQ0FBZCxJQUFtQkYsSUFBSSxDQUFDLENBQUQsQ0FBSixLQUFZLEdBQW5DLEVBQXdDO0FBQ3BDLFVBQUlHLFFBQVEsR0FBR2hDLElBQUksQ0FBQ2lDLElBQUwsQ0FBVVYsV0FBVixFQUF1Qk0sSUFBdkIsQ0FBZjs7QUFDQSxVQUFJLENBQUN6QixFQUFFLENBQUM4QixVQUFILENBQWNGLFFBQWQsQ0FBTCxFQUE4QjtBQUMxQixjQUFNLElBQUlsQixLQUFKLENBQVcsY0FBYWtCLFFBQVMsY0FBakMsQ0FBTjtBQUNIOztBQUVELFlBQU1WLFFBQVEsQ0FBQ2EsS0FBVCxDQUFlSCxRQUFmLENBQU47QUFDSDtBQUNKLEdBWGdCLENBQWpCO0FBWUY7O0FBRUQsZUFBZUksZUFBZixDQUErQmQsUUFBL0IsRUFBeUNlLFVBQXpDLEVBQXFEO0FBQ2xELE1BQUlkLFdBQVcsR0FBR3ZCLElBQUksQ0FBQ2lDLElBQUwsQ0FBVVgsUUFBUSxDQUFDZ0IsWUFBbkIsRUFBaUMsTUFBakMsRUFBeUNELFVBQXpDLENBQWxCO0FBQ0EsTUFBSWIsWUFBWSxHQUFHeEIsSUFBSSxDQUFDaUMsSUFBTCxDQUFVVixXQUFWLEVBQXVCLFlBQXZCLENBQW5CO0FBRUEsTUFBSWdCLGtCQUFKO0FBQUEsTUFBd0JDLGtCQUF4QjtBQUFBLE1BQTRDQyxRQUFRLEdBQUcsS0FBdkQ7O0FBRUEsTUFBSW5CLFFBQVEsQ0FBQ29CLFNBQVQsQ0FBbUJDLFVBQXZCLEVBQW1DO0FBQy9CSixJQUFBQSxrQkFBa0IsR0FBR3ZDLElBQUksQ0FBQ2lDLElBQUwsQ0FBVVYsV0FBVixFQUF1QkQsUUFBUSxDQUFDb0IsU0FBVCxDQUFtQkMsVUFBMUMsQ0FBckI7QUFDQUgsSUFBQUEsa0JBQWtCLEdBQUd4QyxJQUFJLENBQUNpQyxJQUFMLENBQVVNLGtCQUFWLEVBQThCLFlBQTlCLENBQXJCO0FBQ0g7O0FBRUQsTUFBSW5DLEVBQUUsQ0FBQzhCLFVBQUgsQ0FBY1YsWUFBZCxDQUFKLEVBQWlDO0FBQzdCLFVBQU1ILHFCQUFxQixDQUFDQyxRQUFELEVBQVdDLFdBQVgsRUFBd0JDLFlBQXhCLENBQTNCO0FBQ0FpQixJQUFBQSxRQUFRLEdBQUcsSUFBWDtBQUNILEdBSEQsTUFHTztBQUNIbkIsSUFBQUEsUUFBUSxDQUFDb0IsU0FBVCxDQUFtQkUsR0FBbkIsQ0FBdUIsTUFBdkIsRUFBZ0MsdUJBQXNCcEIsWUFBYSxjQUFuRTtBQUNIOztBQUVELE1BQUlnQixrQkFBa0IsSUFBSXBDLEVBQUUsQ0FBQzhCLFVBQUgsQ0FBY00sa0JBQWQsQ0FBMUIsRUFBNkQ7QUFDekQsVUFBTW5CLHFCQUFxQixDQUFDQyxRQUFELEVBQVdpQixrQkFBWCxFQUErQkMsa0JBQS9CLENBQTNCO0FBQ0FDLElBQUFBLFFBQVEsR0FBRyxJQUFYO0FBQ0gsR0FIRCxNQUdPLElBQUluQixRQUFRLENBQUNvQixTQUFULENBQW1CQyxVQUF2QixFQUFtQztBQUN0Q3JCLElBQUFBLFFBQVEsQ0FBQ29CLFNBQVQsQ0FBbUJFLEdBQW5CLENBQXVCSCxRQUFRLEdBQUcsTUFBSCxHQUFZLE1BQTNDLEVBQW9ELDBCQUF5Qm5CLFFBQVEsQ0FBQ29CLFNBQVQsQ0FBbUJDLFVBQVcsVUFBU0gsa0JBQW1CLGNBQXZJO0FBQ0g7O0FBRUQsTUFBSSxDQUFDQyxRQUFMLEVBQWU7QUFDWCxVQUFNLElBQUkzQixLQUFKLENBQVcsMEJBQXlCdUIsVUFBVyxjQUEvQyxDQUFOO0FBQ0g7QUFDSDs7QUFjRlEsT0FBTyxDQUFDQyxNQUFSLEdBQWlCLE1BQU9wQyxPQUFQLElBQW1CO0FBQ2hDQSxFQUFBQSxPQUFPLENBQUNVLE1BQVIsQ0FBZXdCLEdBQWYsQ0FBbUIsU0FBbkIsRUFBOEIsMkJBQTlCO0FBRUEsTUFBSUcsTUFBTSxHQUFHLElBQUl6QyxNQUFKLENBQVdJLE9BQVgsQ0FBYjtBQUNBQSxFQUFBQSxPQUFPLENBQUNxQyxNQUFSLEdBQWlCQSxNQUFqQjtBQUVBLE1BQUlDLFdBQVcsR0FBRzFDLE1BQU0sQ0FBQzJDLGNBQVAsQ0FBc0J2QyxPQUFPLENBQUN3QyxhQUE5QixFQUE2Q3hDLE9BQU8sQ0FBQ3lDLGFBQXJELENBQWxCO0FBQ0FILEVBQUFBLFdBQVcsQ0FBQ0ksT0FBWixDQUFvQkMsVUFBVSxJQUFJTixNQUFNLENBQUNPLElBQVAsQ0FBWUQsVUFBWixDQUFsQzs7QUFFQSxNQUFJRSxpQkFBaUIsR0FBR3BELENBQUMsQ0FBQ3FELFNBQUYsQ0FBWVQsTUFBTSxDQUFDVSxPQUFuQixFQUE0QixDQUFDdEQsQ0FBRCxFQUFJUSxVQUFKLEtBQW1CO0FBQ25FLFFBQUkrQyxTQUFTLEdBQUdqRCxlQUFlLENBQUNDLE9BQUQsRUFBVUMsVUFBVixDQUEvQjs7QUFEbUUsU0FFM0QrQyxTQUYyRDtBQUFBO0FBQUE7O0FBSW5FLFdBQU9BLFNBQVA7QUFDSCxHQUx1QixDQUF4Qjs7QUFPQSxTQUFPckQsVUFBVSxDQUFDSyxPQUFPLENBQUNHLGdCQUFULEVBQTJCLE9BQU84QyxpQkFBUCxFQUEwQmhELFVBQTFCLEtBQXlDO0FBQ2pGRCxJQUFBQSxPQUFPLENBQUNVLE1BQVIsQ0FBZXdCLEdBQWYsQ0FBbUIsU0FBbkIsRUFBK0Isc0JBQXFCakMsVUFBVyxPQUEvRDtBQUVBLFFBQUlpRCxNQUFNLEdBQUdiLE1BQU0sQ0FBQ1UsT0FBUCxDQUFlOUMsVUFBZixDQUFiOztBQUVBLFFBQUksQ0FBQ2lELE1BQUwsRUFBYTtBQUNULFlBQU0sSUFBSTlDLEtBQUosQ0FBVyxXQUFVSCxVQUFXLCtCQUFoQyxDQUFOO0FBQ0g7O0FBRUQsUUFBSStDLFNBQVMsR0FBR0gsaUJBQWlCLENBQUM1QyxVQUFELENBQWpDOztBQUVBLFFBQUk7QUFDQSxVQUFJa0QsU0FBUyxHQUFHNUQsT0FBTyxDQUFFLHVCQUFzQnlELFNBQVMsQ0FBQ3hDLE1BQU8sVUFBekMsQ0FBdkI7O0FBQ0EsVUFBSTRDLFNBQVMsR0FBRyxJQUFJRCxTQUFKLENBQWNuRCxPQUFkLEVBQXVCZ0QsU0FBdkIsRUFBa0NDLGlCQUFpQixDQUFDSSxZQUFwRCxDQUFoQjtBQUNBLFVBQUlDLGFBQWEsR0FBR0YsU0FBUyxDQUFDRyxRQUFWLENBQW1CTCxNQUFuQixFQUEyQkwsaUJBQTNCLENBQXBCOztBQUVBLFlBQU1XLFVBQVUsR0FBR2pFLE9BQU8sQ0FBQyxnQkFBRCxDQUExQjs7QUFDQSxVQUFJa0UsVUFBVSxHQUFHLElBQUlELFVBQUosQ0FBZXhELE9BQWYsRUFBd0JnRCxTQUF4QixDQUFqQjtBQUVBLFlBQU1TLFVBQVUsQ0FBQ0MsU0FBWCxDQUFxQkosYUFBckIsQ0FBTjtBQUNILEtBVEQsQ0FTRSxPQUFPSyxLQUFQLEVBQWM7QUFDWixZQUFNQSxLQUFOO0FBQ0gsS0FYRCxTQVdVO0FBQ04sWUFBTVgsU0FBUyxDQUFDWSxJQUFWLEVBQU47QUFDSDtBQUNKLEdBekJnQixDQUFqQjtBQTBCSCxDQTFDRDs7QUF1REF6QixPQUFPLENBQUMwQixRQUFSLEdBQW1CLE9BQU83RCxPQUFQLEVBQWdCOEQsS0FBSyxHQUFHLEtBQXhCLEtBQWtDO0FBQ2pEOUQsRUFBQUEsT0FBTyxDQUFDVSxNQUFSLENBQWV3QixHQUFmLENBQW1CLFNBQW5CLEVBQThCLDRCQUE5Qjs7QUFFQSxNQUFJNEIsS0FBSixFQUFXO0FBQ1AsVUFBTW5FLFVBQVUsQ0FBQ29FLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZaEUsT0FBTyxDQUFDRyxnQkFBcEIsRUFBc0M4RCxPQUF0QyxFQUFELEVBQWtELE1BQU9oRSxVQUFQLElBQXNCO0FBQ3BGLFVBQUkrQyxTQUFTLEdBQUdqRCxlQUFlLENBQUNDLE9BQUQsRUFBVUMsVUFBVixDQUEvQjs7QUFEb0YsV0FFNUUrQyxTQUY0RTtBQUFBO0FBQUE7O0FBSXBGLFVBQUk7QUFDQSxZQUFJa0IsU0FBUyxHQUFHM0UsT0FBTyxDQUFFLGdCQUFleUQsU0FBUyxDQUFDeEMsTUFBTyxFQUFsQyxDQUF2Qjs7QUFDQSxZQUFJMkQsU0FBUyxHQUFHLElBQUlELFNBQUosQ0FBY2xFLE9BQWQsRUFBdUJDLFVBQXZCLEVBQW1DK0MsU0FBbkMsQ0FBaEI7QUFFQSxjQUFNbUIsU0FBUyxDQUFDQyxNQUFWLEVBQU47QUFDSCxPQUxELENBS0UsT0FBT1QsS0FBUCxFQUFjO0FBQ1osY0FBTUEsS0FBTjtBQUNILE9BUEQsU0FPVTtBQUNOLGNBQU1YLFNBQVMsQ0FBQ1ksSUFBVixFQUFOO0FBQ0g7QUFDSixLQWRlLENBQWhCO0FBZUg7O0FBRUQsU0FBT2pFLFVBQVUsQ0FBQ0ssT0FBTyxDQUFDRyxnQkFBVCxFQUEyQixPQUFPRCxVQUFQLEVBQW1CRCxVQUFuQixLQUFrQztBQUMxRSxRQUFJK0MsU0FBUyxHQUFHakQsZUFBZSxDQUFDQyxPQUFELEVBQVVDLFVBQVYsQ0FBL0I7O0FBRDBFLFNBRWxFK0MsU0FGa0U7QUFBQTtBQUFBOztBQUkxRSxRQUFJO0FBQ0EsVUFBSWtCLFNBQVMsR0FBRzNFLE9BQU8sQ0FBRSxnQkFBZXlELFNBQVMsQ0FBQ3hDLE1BQU8sRUFBbEMsQ0FBdkI7O0FBQ0EsVUFBSTJELFNBQVMsR0FBRyxJQUFJRCxTQUFKLENBQWNsRSxPQUFkLEVBQXVCQyxVQUF2QixFQUFtQytDLFNBQW5DLENBQWhCO0FBRUEsWUFBTW1CLFNBQVMsQ0FBQ0UsT0FBVixDQUFrQm5FLFVBQVUsQ0FBQ21ELFlBQTdCLENBQU47QUFFQSxZQUFNM0IsZUFBZSxDQUFDeUMsU0FBRCxFQUFZLE9BQVosQ0FBckI7QUFDSCxLQVBELENBT0UsT0FBT1IsS0FBUCxFQUFjO0FBQ1osWUFBTUEsS0FBTjtBQUNILEtBVEQsU0FTVTtBQUNOLFlBQU1YLFNBQVMsQ0FBQ1ksSUFBVixFQUFOO0FBQ0g7QUFDSixHQWhCZ0IsQ0FBakI7QUFpQkgsQ0F0Q0Q7O0FBNENBekIsT0FBTyxDQUFDbUMsUUFBUixHQUFtQixPQUFPdEUsT0FBUCxFQUFnQkMsVUFBaEIsS0FBK0I7QUFDOUMsTUFBSStDLFNBQVMsR0FBR2pELGVBQWUsQ0FBQ0MsT0FBRCxFQUFVQyxVQUFWLENBQS9COztBQUQ4QyxPQUV0QytDLFNBRnNDO0FBQUE7QUFBQTs7QUFJOUMsTUFBSW5DLFdBQVcsR0FBR3ZCLElBQUksQ0FBQ2lDLElBQUwsQ0FBVXZCLE9BQU8sQ0FBQ3VFLGdCQUFsQixFQUFvQ3ZCLFNBQVMsQ0FBQ3hDLE1BQTlDLEVBQXNEd0MsU0FBUyxDQUFDd0IsUUFBaEUsRUFBMEUsTUFBMUUsQ0FBbEI7O0FBRUEsTUFBSSxDQUFDOUUsRUFBRSxDQUFDOEIsVUFBSCxDQUFjWCxXQUFkLENBQUwsRUFBaUM7QUFDN0IsV0FBTyxFQUFQO0FBQ0gsR0FGRCxNQUVPO0FBQ0gsUUFBSTRELFFBQVEsR0FBRy9FLEVBQUUsQ0FBQ2dGLFdBQUgsQ0FBZTdELFdBQWYsQ0FBZjtBQUNBLFFBQUk4RCxPQUFPLEdBQUcsRUFBZDtBQUNBRixJQUFBQSxRQUFRLENBQUMvQixPQUFULENBQWlCa0MsRUFBRSxJQUFJO0FBQ25CLFVBQUlDLFNBQVMsR0FBR3ZGLElBQUksQ0FBQ2lDLElBQUwsQ0FBVVYsV0FBVixFQUF1QitELEVBQXZCLEVBQTJCLFlBQTNCLENBQWhCOztBQUNBLFVBQUlsRixFQUFFLENBQUM4QixVQUFILENBQWNxRCxTQUFkLENBQUosRUFBOEI7QUFDMUJGLFFBQUFBLE9BQU8sQ0FBQ0csSUFBUixDQUFhRixFQUFiO0FBQ0g7QUFDSixLQUxEO0FBT0EsV0FBT0QsT0FBUDtBQUNIO0FBQ0osQ0FwQkQ7O0FBK0JBeEMsT0FBTyxDQUFDNEMsT0FBUixHQUFrQixPQUFPL0UsT0FBUCxFQUFnQkMsVUFBaEIsRUFBNEIrRSxXQUE1QixLQUE0QztBQUMxRCxNQUFJaEMsU0FBUyxHQUFHakQsZUFBZSxDQUFDQyxPQUFELEVBQVVDLFVBQVYsQ0FBL0I7O0FBRDBELE9BRWxEK0MsU0FGa0Q7QUFBQTtBQUFBOztBQUkxRCxNQUFJO0FBQ0EsUUFBSWtCLFNBQVMsR0FBRzNFLE9BQU8sQ0FBRSxnQkFBZXlELFNBQVMsQ0FBQ3hDLE1BQU8sRUFBbEMsQ0FBdkI7O0FBQ0EsUUFBSTJELFNBQVMsR0FBRyxJQUFJRCxTQUFKLENBQWNsRSxPQUFkLEVBQXVCQyxVQUF2QixFQUFtQytDLFNBQW5DLENBQWhCO0FBRUEsVUFBTXRCLGVBQWUsQ0FBQ3lDLFNBQUQsRUFBWWEsV0FBWixDQUFyQjtBQUNILEdBTEQsQ0FLRSxPQUFPckIsS0FBUCxFQUFjO0FBQ1osVUFBTUEsS0FBTjtBQUNILEdBUEQsU0FPVTtBQUNOLFVBQU1YLFNBQVMsQ0FBQ1ksSUFBVixFQUFOO0FBQ0g7QUFDSixDQWREOztBQTBCQXpCLE9BQU8sQ0FBQzhDLFFBQVIsR0FBbUIsTUFBT2pGLE9BQVAsSUFBbUI7QUFDbEMsTUFBSWtGLGtCQUFrQixHQUFHM0YsT0FBTyxDQUFFLHVCQUFzQlMsT0FBTyxDQUFDUSxNQUFPLHFCQUF2QyxDQUFoQzs7QUFFQSxNQUFJO0FBQUUyRSxJQUFBQSxVQUFVLEVBQUU3RSxnQkFBZDtBQUFnQyxPQUFHQztBQUFuQyxNQUErQ1AsT0FBTyxDQUFDb0YsV0FBM0Q7QUFDQSxNQUFJcEMsU0FBUyxHQUFHbkQsU0FBUyxDQUFDRSxlQUFWLENBQTBCQyxPQUFPLENBQUNRLE1BQWxDLEVBQTBDRixnQkFBMUMsRUFBNEQ7QUFBRUksSUFBQUEsTUFBTSxFQUFFVixPQUFPLENBQUNVLE1BQWxCO0FBQTBCLE9BQUdIO0FBQTdCLEdBQTVELENBQWhCOztBQUprQyxPQUsxQnlDLFNBTDBCO0FBQUE7QUFBQTs7QUFPbEMsTUFBSTtBQUNBLFFBQUlxQyxPQUFPLEdBQUcsSUFBSUgsa0JBQUosQ0FBdUJsRixPQUF2QixFQUFnQ2dELFNBQWhDLENBQWQ7QUFFQSxVQUFNcUMsT0FBTyxDQUFDSixRQUFSLENBQWlCakYsT0FBTyxDQUFDc0Ysb0JBQXpCLENBQU47QUFDSCxHQUpELENBSUUsT0FBTzNCLEtBQVAsRUFBYztBQUNaLFVBQU1BLEtBQU47QUFDSCxHQU5ELFNBTVU7QUFDTixVQUFNWCxTQUFTLENBQUNZLElBQVYsRUFBTjtBQUNIO0FBQ0osQ0FoQkQ7O0FBa0JBekIsT0FBTyxDQUFDb0QsZ0JBQVIsR0FBMkIsTUFBTTtBQUM3QixTQUFPeEIsTUFBTSxDQUFDQyxJQUFQLENBQVlsRSxVQUFaLENBQVA7QUFDSCxDQUZEIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5cbmNvbnN0IFV0aWwgPSByZXF1aXJlKCdyay11dGlscycpO1xuY29uc3QgeyBfLCBmcywgZWFjaEFzeW5jXyB9ID0gVXRpbDtcblxuY29uc3QgTGlua2VyID0gcmVxdWlyZSgnLi9MaW5rZXInKTtcbmNvbnN0IENvbm5lY3RvciA9IHJlcXVpcmUoJy4uL3J1bnRpbWUvQ29ubmVjdG9yJyk7XG5jb25zdCBWYWxpZGF0b3JzID0gcmVxdWlyZSgnLi4vcnVudGltZS9WYWxpZGF0b3JzJyk7XG5cbi8qKlxuICogT29sb25nIERTTCBhcGlcbiAqIEBtb2R1bGUgT29sb25nXG4gKi9cblxuIGZ1bmN0aW9uIGNyZWF0ZUNvbm5lY3Rvcihjb250ZXh0LCBzY2hlbWFOYW1lKSB7XG4gICAgbGV0IGRlcGxveW1lbnQgPSBjb250ZXh0LnNjaGVtYURlcGxveW1lbnRbc2NoZW1hTmFtZV07XG5cbiAgICBpZiAoIWRlcGxveW1lbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTY2hlbWEgXCIke3NjaGVtYU5hbWV9XCIgaGFzIG5vIGNvbmZpZ3VyZWQgZGVwbG95bWVudCBhbmQgaXMgaWdub3JlZCBpbiBtb2RlbGluZy5gKTtcbiAgICB9XG5cbiAgICBsZXQgeyBkYXRhU291cmNlLCBjb25uZWN0aW9uU3RyaW5nLCBvcHRpb25zIH0gPSBkZXBsb3ltZW50O1xuICAgIGxldCBbIGRyaXZlciBdID0gZGF0YVNvdXJjZS5zcGxpdCgnLicpO1xuXG4gICAgcmV0dXJuIENvbm5lY3Rvci5jcmVhdGVDb25uZWN0b3IoZHJpdmVyLCBjb25uZWN0aW9uU3RyaW5nLCB7IGxvZ2dlcjogY29udGV4dC5sb2dnZXIsIC4uLm9wdGlvbnMgfSk7ICAgICAgIFxuIH1cblxuIGFzeW5jIGZ1bmN0aW9uIGltcG9ydERhdGFGaWxlc0J5TGlzdChtaWdyYXRvciwgZGF0YVNldFBhdGgsIGRhdGFMaXN0RmlsZSkge1xuICAgIGxldCBkYXRhTGlzdCA9IGZzLnJlYWRGaWxlU3luYyhkYXRhTGlzdEZpbGUpLnRvU3RyaW5nKCkubWF0Y2goL14uKyQvZ20pO1xuXG4gICAgaWYgKCFkYXRhTGlzdCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuIGVhY2hBc3luY18oZGF0YUxpc3QsIGFzeW5jIGxpbmUgPT4ge1xuICAgICAgICBsaW5lID0gbGluZS50cmltKCk7XG5cbiAgICAgICAgaWYgKGxpbmUubGVuZ3RoID4gMCAmJiBsaW5lWzBdICE9PSAnIycpIHsgICAgICAgICAgICBcbiAgICAgICAgICAgIGxldCBkYXRhRmlsZSA9IHBhdGguam9pbihkYXRhU2V0UGF0aCwgbGluZSk7XG4gICAgICAgICAgICBpZiAoIWZzLmV4aXN0c1N5bmMoZGF0YUZpbGUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEYXRhIGZpbGUgXCIke2RhdGFGaWxlfVwiIG5vdCBmb3VuZC5gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXdhaXQgbWlncmF0b3IubG9hZF8oZGF0YUZpbGUpO1xuICAgICAgICB9XG4gICAgfSk7IFxuIH1cblxuIGFzeW5jIGZ1bmN0aW9uIGltcG9ydERhdGFGaWxlcyhtaWdyYXRvciwgZm9sZGVyTmFtZSkge1xuICAgIGxldCBkYXRhU2V0UGF0aCA9IHBhdGguam9pbihtaWdyYXRvci5kYlNjcmlwdFBhdGgsICdkYXRhJywgZm9sZGVyTmFtZSk7XG4gICAgbGV0IGRhdGFMaXN0RmlsZSA9IHBhdGguam9pbihkYXRhU2V0UGF0aCwgJ2luZGV4Lmxpc3QnKTtcblxuICAgIGxldCBydW50aW1lRGF0YVNldFBhdGgsIHJ1bnRpbWVEYXRhU2V0RmlsZSwgaW1wb3J0ZWQgPSBmYWxzZTsgICAgXG5cbiAgICBpZiAobWlncmF0b3IuYXBwTW9kdWxlLnJ1bnRpbWVFbnYpIHtcbiAgICAgICAgcnVudGltZURhdGFTZXRQYXRoID0gcGF0aC5qb2luKGRhdGFTZXRQYXRoLCBtaWdyYXRvci5hcHBNb2R1bGUucnVudGltZUVudik7ICAgICAgICBcbiAgICAgICAgcnVudGltZURhdGFTZXRGaWxlID0gcGF0aC5qb2luKHJ1bnRpbWVEYXRhU2V0UGF0aCwgJ2luZGV4Lmxpc3QnKTtcbiAgICB9ICAgIFxuXG4gICAgaWYgKGZzLmV4aXN0c1N5bmMoZGF0YUxpc3RGaWxlKSkge1xuICAgICAgICBhd2FpdCBpbXBvcnREYXRhRmlsZXNCeUxpc3QobWlncmF0b3IsIGRhdGFTZXRQYXRoLCBkYXRhTGlzdEZpbGUpOyAgICAgIFxuICAgICAgICBpbXBvcnRlZCA9IHRydWU7ICBcbiAgICB9IGVsc2Uge1xuICAgICAgICBtaWdyYXRvci5hcHBNb2R1bGUubG9nKCd3YXJuJywgYERhdGFzZXQgaW5kZXggZmlsZSBcIiR7ZGF0YUxpc3RGaWxlfVwiIG5vdCBleGlzdC5gKVxuICAgIH1cbiAgICBcbiAgICBpZiAocnVudGltZURhdGFTZXRGaWxlICYmIGZzLmV4aXN0c1N5bmMocnVudGltZURhdGFTZXRGaWxlKSkge1xuICAgICAgICBhd2FpdCBpbXBvcnREYXRhRmlsZXNCeUxpc3QobWlncmF0b3IsIHJ1bnRpbWVEYXRhU2V0UGF0aCwgcnVudGltZURhdGFTZXRGaWxlKTsgICAgXG4gICAgICAgIGltcG9ydGVkID0gdHJ1ZTsgICAgICBcbiAgICB9IGVsc2UgaWYgKG1pZ3JhdG9yLmFwcE1vZHVsZS5ydW50aW1lRW52KSB7XG4gICAgICAgIG1pZ3JhdG9yLmFwcE1vZHVsZS5sb2coaW1wb3J0ZWQgPyAnaW5mbycgOiAnd2FybicsIGBEYXRhc2V0IGluZGV4IGZpbGUgb2YgXCIke21pZ3JhdG9yLmFwcE1vZHVsZS5ydW50aW1lRW52fVwiIGVudiBcIiR7cnVudGltZURhdGFTZXRGaWxlfVwiIG5vdCBleGlzdC5gKVxuICAgIH1cbiAgICBcbiAgICBpZiAoIWltcG9ydGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRW50cnkgZmlsZSBvZiBkYXRhc2V0IFwiJHtmb2xkZXJOYW1lfVwiIG5vdCBmb3VuZC5gKTtcbiAgICB9ICAgIFxuIH1cblxuLyoqXG4gKiBCdWlsZCBkYXRhYmFzZSBzY3JpcHRzIGFuZCBlbnRpdHkgbW9kZWxzIGZyb20gb29sb25nIGZpbGVzLlxuICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAqIEBwcm9wZXJ0eSB7TG9nZ2VyfSBjb250ZXh0LmxvZ2dlciAtIExvZ2dlciBvYmplY3RcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjb250ZXh0LmRzbFNvdXJjZVBhdGhcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjb250ZXh0Lm1vZGVsT3V0cHV0UGF0aCAgICAgICAgIFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGNvbnRleHQuc2NyaXB0T3V0cHV0UGF0aFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGNvbnRleHQubWFuaWZlc3RPdXRwdXRQYXRoXG4gKiBAcHJvcGVydHkge2Jvb2x9IGNvbnRleHQudXNlSnNvblNvdXJjZVxuICogQHByb3BlcnR5IHtvYmplY3R9IGNvbnRleHQuc2NoZW1hRGVwbG95bWVudCAgIFxuICogQHJldHVybnMge1Byb21pc2V9XG4gKi9cbmV4cG9ydHMuYnVpbGRfID0gYXN5bmMgKGNvbnRleHQpID0+IHtcbiAgICBjb250ZXh0LmxvZ2dlci5sb2coJ3ZlcmJvc2UnLCAnU3RhcnQgYnVpbGRpbmcgbW9kZWxzIC4uLicpO1xuXG4gICAgbGV0IGxpbmtlciA9IG5ldyBMaW5rZXIoY29udGV4dCk7XG4gICAgY29udGV4dC5saW5rZXIgPSBsaW5rZXI7ICAgIFxuXG4gICAgbGV0IHNjaGVtYUZpbGVzID0gTGlua2VyLmdldE9vbG9uZ0ZpbGVzKGNvbnRleHQuZHNsU291cmNlUGF0aCwgY29udGV4dC51c2VKc29uU291cmNlKTtcbiAgICBzY2hlbWFGaWxlcy5mb3JFYWNoKHNjaGVtYUZpbGUgPT4gbGlua2VyLmxpbmsoc2NoZW1hRmlsZSkpOyAgXG4gICAgXG4gICAgbGV0IHNjaGVtYVRvQ29ubmVjdG9yID0gXy5tYXBWYWx1ZXMobGlua2VyLnNjaGVtYXMsIChfLCBzY2hlbWFOYW1lKSA9PiB7XG4gICAgICAgIGxldCBjb25uZWN0b3IgPSBjcmVhdGVDb25uZWN0b3IoY29udGV4dCwgc2NoZW1hTmFtZSk7XG4gICAgICAgIGFzc2VydDogY29ubmVjdG9yO1xuXG4gICAgICAgIHJldHVybiBjb25uZWN0b3I7XG4gICAgfSk7ICAgIFxuXG4gICAgcmV0dXJuIGVhY2hBc3luY18oY29udGV4dC5zY2hlbWFEZXBsb3ltZW50LCBhc3luYyAoZGVwbG95bWVudFNldHRpbmcsIHNjaGVtYU5hbWUpID0+IHsgICAgICBcbiAgICAgICAgY29udGV4dC5sb2dnZXIubG9nKCd2ZXJib3NlJywgYFByb2Nlc3Npbmcgc2NoZW1hIFwiJHtzY2hlbWFOYW1lfVwiIC4uLmApOyAgIFxuICAgICAgICBcbiAgICAgICAgbGV0IHNjaGVtYSA9IGxpbmtlci5zY2hlbWFzW3NjaGVtYU5hbWVdO1xuXG4gICAgICAgIGlmICghc2NoZW1hKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNjaGVtYSBcIiR7c2NoZW1hTmFtZX1cIiBub3QgZm91bmQgaW4gbW9kZWwgc291cmNlLlwiYCk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY29ubmVjdG9yID0gc2NoZW1hVG9Db25uZWN0b3Jbc2NoZW1hTmFtZV07XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBEYk1vZGVsZXIgPSByZXF1aXJlKGAuLi9tb2RlbGVyL2RhdGFiYXNlLyR7Y29ubmVjdG9yLmRyaXZlcn0vTW9kZWxlcmApO1xuICAgICAgICAgICAgbGV0IGRiTW9kZWxlciA9IG5ldyBEYk1vZGVsZXIoY29udGV4dCwgY29ubmVjdG9yLCBkZXBsb3ltZW50U2V0dGluZy5leHRyYU9wdGlvbnMpO1xuICAgICAgICAgICAgbGV0IHJlZmluZWRTY2hlbWEgPSBkYk1vZGVsZXIubW9kZWxpbmcoc2NoZW1hLCBzY2hlbWFUb0Nvbm5lY3Rvcik7XG5cbiAgICAgICAgICAgIGNvbnN0IERhb01vZGVsZXIgPSByZXF1aXJlKCcuLi9tb2RlbGVyL0RhbycpO1xuICAgICAgICAgICAgbGV0IGRhb01vZGVsZXIgPSBuZXcgRGFvTW9kZWxlcihjb250ZXh0LCBjb25uZWN0b3IpO1xuXG4gICAgICAgICAgICBhd2FpdCBkYW9Nb2RlbGVyLm1vZGVsaW5nXyhyZWZpbmVkU2NoZW1hKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgYXdhaXQgY29ubmVjdG9yLmVuZF8oKTtcbiAgICAgICAgfSBcbiAgICB9KTsgICAgICAgICAgICBcbn07XG5cbi8qKlxuICogRGVwbG95IGRhdGFiYXNlIHNjcmlwdHMgaW50byBkYXRhYmFzZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gKiBAcHJvcGVydHkge0xvZ2dlcn0gY29udGV4dC5sb2dnZXIgLSBMb2dnZXIgb2JqZWN0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gY29udGV4dC5tb2RlbFBhdGhcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjb250ZXh0LmRzbFNvdXJjZVBhdGggXG4gKiBAcHJvcGVydHkge3N0cmluZ30gY29udGV4dC5zY3JpcHRTb3VyY2VQYXRoIFxuICogQHByb3BlcnR5IHtvYmplY3R9IGNvbnRleHQuc2NoZW1hRGVwbG95bWVudCAgIFxuICogQHBhcmFtIHtib29sfSByZXNldFxuICogQHJldHVybnMge1Byb21pc2V9XG4gKi9cbmV4cG9ydHMubWlncmF0ZV8gPSBhc3luYyAoY29udGV4dCwgcmVzZXQgPSBmYWxzZSkgPT4ge1xuICAgIGNvbnRleHQubG9nZ2VyLmxvZygndmVyYm9zZScsICdTdGFydCBkZXBsb3lpbmcgbW9kZWxzIC4uLicpO1xuXG4gICAgaWYgKHJlc2V0KSB7XG4gICAgICAgIGF3YWl0IGVhY2hBc3luY18oT2JqZWN0LmtleXMoY29udGV4dC5zY2hlbWFEZXBsb3ltZW50KS5yZXZlcnNlKCksIGFzeW5jIChzY2hlbWFOYW1lKSA9PiB7XG4gICAgICAgICAgICBsZXQgY29ubmVjdG9yID0gY3JlYXRlQ29ubmVjdG9yKGNvbnRleHQsIHNjaGVtYU5hbWUpO1xuICAgICAgICAgICAgYXNzZXJ0OiBjb25uZWN0b3I7XG4gICAgXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxldCBNaWdyYXRpb24gPSByZXF1aXJlKGAuLi9taWdyYXRpb24vJHtjb25uZWN0b3IuZHJpdmVyfWApO1xuICAgICAgICAgICAgICAgIGxldCBtaWdyYXRpb24gPSBuZXcgTWlncmF0aW9uKGNvbnRleHQsIHNjaGVtYU5hbWUsIGNvbm5lY3Rvcik7XG4gICAgXG4gICAgICAgICAgICAgICAgYXdhaXQgbWlncmF0aW9uLnJlc2V0XygpOyAgICBcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGF3YWl0IGNvbm5lY3Rvci5lbmRfKCk7XG4gICAgICAgICAgICB9IFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWFjaEFzeW5jXyhjb250ZXh0LnNjaGVtYURlcGxveW1lbnQsIGFzeW5jIChkZXBsb3ltZW50LCBzY2hlbWFOYW1lKSA9PiB7XG4gICAgICAgIGxldCBjb25uZWN0b3IgPSBjcmVhdGVDb25uZWN0b3IoY29udGV4dCwgc2NoZW1hTmFtZSk7XG4gICAgICAgIGFzc2VydDogY29ubmVjdG9yO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgTWlncmF0aW9uID0gcmVxdWlyZShgLi4vbWlncmF0aW9uLyR7Y29ubmVjdG9yLmRyaXZlcn1gKTtcbiAgICAgICAgICAgIGxldCBtaWdyYXRpb24gPSBuZXcgTWlncmF0aW9uKGNvbnRleHQsIHNjaGVtYU5hbWUsIGNvbm5lY3Rvcik7XG5cbiAgICAgICAgICAgIGF3YWl0IG1pZ3JhdGlvbi5jcmVhdGVfKGRlcGxveW1lbnQuZXh0cmFPcHRpb25zKTsgICAgICBcblxuICAgICAgICAgICAgYXdhaXQgaW1wb3J0RGF0YUZpbGVzKG1pZ3JhdGlvbiwgJ19pbml0Jyk7ICBcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgYXdhaXQgY29ubmVjdG9yLmVuZF8oKTtcbiAgICAgICAgfSBcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAqIEBwYXJhbSB7c3RyaW5nfSBzY2hlbWFOYW1lXG4gKi9cbmV4cG9ydHMuZGF0YXNldF8gPSBhc3luYyAoY29udGV4dCwgc2NoZW1hTmFtZSkgPT4ge1xuICAgIGxldCBjb25uZWN0b3IgPSBjcmVhdGVDb25uZWN0b3IoY29udGV4dCwgc2NoZW1hTmFtZSk7XG4gICAgYXNzZXJ0OiBjb25uZWN0b3I7XG4gICAgXG4gICAgbGV0IGRhdGFTZXRQYXRoID0gcGF0aC5qb2luKGNvbnRleHQuc2NyaXB0U291cmNlUGF0aCwgY29ubmVjdG9yLmRyaXZlciwgY29ubmVjdG9yLmRhdGFiYXNlLCAnZGF0YScpO1xuXG4gICAgaWYgKCFmcy5leGlzdHNTeW5jKGRhdGFTZXRQYXRoKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGRhdGFTZXRzID0gZnMucmVhZGRpclN5bmMoZGF0YVNldFBhdGgpO1xuICAgICAgICBsZXQgdmFsaWREcyA9IFtdO1xuICAgICAgICBkYXRhU2V0cy5mb3JFYWNoKGRzID0+IHtcbiAgICAgICAgICAgIGxldCBpbmRleEZpbGUgPSBwYXRoLmpvaW4oZGF0YVNldFBhdGgsIGRzLCAnaW5kZXgubGlzdCcpO1xuICAgICAgICAgICAgaWYgKGZzLmV4aXN0c1N5bmMoaW5kZXhGaWxlKSkge1xuICAgICAgICAgICAgICAgIHZhbGlkRHMucHVzaChkcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB2YWxpZERzO1xuICAgIH1cbn1cblxuLyoqXG4gKiBJbXBvcnQgYSBkYXRhIHNldCBpbnRvIGRhdGFiYXNlXG4gKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICogQHByb3BlcnR5IHtMb2dnZXJ9IGNvbnRleHQubG9nZ2VyIC0gTG9nZ2VyIG9iamVjdFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGNvbnRleHQuc2NyaXB0U291cmNlUGF0aCAgXG4gKiBAcGFyYW0ge3N0cmluZ30gc2NoZW1hTmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGFzZXROYW1lXG4gKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAqL1xuZXhwb3J0cy5pbXBvcnRfID0gYXN5bmMgKGNvbnRleHQsIHNjaGVtYU5hbWUsIGRhdGFzZXROYW1lKSA9PiB7XG4gICAgbGV0IGNvbm5lY3RvciA9IGNyZWF0ZUNvbm5lY3Rvcihjb250ZXh0LCBzY2hlbWFOYW1lKTtcbiAgICBhc3NlcnQ6IGNvbm5lY3RvcjtcbiAgICBcbiAgICB0cnkge1xuICAgICAgICBsZXQgTWlncmF0aW9uID0gcmVxdWlyZShgLi4vbWlncmF0aW9uLyR7Y29ubmVjdG9yLmRyaXZlcn1gKTtcbiAgICAgICAgbGV0IG1pZ3JhdGlvbiA9IG5ldyBNaWdyYXRpb24oY29udGV4dCwgc2NoZW1hTmFtZSwgY29ubmVjdG9yKTtcblxuICAgICAgICBhd2FpdCBpbXBvcnREYXRhRmlsZXMobWlncmF0aW9uLCBkYXRhc2V0TmFtZSk7ICAgICAgICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgYXdhaXQgY29ubmVjdG9yLmVuZF8oKTtcbiAgICB9IFxufTtcblxuLyoqXG4gKiBFeHRyYWN0IGRhdGFiYXNlIHN0cnVjdHVyZSBpbnRvIG9vbG9uZyBkc2xcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gKiBAcHJvcGVydHkge0Nvbm5lY3Rvcn0gY29udGV4dC5jb25uZWN0b3JcbiAqIEBwcm9wZXJ0eSB7TG9nZ2VyfSBjb250ZXh0LmxvZ2dlciBcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjb250ZXh0LmRzbFJldmVyc2VPdXRwdXRQYXRoIFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGNvbnRleHQuZHJpdmVyXG4gKiBAcHJvcGVydHkge29iamVjdH0gY29udGV4dC5jb25uT3B0aW9ucyBcbiAqIEByZXR1cm5zIHtQcm9taXNlfVxuICovXG5leHBvcnRzLnJldmVyc2VfID0gYXN5bmMgKGNvbnRleHQpID0+IHsgICBcbiAgICBsZXQgUmVzZXJ2ZUVuZ2luZWVyaW5nID0gcmVxdWlyZShgLi4vbW9kZWxlci9kYXRhYmFzZS8ke2NvbnRleHQuZHJpdmVyfS9SZXZlcnNlRW5naW5lZXJpbmdgKTtcbiAgICBcbiAgICBsZXQgeyBjb25uZWN0aW9uOiBjb25uZWN0aW9uU3RyaW5nLCAuLi5vcHRpb25zIH0gPSBjb250ZXh0LmNvbm5PcHRpb25zOyAgXG4gICAgbGV0IGNvbm5lY3RvciA9IENvbm5lY3Rvci5jcmVhdGVDb25uZWN0b3IoY29udGV4dC5kcml2ZXIsIGNvbm5lY3Rpb25TdHJpbmcsIHsgbG9nZ2VyOiBjb250ZXh0LmxvZ2dlciwgLi4ub3B0aW9ucyB9KTsgICAgIFxuICAgIGFzc2VydDogY29ubmVjdG9yOyAgXG5cbiAgICB0cnkge1xuICAgICAgICBsZXQgbW9kZWxlciA9IG5ldyBSZXNlcnZlRW5naW5lZXJpbmcoY29udGV4dCwgY29ubmVjdG9yKTtcblxuICAgICAgICBhd2FpdCBtb2RlbGVyLnJldmVyc2VfKGNvbnRleHQuZHNsUmV2ZXJzZU91dHB1dFBhdGgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIGF3YWl0IGNvbm5lY3Rvci5lbmRfKCk7XG4gICAgfSBcbn07XG5cbmV4cG9ydHMuZ2V0VmFsaWRhdG9yTGlzdCA9ICgpID0+IHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoVmFsaWRhdG9ycyk7ICAgIFxufSJdfQ==