"use strict";

require("source-map-support/register");

const validator = require("validator");

const {
  _
} = require("rk-utils");

exports.toBoolean = value => typeof value === "boolean" ? value : validator.toBoolean(value.toString(), true);

exports.toText = (value, noTrim) => {
  if (value) {
    value = typeof value !== "string" ? value.toString() : value;
    return noTrim ? value : value.trim();
  }

  return value;
};

exports.toInt = (value, radix) => _.isInteger(value) ? value : parseInt(value, radix);

exports.toFloat = value => _.isFinite(value) ? value : validator.toFloat(value);

exports.jsonToBase64 = obj => Buffer.from(JSON.stringify(obj)).toString("base64");

exports.base64ToJson = base64 => JSON.parse(Buffer.from(base64, "base64").toString("ascii"));

exports.toKVPairs = (arrayOfObjects, property, transformer) => {
  const keyGetter = typeof property === "function" ? property : obj => obj[property];
  return arrayOfObjects.reduce((table, obj) => {
    table[keyGetter(obj)] = transformer ? transformer(obj) : obj;
    return table;
  }, {});
};

exports.toSet = (arrayOfObjects, property) => {
  if (!arrayOfObjects) return new Set();
  const valueGetter = typeof property === "function" ? property : obj => obj[property];
  const result = new Set();
  arrayOfObjects.forEach(obj => result.add(valueGetter(obj)));
  return result;
};

const mapKeysDeep = (object, mapping, keepUnmapped) => {
  if (typeof mapping === "string") return {
    [mapping]: object
  };
  let newObj = {};

  _.forOwn(object, (v, k) => {
    if (k in mapping) {
      let nk = mapping[k];

      if (Array.isArray(nk)) {
        newObj[nk[0]] = { ...newObj[nk[0]],
          ...mapKeysDeep(v, nk[1], keepUnmapped)
        };
      } else {
        newObj[nk] = v;
      }
    } else {
      if (keepUnmapped) {
        newObj[k] = v;
      }
    }
  });

  return newObj;
};

const mapArraysDeep = (arrayOfObjects, mapping, keepUnmapped) => _.map(arrayOfObjects, obj => mapKeysDeep(obj, mapping, keepUnmapped));

exports.mapKeysDeep = mapKeysDeep;
exports.mapArraysDeep = mapArraysDeep;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9Db252ZXJ0b3JzLmpzIl0sIm5hbWVzIjpbInZhbGlkYXRvciIsInJlcXVpcmUiLCJfIiwiZXhwb3J0cyIsInRvQm9vbGVhbiIsInZhbHVlIiwidG9TdHJpbmciLCJ0b1RleHQiLCJub1RyaW0iLCJ0cmltIiwidG9JbnQiLCJyYWRpeCIsImlzSW50ZWdlciIsInBhcnNlSW50IiwidG9GbG9hdCIsImlzRmluaXRlIiwianNvblRvQmFzZTY0Iiwib2JqIiwiQnVmZmVyIiwiZnJvbSIsIkpTT04iLCJzdHJpbmdpZnkiLCJiYXNlNjRUb0pzb24iLCJiYXNlNjQiLCJwYXJzZSIsInRvS1ZQYWlycyIsImFycmF5T2ZPYmplY3RzIiwicHJvcGVydHkiLCJ0cmFuc2Zvcm1lciIsImtleUdldHRlciIsInJlZHVjZSIsInRhYmxlIiwidG9TZXQiLCJTZXQiLCJ2YWx1ZUdldHRlciIsInJlc3VsdCIsImZvckVhY2giLCJhZGQiLCJtYXBLZXlzRGVlcCIsIm9iamVjdCIsIm1hcHBpbmciLCJrZWVwVW5tYXBwZWQiLCJuZXdPYmoiLCJmb3JPd24iLCJ2IiwiayIsIm5rIiwiQXJyYXkiLCJpc0FycmF5IiwibWFwQXJyYXlzRGVlcCIsIm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7QUFFQSxNQUFNQSxTQUFTLEdBQUdDLE9BQU8sQ0FBQyxXQUFELENBQXpCOztBQUNBLE1BQU07QUFBRUMsRUFBQUE7QUFBRixJQUFRRCxPQUFPLENBQUMsVUFBRCxDQUFyQjs7QUFFQUUsT0FBTyxDQUFDQyxTQUFSLEdBQXFCQyxLQUFELElBQVksT0FBT0EsS0FBUCxLQUFpQixTQUFqQixHQUE2QkEsS0FBN0IsR0FBcUNMLFNBQVMsQ0FBQ0ksU0FBVixDQUFvQkMsS0FBSyxDQUFDQyxRQUFOLEVBQXBCLEVBQXNDLElBQXRDLENBQXJFOztBQUVBSCxPQUFPLENBQUNJLE1BQVIsR0FBaUIsQ0FBQ0YsS0FBRCxFQUFRRyxNQUFSLEtBQW1CO0FBQ2hDLE1BQUlILEtBQUosRUFBVztBQUNQ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QU4sQ0FBY0YsRUFBZCxDQUFKLEVBQXVCO0FBQ25CSixRQUFBQSxNQUFNLENBQUNJLEVBQUUsQ0FBQyxDQUFELENBQUgsQ0FBTixHQUFnQixFQUFFLEdBQUdKLE1BQU0sQ0FBQ0ksRUFBRSxDQUFDLENBQUQsQ0FBSCxDQUFYO0FBQW9CLGFBQUdSLFdBQVcsQ0FBQ00sQ0FBRCxFQUFJRSxFQUFFLENBQUMsQ0FBRCxDQUFOLEVBQVdMLFlBQVg7QUFBbEMsU0FBaEI7QUFDSCxPQUZELE1BRU87QUFDSEMsUUFBQUEsTUFBTSxDQUFDSSxFQUFELENBQU4sR0FBYUYsQ0FBYjtBQUNIO0FBQ0osS0FQRCxNQU9PO0FBQ0gsVUFBSUgsWUFBSixFQUFrQjtBQUNkQyxRQUFBQSxNQUFNLENBQUNHLENBQUQsQ0FBTixHQUFZRCxDQUFaO0FBQ0g7QUFDSjtBQUNKLEdBYkQ7O0FBZUEsU0FBT0YsTUFBUDtBQUNILENBcEJEOztBQXNCQSxNQUFNTyxhQUFhLEdBQUcsQ0FBQ3ZCLGNBQUQsRUFBaUJjLE9BQWpCLEVBQTBCQyxZQUExQixLQUNsQnZDLENBQUMsQ0FBQ2dELEdBQUYsQ0FBTXhCLGNBQU4sRUFBdUJULEdBQUQsSUFBU3FCLFdBQVcsQ0FBQ3JCLEdBQUQsRUFBTXVCLE9BQU4sRUFBZUMsWUFBZixDQUExQyxDQURKOztBQUdBdEMsT0FBTyxDQUFDbUMsV0FBUixHQUFzQkEsV0FBdEI7QUFDQW5DLE9BQU8sQ0FBQzhDLGFBQVIsR0FBd0JBLGFBQXhCIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmNvbnN0IHZhbGlkYXRvciA9IHJlcXVpcmUoXCJ2YWxpZGF0b3JcIik7XG5jb25zdCB7IF8gfSA9IHJlcXVpcmUoXCJyay11dGlsc1wiKTtcblxuZXhwb3J0cy50b0Jvb2xlYW4gPSAodmFsdWUpID0+ICh0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiID8gdmFsdWUgOiB2YWxpZGF0b3IudG9Cb29sZWFuKHZhbHVlLnRvU3RyaW5nKCksIHRydWUpKTtcblxuZXhwb3J0cy50b1RleHQgPSAodmFsdWUsIG5vVHJpbSkgPT4ge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB2YWx1ZSA9IHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIiA/IHZhbHVlLnRvU3RyaW5nKCkgOiB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIG5vVHJpbSA/IHZhbHVlIDogdmFsdWUudHJpbSgpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbn07XG5cbmV4cG9ydHMudG9JbnQgPSAodmFsdWUsIHJhZGl4KSA9PiAoXy5pc0ludGVnZXIodmFsdWUpID8gdmFsdWUgOiBwYXJzZUludCh2YWx1ZSwgcmFkaXgpKTtcblxuZXhwb3J0cy50b0Zsb2F0ID0gKHZhbHVlKSA9PiAoXy5pc0Zpbml0ZSh2YWx1ZSkgPyB2YWx1ZSA6IHZhbGlkYXRvci50b0Zsb2F0KHZhbHVlKSk7XG5cbmV4cG9ydHMuanNvblRvQmFzZTY0ID0gKG9iaikgPT4gQnVmZmVyLmZyb20oSlNPTi5zdHJpbmdpZnkob2JqKSkudG9TdHJpbmcoXCJiYXNlNjRcIik7XG5cbmV4cG9ydHMuYmFzZTY0VG9Kc29uID0gKGJhc2U2NCkgPT4gSlNPTi5wYXJzZShCdWZmZXIuZnJvbShiYXNlNjQsIFwiYmFzZTY0XCIpLnRvU3RyaW5nKFwiYXNjaWlcIikpO1xuXG5leHBvcnRzLnRvS1ZQYWlycyA9IChhcnJheU9mT2JqZWN0cywgcHJvcGVydHksIHRyYW5zZm9ybWVyKSA9PiB7XG4gICAgY29uc3Qga2V5R2V0dGVyID0gdHlwZW9mIHByb3BlcnR5ID09PSBcImZ1bmN0aW9uXCIgPyBwcm9wZXJ0eSA6IChvYmopID0+IG9ialtwcm9wZXJ0eV07XG5cbiAgICByZXR1cm4gYXJyYXlPZk9iamVjdHMucmVkdWNlKCh0YWJsZSwgb2JqKSA9PiB7XG4gICAgICAgIHRhYmxlW2tleUdldHRlcihvYmopXSA9IHRyYW5zZm9ybWVyID8gdHJhbnNmb3JtZXIob2JqKSA6IG9iajtcbiAgICAgICAgcmV0dXJuIHRhYmxlO1xuICAgIH0sIHt9KTtcbn07XG5cbmV4cG9ydHMudG9TZXQgPSAoYXJyYXlPZk9iamVjdHMsIHByb3BlcnR5KSA9PiB7XG4gICAgaWYgKCFhcnJheU9mT2JqZWN0cykgcmV0dXJuIG5ldyBTZXQoKTtcblxuICAgIGNvbnN0IHZhbHVlR2V0dGVyID0gdHlwZW9mIHByb3BlcnR5ID09PSBcImZ1bmN0aW9uXCIgPyBwcm9wZXJ0eSA6IChvYmopID0+IG9ialtwcm9wZXJ0eV07XG4gICAgY29uc3QgcmVzdWx0ICA9IG5ldyBTZXQoKTtcblxuICAgIGFycmF5T2ZPYmplY3RzLmZvckVhY2gob2JqID0+IHJlc3VsdC5hZGQodmFsdWVHZXR0ZXIob2JqKSkpO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBSZW1hcCB0aGUga2V5cyBvZiBvYmplY3QgZWxlbWVudHMgaW4gYW4gYXJyYXksIGxpa2UgcHJvamVjdGlvbi5cbiAqIEBwYXJhbSB7Kn0gb2JqZWN0XG4gKiBAcGFyYW0geyp9IG1hcHBpbmcgLSBrZXkgdG8gbmV3S2V5IG9yIGtleSB0byBhcnJheVsgbmV3S2V5LCB2YWx1ZU1hcCBdIGZvciBuZXh0IGxldmVsIG1hcHBpbmdcbiAqIEBwYXJhbSB7Ym9vbGVhbn0ga2VlcFVubWFwcGVkIC0gSWYgdHJ1ZSwgd2lsbCBrZWVwIHRob3NlIG5vdCBpbiBtYXBwaW5nIGFzIGl0cyBvcmlnaW5hbCBrZXksIG90aGVyd2lzZSBmaWx0ZXIgb3V0XG4gKi9cbmNvbnN0IG1hcEtleXNEZWVwID0gKG9iamVjdCwgbWFwcGluZywga2VlcFVubWFwcGVkKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBtYXBwaW5nID09PSBcInN0cmluZ1wiKSByZXR1cm4geyBbbWFwcGluZ106IG9iamVjdCB9O1xuXG4gICAgbGV0IG5ld09iaiA9IHt9O1xuICAgIF8uZm9yT3duKG9iamVjdCwgKHYsIGspID0+IHtcbiAgICAgICAgaWYgKGsgaW4gbWFwcGluZykge1xuICAgICAgICAgICAgbGV0IG5rID0gbWFwcGluZ1trXTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG5rKSkge1xuICAgICAgICAgICAgICAgIG5ld09ialtua1swXV0gPSB7IC4uLm5ld09ialtua1swXV0sIC4uLm1hcEtleXNEZWVwKHYsIG5rWzFdLCBrZWVwVW5tYXBwZWQpIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld09ialtua10gPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGtlZXBVbm1hcHBlZCkge1xuICAgICAgICAgICAgICAgIG5ld09ialtrXSA9IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBuZXdPYmo7XG59O1xuXG5jb25zdCBtYXBBcnJheXNEZWVwID0gKGFycmF5T2ZPYmplY3RzLCBtYXBwaW5nLCBrZWVwVW5tYXBwZWQpID0+XG4gICAgXy5tYXAoYXJyYXlPZk9iamVjdHMsIChvYmopID0+IG1hcEtleXNEZWVwKG9iaiwgbWFwcGluZywga2VlcFVubWFwcGVkKSk7XG5cbmV4cG9ydHMubWFwS2V5c0RlZXAgPSBtYXBLZXlzRGVlcDtcbmV4cG9ydHMubWFwQXJyYXlzRGVlcCA9IG1hcEFycmF5c0RlZXA7XG4iXX0=