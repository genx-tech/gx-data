{"version":3,"file":"EntityModel.js","names":["HttpCode","UnexpectedState","ValidationError","DatabaseError","InvalidArgument","require","_","eachAsync_","Generators","Convertors","Types","Features","Rules","isNothing","hasValueIn","JES","NEED_OVERRIDE","minifyAssocs","assocs","sorted","uniq","sort","reverse","minified","take","l","length","i","k","find","a","startsWith","push","oorTypesToBypass","Set","EntityModel","constructor","rawData","Object","assign","valueOfKey","data","meta","keyField","feildMeta","args","fieldSchema","name","extra","fields","schema","omit","$addEnumValues","$orAsArray","others","arrayElem","type","ENUM","values","concat","elementSchema","inputSchema","inputSetName","options","key","JSON","stringify","_cachedSchema","cache","schemaGenerator","db","assocFrom","extraArray","result","forEach","keyPath","keyNodes","split","assoc","slice","map","p","substring","join","add","Array","from","getUniqueKeyFieldsFrom","uniqueKeys","every","f","isNil","getUniqueKeyValuePairsFrom","ukFields","pick","getNestedObject","entityObj","defaultValue","nodes","isArray","get","ensureFields_","connOpts","field","has","uk","isEmpty","findOptions","$query","$association","findOne_","ensureRetrieveCreated","context","customOptions","$retrieveCreated","ensureRetrieveUpdated","$retrieveUpdated","ensureRetrieveDeleted","$retrieveDeleted","ensureTransaction_","connOptions","connection","connector","beginTransaction_","getValueFromContext","cached_","associations","combinedKey","cachedData","_cachedData","findAll_","$toDictionary","toDictionary","entityCollection","transformer","toKVPairs","aggregate_","pipeline","_pipeline","q","_prepareQueries","rawOptions","op","applyRules_","RULE_BEFORE_FIND","_safeExecute_","records","find_","$retrieveDbResult","$result","$relationships","$skipOrm","undefined","_mapRecordsToObjects","$nestedKeyGetter","log","entity","$transformer","evaluate","totalCount","rows","$totalCount","afterFindAll_","row","ret","totalItems","items","$offset","offset","$limit","limit","retryCreateOnDuplicate_","dataGenerator_","maxRery","createOptions","counter","errorRet","create_","error","code","raw","references","_extractAssociations","beforeCreate_","return","success","_populateReferences_","needCreateAssocs","_createAssocs_","_prepareEntityData_","RULE_BEFORE_CREATE","_internalBeforeCreate_","$dryRun","$upsert","dataForUpdating","latest","keys","upsertOne_","_fillResult","insertId","affectedRows","_internalAfterCreate_","queryKey","RULE_AFTER_CREATE","afterCreate_","updateOne_","updateOptions","_update_","updateMany_","forSingleRecord","conditionFields","toUpdate","beforeUpdate_","beforeUpdateMany_","needUpdateAssocs","doneUpdateAssocs","_updateAssocs_","RULE_BEFORE_UPDATE","_internalBeforeUpdate_","_internalBeforeUpdateMany_","otherOptions","update_","_internalAfterUpdate_","_internalAfterUpdateMany_","RULE_AFTER_UPDATE","afterUpdate_","afterUpdateMany_","replaceOne_","_doReplaceOne_","deleteOne_","deleteOptions","_delete_","deleteMany_","deleteAll_","$deleteAll","toDelete","beforeDelete_","beforeDeleteMany_","deletedCount","RULE_BEFORE_DELETE","_internalBeforeDelete_","_internalBeforeDeleteMany_","delete_","_internalAfterDelete_","_internalAfterDeleteMany_","RULE_AFTER_DELETE","afterDelete_","afterDeleteMany_","_containsUniqueKey","hasKeyNameOnly","hasNotNullKey","hasKeys","_ensureContainsUniqueKey","condition","containsUniqueKeyAndValue","containsUniqueKeyOnly","isUpdating","i18n","existing","$existing","opOptions","_dependsOnExistingData","$retrieveExisting","RULE_BEFORE_VALIDATION","fieldInfo","fieldName","value","useRaw","readOnly","$migration","$bypassReadOnly","freezeAfterNonDefault","Error","default","optional","isPlainObject","oorType","sanitize","stack","forceUpdate","updateByDb","hasActivator","auto","createByDb","_translateValue","$variables","RULE_AFTER_VALIDATION","$skipModifiers","applyModifiers_","mapValues","$requireSplitColumns","_serializeByTypeInfo","executor","bind","commit_","message","latestData","rollback_","_dependencyChanged","fieldDependencies","deps","d","reference","hasIn","_referenceExist","input","ref","pos","indexOf","substr","hasDepends","nullDepends","dep","whenNull","atLeastOneNotNull","features","_hasReservedKeys","obj","v","keyFields","normalizedOptions","$key","query","forOwn","$bypassEnsureUnique","$groupBy","having","$projection","_prepareAssociations","inputKeyField","_translateSymbolToken","info","variables","skipTypeCast","arrayToInOperator","session","errArgs","missingMessage","missingStatus","BAD_REQUEST","$in","typeCast","module","exports"],"sources":["../src/EntityModel.js"],"sourcesContent":["const { HttpCode, UnexpectedState, ValidationError, DatabaseError, InvalidArgument } = require('@genx/error');\nconst { _, eachAsync_ } = require('@genx/july');\nconst Generators = require('./Generators');\nconst Convertors = require('./Convertors');\nconst Types = require('./types');\nconst Features = require('./entityFeatures');\nconst Rules = require('./enum/Rules');\n\nconst { isNothing, hasValueIn } = require('./utils/lang');\nconst JES = require('@genx/jes');\n\nconst NEED_OVERRIDE = 'Should be overrided by driver-specific subclass.';\n\nfunction minifyAssocs(assocs) {\n    const sorted = _.uniq(assocs).sort().reverse();\n\n    const minified = _.take(sorted, 1);\n    const l = sorted.length - 1;\n\n    for (let i = 1; i < l; i++) {\n        const k = sorted[i] + '.';\n\n        if (!_.find(minified, (a) => a.startsWith(k))) {\n            minified.push(sorted[i]);\n        }\n    }\n\n    return minified;\n}\n\nconst oorTypesToBypass = new Set([\n    'ColumnReference',\n    'Function',\n    'BinaryExpression',\n    'DataSet',\n    'SQL',\n]);\n\n/**\n * Base entity model class.\n * @class\n */\nclass EntityModel {\n    /**\n     * @param {Object} [rawData] - Raw data object\n     */\n    constructor(rawData) {\n        if (rawData) {\n            // only pick those that are fields of this entity\n            Object.assign(this, rawData);\n        }\n    }\n\n    static valueOfKey(data) {\n        return data[this.meta.keyField];\n    }\n\n    // alias of fieldSchema, backward compatible with v1\n    static feildMeta(...args) {\n        return this.fieldSchema(...args);\n    }\n\n    /**\n     * Get a field schema based on the metadata of the field.\n     * @param {string} name - Field name\n     * @param {object} [extra] - Extra schema options\n     * @return {object|array} Schema object\n     */\n    static fieldSchema(name, extra) {\n        const meta = this.meta.fields[name];\n        if (!meta) {\n            throw new InvalidArgument(\n                `Unknown field \"${name}\" of entity \"${this.meta.name}\".`\n            );\n        }\n\n        const schema = _.omit(meta, ['default', 'optional']);        \n\n        if (extra) {\n            const { $addEnumValues, $orAsArray, ...others } = extra;\n            let arrayElem = schema;\n\n            if ($orAsArray) {\n                arrayElem = { ...schema, ...others };\n            }\n\n            if (meta.type === Types.ENUM.name && $addEnumValues) {\n                schema.values = schema.values.concat($addEnumValues);\n            } \n\n            Object.assign(schema, others);                  \n\n            if ($orAsArray) {\n                return [\n                    schema,\n                    {\n                        type: 'array',\n                        elementSchema: arrayElem,\n                    },\n                ];\n            }    \n        }          \n\n        return schema;\n    }\n\n    /**\n     * Get a map of fields schema by predefined input set.\n     * @param {string} inputSetName - Input set name, predefined in geml\n     * @param {object} [options] - Input set options\n     * @return {object} Schema object\n     */\n    static inputSchema(inputSetName, options) {\n        const key =\n            inputSetName + (options == null ? '{}' : JSON.stringify(options));\n\n        if (this._cachedSchema) {\n            const cache = this._cachedSchema[key];\n            if (cache) {\n                return cache;\n            }\n        } else {\n            this._cachedSchema = {};\n        }\n\n        const schemaGenerator = this.db.require(\n            `inputs/${this.meta.name}-${inputSetName}`\n        );\n\n        return (this._cachedSchema[key] = schemaGenerator(options));\n    }\n\n    /**\n     * Helper to combine explicit required associations and associations required by query fields or projection fields.\n     * @param {*} extraArray \n     * @param {*} fields \n     * @returns {Array}\n     */\n    static assocFrom(extraArray, fields) {\n        const result = new Set(extraArray);       \n\n        if (fields) {\n            fields.forEach(keyPath => {\n                const keyNodes = keyPath.split('.');\n                if (keyNodes.length > 1) {\n                    const assoc = keyNodes.slice(0, -1).map(p => p.startsWith(\":\") ? p.substring(1) : p).join('.');\n                    result.add(assoc);\n                }\n            })\n        }\n\n        return Array.from(result);\n    }\n\n    /**\n     * Get field names array of a unique key from input data.\n     * @param {object} data - Input data.\n     */\n    static getUniqueKeyFieldsFrom(data) {\n        return _.find(this.meta.uniqueKeys, (fields) =>\n            _.every(fields, (f) => !_.isNil(data[f]))\n        );\n    }\n\n    /**\n     * Get key-value pairs of a unique key from input data.\n     * @param {object} data - Input data.\n     */\n    static getUniqueKeyValuePairsFrom(data) {\n        const ukFields = this.getUniqueKeyFieldsFrom(data);\n        return _.pick(data, ukFields);\n    }\n\n    /**\n     * Get nested object of an entity.\n     * @param {*} entityObj\n     * @param {*} keyPath\n     */\n    static getNestedObject(entityObj, keyPath, defaultValue) {\n        const nodes = (\n            Array.isArray(keyPath) ? keyPath : keyPath.split('.')\n        ).map((key) => (key[0] === ':' ? key : ':' + key));\n        return _.get(entityObj, nodes, defaultValue);\n    }\n\n    /**\n     * Ensure the entity object containing required fields, if not, it will automatically fetched from db and return.\n     * @param {*} entityObj \n     * @param {Array} fields \n     * @param {*} connOpts \n     * @returns {Object}\n     */\n    static async ensureFields_(entityObj, fields, connOpts) {\n        if (_.find(fields, field => !_.has(entityObj, field))) {\n            const uk = this.getUniqueKeyValuePairsFrom(entityObj);\n\n            if (_.isEmpty(uk)) {\n                throw new UnexpectedState('None of the unique keys found from the data set.');\n            }\n\n            const findOptions = { $query: uk, /* $projection: fields,*/ $association: this.assocFrom(null, fields) };\n\n            return this.findOne_(findOptions, connOpts)\n        }\n\n        return entityObj;\n    }\n\n    /**\n     * Ensure context.latest be the just created entity.\n     * @param {*} context\n     * @param {*} customOptions\n     */\n    static ensureRetrieveCreated(context, customOptions) {\n        if (!context.options.$retrieveCreated) {\n            context.options.$retrieveCreated = customOptions || true;\n        }\n    }\n\n    /**\n     * Ensure context.latest be the just updated entity.\n     * @param {*} context\n     * @param {*} customOptions\n     */\n    static ensureRetrieveUpdated(context, customOptions) {\n        if (!context.options.$retrieveUpdated) {\n            context.options.$retrieveUpdated = customOptions || true;\n        }\n    }\n\n    /**\n     * Ensure context.exisintg be the just deleted entity.\n     * @param {*} context\n     * @param {*} customOptions\n     */\n    static ensureRetrieveDeleted(context, customOptions) {\n        if (!context.options.$retrieveDeleted) {\n            context.options.$retrieveDeleted = customOptions || true;\n        }\n    }\n\n    /**\n     * Ensure the upcoming operations are executed in a transaction.\n     * @param {*} context\n     */\n    static async ensureTransaction_(context) {\n        if (!context.connOptions || !context.connOptions.connection) {\n            context.connOptions || (context.connOptions = {});\n\n            context.connOptions.connection =\n                await this.db.connector.beginTransaction_();\n        }\n    }\n\n    /**\n     * Get value from context, e.g. session, query ...\n     * @param {*} context\n     * @param {string} key\n     * @returns {*}\n     */\n    static getValueFromContext(context, key) {\n        return _.get(context, 'options.$variables.' + key);\n    }\n\n    /**\n     * Get a pk-indexed hashtable with all undeleted data\n     * {string} [key] - The key field to used by the hashtable.\n     * {array} [associations] - With an array of associations.\n     * {object} [connOptions] - Connection options, e.g. transaction handle\n     */\n    static async cached_(key, associations, connOptions) {\n        if (key) {\n            let combinedKey = key;\n\n            if (!_.isEmpty(associations)) {\n                combinedKey += '/' + minifyAssocs(associations).join('&');\n            }\n\n            let cachedData;\n\n            if (!this._cachedData) {\n                this._cachedData = {};\n            } else if (this._cachedData[combinedKey]) {\n                cachedData = this._cachedData[combinedKey];\n            }\n\n            if (!cachedData) {\n                cachedData = this._cachedData[combinedKey] =\n                    await this.findAll_(\n                        { $association: associations, $toDictionary: key },\n                        connOptions\n                    );\n            }\n\n            return cachedData;\n        }\n\n        return this.cached_(this.meta.keyField, associations, connOptions);\n    }\n\n    static toDictionary(entityCollection, key, transformer) {\n        key || (key = this.meta.keyField);\n\n        return Convertors.toKVPairs(entityCollection, key, transformer);\n    }\n\n    /**\n     * Run aggregate pipeline\n     * @param {array} pipeline\n     * @param {object} [connOptions]\n     * @returns {*}\n     */\n     static async aggregate_(pipeline, connOptions) {\n        const _pipeline = pipeline.map(q => this._prepareQueries(q));\n\n        return this.db.connector.aggregate_(\n            this.meta.name,\n            _pipeline,\n            connOptions\n        );\n    }\n\n    /**\n     * Find one record, returns a model object containing the record or undefined if nothing found.     \n     * @param {object} [findOptions] - findOptions\n     * @property {object} [findOptions.$association] - Joinings\n     * @property {object} [findOptions.$projection] - Selected fields\n     * @property {object} [findOptions.$transformer] - Transform fields before returning\n     * @property {object} [findOptions.$query] - Extra condition\n     * @property {object} [findOptions.$groupBy] - Group by fields\n     * @property {object} [findOptions.$orderBy] - Order by fields\n     * @property {number} [findOptions.$offset] - Offset\n     * @property {number} [findOptions.$limit] - Limit\n     * @property {bool} [findOptions.$includeDeleted=false] - Include those marked as logical deleted.\n     * @param {object} [connOptions]\n     * @property {object} [connOptions.connection]\n     * @returns {*}\n     */\n    static async findOne_(findOptions, connOptions) {\n        const rawOptions = findOptions;\n\n        findOptions = this._prepareQueries(\n            findOptions,\n            true /* for single record */\n        );\n\n        const context = {\n            op: 'find',\n            options: findOptions,\n            connOptions,\n        };\n\n        await Features.applyRules_(Rules.RULE_BEFORE_FIND, this, context);\n\n        const result = await this._safeExecute_(async (context) => {\n            let records = await this.db.connector.find_(\n                this.meta.name,\n                context.options,\n                context.connOptions\n            );\n            if (!records)\n                throw new DatabaseError(\n                    'connector.find_() returns undefined data record.'\n                );\n\n            if (rawOptions && rawOptions.$retrieveDbResult) {\n                rawOptions.$result = records.slice(1);\n            }\n\n            if (findOptions.$relationships && !findOptions.$skipOrm) {\n                // rows, coloumns, aliasMap\n                if (records[0].length === 0) return undefined;\n\n                records = this._mapRecordsToObjects(\n                    records,\n                    findOptions.$relationships,\n                    findOptions.$nestedKeyGetter\n                );\n            } else if (records.length === 0) {\n                return undefined;\n            }\n\n            if (records.length !== 1) {\n                this.db.connector.log(\n                    'error',\n                    `findOne() returns more than one record.`,\n                    { entity: this.meta.name, options: context.options }\n                );\n            }\n\n            const result = records[0];\n\n            return result;\n        }, context);\n\n        if (findOptions.$transformer) {\n            return JES.evaluate(result, findOptions.$transformer);\n        }\n\n        return result;\n    }\n\n    /**\n     * Find records matching the condition, returns an array of records.\n     * @param {object} [findOptions] - findOptions\n     * @property {object} [findOptions.$association] - Joinings\n     * @property {object} [findOptions.$projection] - Selected fields\n     * @property {object} [findOptions.$transformer] - Transform fields before returning\n     * @property {object} [findOptions.$query] - Extra condition\n     * @property {object} [findOptions.$groupBy] - Group by fields\n     * @property {object} [findOptions.$orderBy] - Order by fields\n     * @property {number} [findOptions.$offset] - Offset\n     * @property {number} [findOptions.$limit] - Limit\n     * @property {number} [findOptions.$totalCount] - Return totalCount\n     * @property {bool} [findOptions.$includeDeleted=false] - Include those marked as logical deleted.\n     * @param {object} [connOptions]\n     * @property {object} [connOptions.connection]\n     * @returns {array}\n     */\n    static async findAll_(findOptions, connOptions) {\n        const rawOptions = findOptions;\n\n        findOptions = this._prepareQueries(findOptions);\n\n        const context = {\n            op: 'find',\n            options: findOptions,\n            connOptions,\n        };\n\n        await Features.applyRules_(Rules.RULE_BEFORE_FIND, this, context);\n\n        let totalCount;\n\n        let rows = await this._safeExecute_(async (context) => {\n            let records = await this.db.connector.find_(\n                this.meta.name,\n                context.options,\n                context.connOptions\n            );\n\n            if (!records)\n                throw new DatabaseError(\n                    'connector.find_() returns undefined data record.'\n                );\n\n            if (rawOptions && rawOptions.$retrieveDbResult) {\n                rawOptions.$result = records.slice(1);\n            }\n\n            if (findOptions.$relationships) {\n                if (findOptions.$totalCount) {\n                    totalCount = records[3];\n                }\n\n                if (!findOptions.$skipOrm) {\n                    records = this._mapRecordsToObjects(\n                        records,\n                        findOptions.$relationships,\n                        findOptions.$nestedKeyGetter\n                    );\n                } else {\n                    records = records[0];\n                }\n            } else {\n                if (findOptions.$totalCount) {\n                    totalCount = records[1];\n                    records = records[0];\n                } else if (findOptions.$skipOrm) {\n                    records = records[0];\n                }\n            }\n\n            return this.afterFindAll_(context, records);\n        }, context);\n\n        if (findOptions.$transformer) {\n            rows = rows.map((row) =>\n                JES.evaluate(row, findOptions.$transformer)\n            );\n        }\n\n        if (findOptions.$totalCount) {\n            const ret = { totalItems: totalCount, items: rows };\n\n            if (!isNothing(findOptions.$offset)) {\n                ret.offset = findOptions.$offset;\n            }\n\n            if (!isNothing(findOptions.$limit)) {\n                ret.limit = findOptions.$limit;\n            }\n\n            return ret;\n        }\n\n        return rows;\n    }\n\n    /**\n     * Regenerate creation data and try again if duplicate record exists\n     * @param {Function} dataGenerator_\n     * @param {Object} connOptions\n     */\n    static async retryCreateOnDuplicate_(\n        dataGenerator_,\n        maxRery,\n        createOptions,\n        connOptions\n    ) {\n        let counter = 0;\n        let errorRet;\n        maxRery || (maxRery = 10);\n\n        while (counter++ < maxRery) {\n            const data = await dataGenerator_();\n\n            try {\n                return await this.create_(data, createOptions, connOptions);\n            } catch (error) {\n                if (error.code !== 'E_DUPLICATE') {\n                    throw error;\n                }\n\n                errorRet = error;\n            }\n        }\n\n        return errorRet;\n    }\n\n    /**\n     * Create a new entity with given data.\n     * @param {object} data - Entity data\n     * @param {object} [createOptions] - Create options\n     * @property {bool} [createOptions.$retrieveCreated=false] - Retrieve the newly created record from db.\n     * @property {bool} [createOptions.$upsert=false] - If already exist, just update the record.\n     * @param {object} [connOptions]\n     * @property {object} [connOptions.connection]\n     * @returns {EntityModel}\n     */\n    static async create_(data, createOptions, connOptions) {\n        const rawOptions = createOptions;\n\n        if (!createOptions) {\n            createOptions = {};\n        }\n\n        let [raw, associations, references] = this._extractAssociations(\n            data,\n            true\n        );\n\n        const context = {\n            op: 'create',\n            raw,\n            rawOptions,\n            options: createOptions,\n            connOptions,\n        };\n\n        if (!(await this.beforeCreate_(context))) {\n            return context.return;\n        }\n\n        const success = await this._safeExecute_(async (context) => {\n            if (!_.isEmpty(references)) {\n                await this.ensureTransaction_(context);\n                await this._populateReferences_(context, references);\n            }\n\n            let needCreateAssocs = !_.isEmpty(associations);\n            if (needCreateAssocs) {\n                await this.ensureTransaction_(context);\n\n                associations = await this._createAssocs_(\n                    context,\n                    associations,\n                    true /* before create */\n                );\n                // check any other associations left\n                needCreateAssocs = !_.isEmpty(associations);\n            }\n\n            await this._prepareEntityData_(context);\n\n            if (\n                !(await Features.applyRules_(\n                    Rules.RULE_BEFORE_CREATE,\n                    this,\n                    context\n                ))\n            ) {\n                return false;\n            }\n\n            if (!(await this._internalBeforeCreate_(context))) {\n                return false;\n            }\n\n            if (!context.options.$dryRun) {\n                if (context.options.$upsert) {\n                    const dataForUpdating = _.pick(context.latest, Object.keys(context.raw)); // only update the raw part    \n\n                    context.result = await this.db.connector.upsertOne_(\n                        this.meta.name,\n                        dataForUpdating,\n                        this.getUniqueKeyFieldsFrom(context.latest),\n                        context.connOptions,\n                        context.latest\n                    );                    \n                } else {\n                    context.result = await this.db.connector.create_(\n                        this.meta.name,\n                        context.latest,\n                        context.connOptions\n                    );\n                }\n\n                this._fillResult(context);\n            } else {\n                context.return = context.latest;\n                context.result = { insertId: context.latest[this.meta.keyField], affectedRows: 1 };\n            }\n\n            if (needCreateAssocs) {\n                await this._createAssocs_(context, associations);\n            }\n\n            await this._internalAfterCreate_(context);\n\n            if (!context.queryKey) {\n                context.queryKey = this.getUniqueKeyValuePairsFrom(\n                    context.latest\n                );\n            }\n\n            await Features.applyRules_(Rules.RULE_AFTER_CREATE, this, context);\n\n            return true;\n        }, context);\n\n        if (success && !context.options.$dryRun) {\n            await this.afterCreate_(context);\n        }\n\n        return context.return;\n    }\n\n    /**\n     * Update an existing entity with given data.\n     * @param {object} data - Entity data with at least one unique key (pair) given\n     * @param {object} [updateOptions] - Update options\n     * @property {object} [updateOptions.$query] - Extra condition\n     * @property {bool} [updateOptions.$retrieveUpdated=false] - Retrieve the updated entity from database\n     * @param {object} [connOptions]\n     * @property {object} [connOptions.connection]\n     * @returns {object}\n     */\n    static async updateOne_(data, updateOptions, connOptions) {\n        return this._update_(data, updateOptions, connOptions, true);\n    }\n\n    /**\n     * Update many existing entites with given data.\n     * @param {*} data\n     * @param {*} updateOptions\n     * @param {*} connOptions\n     */\n    static async updateMany_(data, updateOptions, connOptions) {\n        return this._update_(data, updateOptions, connOptions, false);\n    }\n\n    static async _update_(data, updateOptions, connOptions, forSingleRecord) {\n        const rawOptions = updateOptions;\n\n        if (!updateOptions) {\n            // if no condition given, extract from data\n            const conditionFields = this.getUniqueKeyFieldsFrom(data);\n            if (_.isEmpty(conditionFields)) {\n                throw new InvalidArgument(\n                    'Primary key value(s) or at least one group of unique key value(s) is required for updating an entity.',\n                    {\n                        entity: this.meta.name,\n                        data,\n                    }\n                );\n            }\n            updateOptions = { $query: _.pick(data, conditionFields) };\n            data = _.omit(data, conditionFields);\n        }\n\n        // see if there is associated entity data provided together\n        let [raw, associations, references] = this._extractAssociations(data);\n\n        const context = {\n            op: 'update',\n            raw,\n            rawOptions,\n            options: this._prepareQueries(\n                updateOptions,\n                forSingleRecord /* for single record */\n            ),\n            connOptions,\n            forSingleRecord,\n        };\n\n        // see if there is any runtime feature stopping the update\n        let toUpdate;\n\n        if (forSingleRecord) {\n            toUpdate = await this.beforeUpdate_(context);\n        } else {\n            toUpdate = await this.beforeUpdateMany_(context);\n        }\n\n        if (!toUpdate) {\n            return context.return;\n        }\n\n        const success = await this._safeExecute_(async (context) => {\n            if (!_.isEmpty(references)) {\n                await this.ensureTransaction_(context);\n                await this._populateReferences_(context, references);\n            }\n\n            let needUpdateAssocs = !_.isEmpty(associations);\n            let doneUpdateAssocs;\n\n            if (needUpdateAssocs) {\n                await this.ensureTransaction_(context);\n\n                associations = await this._updateAssocs_(\n                    context,\n                    associations,\n                    true /* before update */,\n                    forSingleRecord\n                );\n                needUpdateAssocs = !_.isEmpty(associations);\n                doneUpdateAssocs = true;\n            }\n\n            await this._prepareEntityData_(\n                context,\n                true /* is updating */,\n                forSingleRecord\n            );\n\n            if (\n                !(await Features.applyRules_(\n                    Rules.RULE_BEFORE_UPDATE,\n                    this,\n                    context\n                ))\n            ) {\n                return false;\n            }\n\n            if (forSingleRecord) {\n                toUpdate = await this._internalBeforeUpdate_(context);\n            } else {\n                toUpdate = await this._internalBeforeUpdateMany_(context);\n            }\n\n            if (!toUpdate) {\n                return false;\n            }\n\n            const { $query, ...otherOptions } = context.options;\n\n            if (_.isEmpty(context.latest)) {\n                if (!doneUpdateAssocs && !needUpdateAssocs) {\n                    throw new InvalidArgument(\n                        'Cannot do the update with empty record. Entity: ' +\n                            this.meta.name\n                    );\n                }\n            } else {\n                if (\n                    needUpdateAssocs &&\n                    !hasValueIn([$query, context.latest], this.meta.keyField) &&\n                    !otherOptions.$retrieveUpdated\n                ) {\n                    // has associated data depending on this record\n                    // should ensure the latest result will contain the key of this record\n                    otherOptions.$retrieveUpdated = true;\n                }\n\n                if (forSingleRecord && !otherOptions.$limit) {\n                    otherOptions.$limit = 1;\n                }\n\n                context.result = await this.db.connector.update_(\n                    this.meta.name,\n                    context.latest,\n                    $query,\n                    otherOptions,\n                    context.connOptions\n                );\n\n                context.return = context.latest;\n            }\n\n            if (forSingleRecord) {\n                await this._internalAfterUpdate_(context);\n\n                if (!context.queryKey) {\n                    context.queryKey = this.getUniqueKeyValuePairsFrom($query);\n                }\n            } else {\n                await this._internalAfterUpdateMany_(context);\n            }\n\n            await Features.applyRules_(Rules.RULE_AFTER_UPDATE, this, context);\n\n            if (needUpdateAssocs) {\n                await this._updateAssocs_(\n                    context,\n                    associations,\n                    false,\n                    forSingleRecord\n                );\n            }\n\n            return true;\n        }, context);\n\n        if (success && !context.options.$dryRun) {\n            if (forSingleRecord) {\n                await this.afterUpdate_(context);\n            } else {\n                await this.afterUpdateMany_(context);\n            }\n        }\n\n        return context.return;\n    }\n\n    /**\n     * Update an existing entity with given data, or create one if not found.\n     * @param {*} data\n     * @param {*} updateOptions\n     * @param {*} connOptions\n     */\n    static async replaceOne_(data, updateOptions, connOptions) {\n        const rawOptions = updateOptions;\n\n        if (!updateOptions) {\n            const conditionFields = this.getUniqueKeyFieldsFrom(data);\n            if (_.isEmpty(conditionFields)) {\n                throw new InvalidArgument(\n                    'Primary key value(s) or at least one group of unique key value(s) is required for replacing an entity.',\n                    {\n                        entity: this.meta.name,\n                        data,\n                    }\n                );\n            }\n\n            updateOptions = {\n                ...updateOptions,\n                $query: _.pick(data, conditionFields),\n            };\n        } else {\n            updateOptions = this._prepareQueries(updateOptions, true);\n        }\n\n        const context = {\n            op: 'replace',\n            raw: data,\n            rawOptions,\n            options: updateOptions,\n            connOptions,\n        };\n\n        return this._safeExecute_(async (context) => {\n            return this._doReplaceOne_(context); // different dbms has different replacing strategy\n        }, context);\n    }\n\n    /**\n     * Remove an existing entity with given data.\n     * @param {object} [deleteOptions] - Update options\n     * @property {object} [deleteOptions.$query] - Extra condition\n     * @property {bool} [deleteOptions.$retrieveDeleted=false] - Retrieve the deleted entity from database\n     * @property {bool} [deleteOptions.$physicalDeletion=false] - When $physicalDeletion = true, deletetion will not take into account logicaldeletion feature\n     * @param {object} [connOptions]\n     * @property {object} [connOptions.connection]\n     */\n    static async deleteOne_(deleteOptions, connOptions) {\n        return this._delete_(deleteOptions, connOptions, true);\n    }\n\n    /**\n     * Remove an existing entity with given data.\n     * @param {object} [deleteOptions] - Update options\n     * @property {object} [deleteOptions.$query] - Extra condition\n     * @property {bool} [deleteOptions.$retrieveDeleted=false] - Retrieve the deleted entity from database\n     * @property {bool} [deleteOptions.$physicalDeletion=false] - When $physicalDeletion = true, deletetion will not take into account logicaldeletion feature\n     * @property {bool} [deleteOptions.$deleteAll=false] - When $deleteAll = true, the operation will proceed even empty condition is given\n     * @param {object} [connOptions]\n     * @property {object} [connOptions.connection]\n     */\n    static async deleteMany_(deleteOptions, connOptions) {\n        return this._delete_(deleteOptions, connOptions, false);\n    }\n\n    static async deleteAll_(connOptions) {\n        return this.deleteMany_({ $deleteAll: true }, connOptions);\n    }\n\n    /**\n     * Remove an existing entity with given data.\n     * @param {object} [deleteOptions] - Update options\n     * @property {object} [deleteOptions.$query] - Extra condition\n     * @property {bool} [deleteOptions.$retrieveDeleted=false] - Retrieve the deleted entity from database\n     * @property {bool} [deleteOptions.$physicalDeletion=false] - When $physicalDeletion = true, deletetion will not take into account logicaldeletion feature\n     * @param {object} [connOptions]\n     * @property {object} [connOptions.connection]\n     */\n    static async _delete_(deleteOptions, connOptions, forSingleRecord) {\n        const rawOptions = deleteOptions;\n\n        deleteOptions = this._prepareQueries(\n            deleteOptions,\n            forSingleRecord /* for single record */\n        );\n\n        if (\n            _.isEmpty(deleteOptions.$query) &&\n            (forSingleRecord || !deleteOptions.$deleteAll)\n        ) {\n            throw new InvalidArgument(\n                'Empty condition is not allowed for deleting or add { $deleteAll: true } to delete all records.',\n                {\n                    entity: this.meta.name,\n                    deleteOptions,\n                }\n            );\n        }\n\n        const context = {\n            op: 'delete',\n            rawOptions,\n            options: deleteOptions,\n            connOptions,\n            forSingleRecord,\n        };\n\n        let toDelete;\n\n        if (forSingleRecord) {\n            toDelete = await this.beforeDelete_(context);\n        } else {\n            toDelete = await this.beforeDeleteMany_(context);\n        }\n\n        if (!toDelete) {\n            return context.return;\n        }\n\n        const deletedCount = await this._safeExecute_(async (context) => {\n            if (\n                !(await Features.applyRules_(\n                    Rules.RULE_BEFORE_DELETE,\n                    this,\n                    context\n                ))\n            ) {\n                return false;\n            }\n\n            if (forSingleRecord) {\n                toDelete = await this._internalBeforeDelete_(context);\n            } else {\n                toDelete = await this._internalBeforeDeleteMany_(context);\n            }\n\n            if (!toDelete) {\n                return false;\n            }\n\n            const { $query, ...otherOptions } = context.options;\n\n            context.result = await this.db.connector.delete_(\n                this.meta.name,\n                $query,\n                otherOptions,\n                context.connOptions\n            );\n\n            if (forSingleRecord) {\n                await this._internalAfterDelete_(context);\n            } else {\n                await this._internalAfterDeleteMany_(context);\n            }\n\n            if (!context.queryKey) {\n                if (forSingleRecord) {\n                    context.queryKey = this.getUniqueKeyValuePairsFrom(\n                        context.options.$query\n                    );\n                } else {\n                    context.queryKey = context.options.$query;\n                }\n            }\n\n            await Features.applyRules_(Rules.RULE_AFTER_DELETE, this, context);\n\n            return this.db.connector.deletedCount(context);\n        }, context);\n\n        if (deletedCount && !context.options.$dryRun) {\n            if (forSingleRecord) {\n                await this.afterDelete_(context);\n            } else {\n                await this.afterDeleteMany_(context);\n            }\n        }\n\n        return context.return || deletedCount;\n    }\n\n    /**\n     * Check whether a data record contains primary key or at least one unique key pair.\n     * @param {object} data\n     */\n    static _containsUniqueKey(data) {\n        let hasKeyNameOnly = false;\n\n        const hasNotNullKey = _.find(this.meta.uniqueKeys, (fields) => {\n            const hasKeys = _.every(fields, (f) => f in data);\n            hasKeyNameOnly = hasKeyNameOnly || hasKeys;\n\n            return _.every(fields, (f) => !_.isNil(data[f]));\n        });\n\n        return [hasNotNullKey, hasKeyNameOnly];\n    }\n\n    /**\n     * Ensure the condition contains one of the unique keys.\n     * @param {*} condition\n     */\n    static _ensureContainsUniqueKey(condition) {\n        const [containsUniqueKeyAndValue, containsUniqueKeyOnly] =\n            this._containsUniqueKey(condition);\n\n        if (!containsUniqueKeyAndValue) {\n            if (containsUniqueKeyOnly) {\n                throw new ValidationError(\n                    'One of the unique key field as query condition is null. Condition: ' +\n                        JSON.stringify(condition)\n                );\n            }\n\n            throw new InvalidArgument(\n                'Single record operation requires at least one unique key value pair in the query condition.',\n                {\n                    entity: this.meta.name,\n                    condition,\n                }\n            );\n        }\n    }\n\n    /**\n     * Prepare valid and sanitized entity data for sending to database.\n     * @param {object} context - Operation context.\n     * @property {object} context.raw - Raw input data.\n     * @property {object} [context.connOptions]\n     * @param {bool} isUpdating - Flag for updating existing entity.\n     */\n    static async _prepareEntityData_(\n        context,\n        isUpdating = false,\n        forSingleRecord = true\n    ) {\n        const meta = this.meta;\n        const i18n = this.i18n;\n        const { name, fields } = meta;\n\n        let { raw } = context;\n        let latest = {};\n        // returned by $retrieveExisting\n        let existing = context.options.$existing;\n        context.latest = latest;\n\n        if (!context.i18n) {\n            context.i18n = i18n;\n        }\n\n        const opOptions = context.options;\n\n        if (opOptions.$upsert && typeof opOptions.$upsert === 'object') {\n            raw = { ...raw, ...opOptions.$upsert };\n        }\n\n        if (\n            isUpdating &&\n            _.isEmpty(existing) &&\n            (this._dependsOnExistingData(raw) || opOptions.$retrieveExisting)\n        ) {\n            await this.ensureTransaction_(context);\n\n            if (forSingleRecord) {\n                existing = await this.findOne_(\n                    { $query: opOptions.$query },\n                    context.connOptions\n                );\n            } else {\n                existing = await this.findAll_(\n                    { $query: opOptions.$query },\n                    context.connOptions\n                );\n            }\n            context.existing = existing;\n        }\n\n        if (opOptions.$retrieveExisting && !context.rawOptions.$existing) {\n            context.rawOptions.$existing = existing;\n        }\n\n        await Features.applyRules_(Rules.RULE_BEFORE_VALIDATION, this, context);\n\n        await eachAsync_(fields, async (fieldInfo, fieldName) => {\n            let value;\n            let useRaw = false;\n\n            if (fieldName in raw) {\n                value = raw[fieldName];\n                useRaw = true;\n            } else if (fieldName in latest) {\n                value = latest[fieldName];\n            }\n\n            if (typeof value !== 'undefined') {\n                // field value given in raw data\n                if (fieldInfo.readOnly && useRaw) {\n                    if (\n                        !opOptions.$migration &&\n                        (!opOptions.$bypassReadOnly ||\n                        !opOptions.$bypassReadOnly.has(fieldName))\n                    ) {\n                        // read only, not allow to set by input value\n                        throw new ValidationError(\n                            `Read-only field \"${fieldName}\" is not allowed to be set by manual input.`,\n                            {\n                                entity: name,\n                                fieldInfo: fieldInfo,\n                            }\n                        );\n                    }\n                }\n\n                if (isUpdating && fieldInfo.freezeAfterNonDefault) {\n                    if (!existing) {\n                        throw new Error(\n                            '\"freezeAfterNonDefault\" qualifier requires existing data.'\n                        );\n                    }\n\n                    if (existing[fieldName] !== fieldInfo.default) {\n                        // freezeAfterNonDefault, not allow to change if value is non-default\n                        throw new ValidationError(\n                            `FreezeAfterNonDefault field \"${fieldName}\" is not allowed to be changed.`,\n                            {\n                                entity: name,\n                                fieldInfo: fieldInfo,\n                            }\n                        );\n                    }\n                }\n\n                /**  todo: fix dependency, check writeProtect \n                if (isUpdating && fieldInfo.writeOnce) {     \n                    assert: existing, '\"writeOnce\" qualifier requires existing data.';\n                    if (!_.isNil(existing[fieldName])) {\n                        throw new ValidationError(`Write-once field \"${fieldName}\" is not allowed to be update once it was set.`, {\n                            entity: name,\n                            fieldInfo: fieldInfo \n                        });\n                    }\n                } */\n\n                // sanitize first\n                if (isNothing(value)) {\n                    if (fieldInfo.default) {\n                        // has default setting in meta data\n                        latest[fieldName] = fieldInfo.default;\n                    } else if (!fieldInfo.optional) {\n                        throw new ValidationError(\n                            `The \"${fieldName}\" value of \"${name}\" entity cannot be null.`,\n                            {\n                                entity: name,\n                                fieldInfo: fieldInfo,\n                            }\n                        );\n                    } else {\n                        latest[fieldName] = null;\n                    }\n                } else {\n                    if (_.isPlainObject(value) && value.oorType) {\n                        latest[fieldName] = value;\n\n                        return;\n                    }\n\n                    try {\n                        latest[fieldName] = Types.sanitize(\n                            value,\n                            fieldInfo,\n                            i18n\n                        );\n                    } catch (error) {\n                        throw new ValidationError(\n                            `Invalid \"${fieldName}\" value of \"${name}\" entity.`,\n                            {\n                                entity: name,\n                                fieldInfo: fieldInfo,\n                                value,\n                                error: error.stack,\n                            }\n                        );\n                    }\n                }\n\n                return;\n            }\n\n            // not given in raw data\n            if (isUpdating) {\n                if (fieldInfo.forceUpdate) {\n                    // has force update policy, e.g. updateTimestamp\n                    if (fieldInfo.updateByDb || fieldInfo.hasActivator) {\n                        return;\n                    }\n\n                    // require generator to refresh auto generated value\n                    if (fieldInfo.auto) {                        \n                        latest[fieldName] = await Generators.default(\n                            fieldInfo,\n                            i18n\n                        );\n                        return;\n                    }\n\n                    throw new ValidationError(\n                        `Field \"${fieldName}\" of \"${name}\" entity is required for each update.`,\n                        {\n                            entity: name,\n                            fieldInfo: fieldInfo,\n                        }\n                    );\n                }\n\n                return;\n            }\n\n            // new record\n            if (!fieldInfo.createByDb) {\n                if ('default' in fieldInfo) {\n                    // has default setting in meta data\n                    latest[fieldName] = fieldInfo.default;\n                } else if (fieldInfo.optional) {\n                    // ignore\n                } else if (fieldInfo.auto) {\n                    // automatically generated\n                    latest[fieldName] = await Generators.default(\n                        fieldInfo,\n                        i18n\n                    );\n                } else if (!fieldInfo.hasActivator) {\n                    // skip those have activators\n\n                    throw new ValidationError(\n                        `Field \"${fieldName}\" of \"${name}\" entity is required.`,\n                        {\n                            entity: name,\n                            fieldInfo: fieldInfo,\n                            raw,\n                        }\n                    );\n                }\n            } // else default value set by database or by rules\n        });\n\n        latest = context.latest = this._translateValue(\n            latest,\n            opOptions.$variables,\n            true\n        );\n\n        await Features.applyRules_(Rules.RULE_AFTER_VALIDATION, this, context);\n\n        if (!opOptions.$skipModifiers) {\n            await this.applyModifiers_(context, isUpdating);\n        }\n\n        // final round process before entering database\n        context.latest = _.mapValues(latest, (value, key) => {\n            if (value == null) return value;\n\n            if (_.isPlainObject(value) && value.oorType) {\n                // there is special input column which maybe a function or an expression\n                opOptions.$requireSplitColumns = true;\n                return value;\n            }\n\n            const fieldInfo = fields[key];\n\n            return this._serializeByTypeInfo(value, fieldInfo);\n        });\n\n        return context;\n    }\n\n    /**\n     * Ensure commit or rollback is called if transaction is created within the executor.\n     * @param {*} executor\n     * @param {*} context\n     */\n    static async _safeExecute_(executor, context) {\n        executor = executor.bind(this);\n\n        if (context.connOptions && context.connOptions.connection) {\n            return executor(context);\n        }\n\n        try {\n            const result = await executor(context);\n\n            // if the executor have initiated a transaction\n            if (context.connOptions && context.connOptions.connection) {\n                await this.db.connector.commit_(context.connOptions.connection);\n                delete context.connOptions.connection;\n            }\n\n            return result;\n        } catch (error) {\n            // we have to rollback if error occurred in a transaction\n            if (context.connOptions && context.connOptions.connection) {\n                this.db.connector.log(\n                    'error',\n                    `Rollbacked, reason: ${error.message}`,\n                    {\n                        entity: this.meta.name,\n                        context: context.options,\n                        rawData: context.raw,\n                        latestData: context.latest,\n                    }\n                );\n                await this.db.connector.rollback_(\n                    context.connOptions.connection\n                );\n                delete context.connOptions.connection;\n            }\n\n            throw error;\n        }\n    }\n\n    static _dependencyChanged(fieldName, context) {\n        if (this.meta.fieldDependencies) {\n            const deps = this.meta.fieldDependencies[fieldName];\n\n            return _.find(deps, (d) =>\n                _.isPlainObject(d)\n                    ? (d.reference !== fieldName && _.hasIn(context, d.reference))\n                    : _.hasIn(context, d)\n            );\n        }\n        \n        return false;\n    }\n\n    static _referenceExist(input, ref) {\n        const pos = ref.indexOf('.');\n\n        if (pos > 0) {\n            return ref.substr(pos + 1) in input;\n        }\n\n        return ref in input;\n    }\n\n    static _dependsOnExistingData(input) {\n        // check modifier dependencies\n        const deps = this.meta.fieldDependencies;\n        let hasDepends = false;\n\n        if (deps) {\n            const nullDepends = new Set();\n\n            hasDepends = _.find(deps, (dep, fieldName) =>\n                _.find(dep, (d) => {\n                    if (_.isPlainObject(d)) {\n                        if (d.whenNull) {\n                            if (_.isNil(input[fieldName])) {\n                                nullDepends.add(dep);\n                            }\n\n                            return false;\n                        }\n\n                        if (d.reference === fieldName) return false;\n\n                        d = d.reference;\n                    }\n\n                    return (\n                        fieldName in input && !this._referenceExist(input, d)\n                    ) || (this._referenceExist(input, d) && !(fieldName in input));\n                })\n            );\n\n            if (hasDepends) {\n                return true;\n            }\n\n            for (const dep of nullDepends) {\n                if (\n                    _.find(\n                        dep,\n                        (d) => !this._referenceExist(input, d.reference)\n                    )\n                ) {\n                    return true;\n                }\n            }\n        }\n\n        // check by special rules\n        const atLeastOneNotNull = this.meta.features.atLeastOneNotNull;\n        if (atLeastOneNotNull) {\n            hasDepends = _.find(atLeastOneNotNull, (fields) =>\n                _.find(\n                    fields,\n                    (field) => field in input && _.isNil(input[field])\n                )\n            );\n            if (hasDepends) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    static _hasReservedKeys(obj) {\n        return _.find(obj, (v, k) => k[0] === '$');\n    }\n\n    /**\n     * Normalize options including moving entries with key not starting with '$' into $query, interpolating variables and building relationship structure.\n     * @param {object} options \n     * @param {boolean} [forSingleRecord=false]\n     * @returns {object}\n     */\n    static _prepareQueries(options, forSingleRecord = false) {\n        if (!_.isPlainObject(options)) {\n            if (forSingleRecord && Array.isArray(this.meta.keyField)) {\n                throw new InvalidArgument(\n                    'Cannot use a singular value as condition to query against an entity with combined primary key.',\n                    {\n                        entity: this.meta.name,\n                        keyFields: this.meta.keyField,\n                    }\n                );\n            }\n\n            return options\n                ? {\n                      $query: {\n                          [this.meta.keyField]: this._translateValue(options),\n                      },\n                  }\n                : {};\n        }\n\n        const normalizedOptions = { $key: this.meta.keyField };\n        const query = {};\n\n        _.forOwn(options, (v, k) => {\n            if (k[0] === '$') {\n                normalizedOptions[k] = v;\n            } else {\n                query[k] = v;\n            }\n        });\n\n        normalizedOptions.$query = { ...query, ...normalizedOptions.$query };\n\n        if (forSingleRecord && !options.$bypassEnsureUnique) {\n            this._ensureContainsUniqueKey(normalizedOptions.$query);\n        }\n\n        normalizedOptions.$query = this._translateValue(\n            normalizedOptions.$query,\n            normalizedOptions.$variables,\n            null,\n            true\n        );\n\n        if (normalizedOptions.$groupBy) {\n            if (_.isPlainObject(normalizedOptions.$groupBy)) {\n                if (normalizedOptions.$groupBy.having) {\n                    normalizedOptions.$groupBy.having = this._translateValue(\n                        normalizedOptions.$groupBy.having,\n                        normalizedOptions.$variables\n                    );\n                }\n            }\n        }\n\n        if (normalizedOptions.$projection) {\n            normalizedOptions.$projection = this._translateValue(\n                normalizedOptions.$projection,\n                normalizedOptions.$variables\n            );\n        }\n\n        if (\n            normalizedOptions.$association &&\n            !normalizedOptions.$relationships\n        ) {\n            normalizedOptions.$relationships =\n                this._prepareAssociations(normalizedOptions);\n        }\n\n        return normalizedOptions;\n    }\n\n    /**\n     * Pre create processing, return false to stop upcoming operation.\n     * @param {*} context\n     */\n    static async beforeCreate_(context) {\n        return true;\n    }\n\n    /**\n     * Pre update processing, return false to stop upcoming operation.\n     * @param {*} context\n     */\n    static async beforeUpdate_(context) {\n        return true;\n    }\n\n    /**\n     * Pre update processing, multiple records, return false to stop upcoming operation.\n     * @param {*} context\n     */\n    static async beforeUpdateMany_(context) {\n        return true;\n    }\n\n    /**\n     * Pre delete processing, return false to stop upcoming operation.\n     * @param {*} context\n     */\n    static async beforeDelete_(context) {\n        return true;\n    }\n\n    /**\n     * Pre delete processing, multiple records, return false to stop upcoming operation.\n     * @param {*} context\n     */\n    static async beforeDeleteMany_(context) {\n        return true;\n    }\n\n    /**\n     * Post create processing.\n     * @param {*} context\n     */\n    static async afterCreate_(context) {}\n\n    /**\n     * Post update processing.\n     * @param {*} context\n     */\n    static async afterUpdate_(context) {}\n\n    /**\n     * Post update processing, multiple records\n     * @param {*} context\n     */\n    static async afterUpdateMany_(context) {}\n\n    /**\n     * Post delete processing.\n     * @param {*} context\n     */\n    static async afterDelete_(context) {}\n\n    /**\n     * Post delete processing, multiple records\n     * @param {*} context\n     */\n    static async afterDeleteMany_(context) {}\n\n    /**\n     * Post findAll processing\n     * @param {*} context\n     * @param {*} records\n     */\n    static async afterFindAll_(context, records) {\n        if (context.options.$toDictionary) {\n            let keyField = this.meta.keyField;\n\n            if (typeof context.options.$toDictionary === 'string') {\n                keyField = context.options.$toDictionary;\n\n                if (!(keyField in this.meta.fields)) {\n                    throw new InvalidArgument(\n                        `The key field \"${keyField}\" provided to index the cached dictionary is not a field of entity \"${this.meta.name}\".`,\n                        {\n                            entity: this.meta.name,\n                            inputKeyField: keyField,\n                        }\n                    );\n                }\n            }\n\n            return this.toDictionary(records, keyField);\n        }\n\n        return records;\n    }\n\n    static _prepareAssociations() {\n        throw new Error(NEED_OVERRIDE);\n    }\n\n    static _mapRecordsToObjects() {\n        throw new Error(NEED_OVERRIDE);\n    }\n\n    static _extractAssociations(data) {\n        throw new Error(NEED_OVERRIDE);\n    }\n\n    // will update context.raw if applicable\n    static async _populateReferences_(context, references) {\n        throw new Error(NEED_OVERRIDE);\n    }\n\n    // will update context.raw if applicable\n    static async _createAssocs_(context, assocs) {\n        throw new Error(NEED_OVERRIDE);\n    }\n\n    static async _updateAssocs_(context, assocs) {\n        throw new Error(NEED_OVERRIDE);\n    }\n\n    static _translateSymbolToken(name) {\n        throw new Error(NEED_OVERRIDE);\n    }\n\n    static _serializeByTypeInfo(value, info) {\n        throw new Error(NEED_OVERRIDE);\n    }\n\n    static _translateValue(value, variables, skipTypeCast, arrayToInOperator) {\n        if (_.isPlainObject(value)) {\n            if (value.oorType) {\n                if (oorTypesToBypass.has(value.oorType)) return value;\n\n                if (value.oorType === 'SessionVariable') {\n                    if (!variables) {\n                        throw new InvalidArgument(\n                            'Variables context missing.',\n                            {\n                                entity: this.meta.name,\n                            }\n                        );\n                    }\n\n                    if (\n                        (!variables.session ||\n                            !(value.name in variables.session)) &&\n                        !value.optional\n                    ) {\n                        const errArgs = [];\n                        if (value.missingMessage) {\n                            errArgs.push(value.missingMessage);\n                        }\n                        if (value.missingStatus) {\n                            errArgs.push(\n                                value.missingStatus || HttpCode.BAD_REQUEST\n                            );\n                        }\n\n                        throw new ValidationError(...errArgs);\n                    }\n\n                    return variables.session[value.name];\n                } else if (value.oorType === 'QueryVariable') {\n                    if (!variables) {\n                        throw new InvalidArgument(\n                            'Variables context missing.',\n                            {\n                                entity: this.meta.name,\n                            }\n                        );\n                    }\n\n                    if (!variables.query || !(value.name in variables.query)) {\n                        throw new InvalidArgument(\n                            `Query parameter \"${value.name}\" in configuration not found.`,\n                            {\n                                entity: this.meta.name,\n                            }\n                        );\n                    }\n\n                    return variables.query[value.name];\n                } else if (value.oorType === 'SymbolToken') {\n                    return this._translateSymbolToken(value.name);\n                }\n\n                throw new Error('Not implemented yet. ' + value.oorType);\n            }\n\n            return _.mapValues(value, (v, k) =>\n                this._translateValue(\n                    v,\n                    variables,\n                    skipTypeCast,\n                    arrayToInOperator && k[0] !== '$'\n                )\n            );\n        }\n\n        if (Array.isArray(value)) {\n            const ret = value.map((v) =>\n                this._translateValue(\n                    v,\n                    variables,\n                    skipTypeCast,\n                    arrayToInOperator\n                )\n            );\n            return arrayToInOperator ? { $in: ret } : ret;\n        }\n\n        if (skipTypeCast) return value;\n\n        return this.db.connector.typeCast(value);\n    }\n}\n\nmodule.exports = EntityModel;\n"],"mappings":"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"}