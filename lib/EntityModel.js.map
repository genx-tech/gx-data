{"version":3,"file":"EntityModel.js","names":["HttpCode","UnexpectedState","ValidationError","DatabaseError","InvalidArgument","require","_","eachAsync_","Generators","Convertors","Types","Features","Rules","excludeColumn","isNothing","hasValueIn","JES","NEED_OVERRIDE","minifyAssocs","assocs","sorted","uniq","sort","reverse","minified","take","l","length","i","k","find","a","startsWith","push","oorTypesToBypass","Set","EntityModel","constructor","rawData","Object","assign","valueOfKey","data","meta","keyField","feildMeta","args","fieldSchema","name","extra","fields","schema","omit","$addEnumValues","$orAsArray","others","arrayElem","type","ENUM","values","concat","elementSchema","inputSchema","inputSetName","options","key","JSON","stringify","_cachedSchema","cache","schemaGenerator","db","assocFrom","extraArray","result","forEach","keyPath","keyNodes","split","assoc","slice","map","p","substring","join","add","Array","from","getUniqueKeyFieldsFrom","uniqueKeys","every","f","isNil","getUniqueKeyValuePairsFrom","ukFields","pick","getNestedObject","entityObj","defaultValue","nodes","isArray","get","ensureFields_","connOpts","field","has","uk","isEmpty","findOptions","$query","$association","findOne_","ensureRetrieveCreated","context","customOptions","$retrieveCreated","ensureRetrieveUpdated","$retrieveUpdated","ensureRetrieveDeleted","$retrieveDeleted","ensureTransaction_","connOptions","connection","connector","beginTransaction_","getValueFromContext","cached_","associations","combinedKey","cachedData","_cachedData","findAll_","$toDictionary","toDictionary","entityCollection","transformer","toKVPairs","aggregate_","pipeline","_pipeline","q","_prepareQueries","rawOptions","op","applyRules_","RULE_BEFORE_FIND","_safeExecute_","records","find_","$retrieveDbResult","$result","$relationships","$skipOrm","undefined","_mapRecordsToObjects","$nestedKeyGetter","log","entity","$transformer","evaluate","totalCount","rows","$totalCount","afterFindAll_","row","ret","totalItems","items","$offset","offset","$limit","limit","retryCreateOnDuplicate_","dataGenerator_","maxRery","createOptions","counter","errorRet","create_","error","code","raw","references","_extractAssociations","beforeCreate_","return","success","_populateReferences_","needCreateAssocs","_createAssocs_","_prepareEntityData_","RULE_BEFORE_CREATE","_internalBeforeCreate_","$dryRun","$upsert","dataForUpdating","latest","keys","upsertOne_","_fillResult","insertId","affectedRows","_internalAfterCreate_","queryKey","RULE_AFTER_CREATE","afterCreate_","updateOne_","updateOptions","_update_","updateMany_","forSingleRecord","conditionFields","toUpdate","beforeUpdate_","beforeUpdateMany_","needUpdateAssocs","doneUpdateAssocs","_updateAssocs_","RULE_BEFORE_UPDATE","_internalBeforeUpdate_","_internalBeforeUpdateMany_","otherOptions","update_","_internalAfterUpdate_","_internalAfterUpdateMany_","RULE_AFTER_UPDATE","afterUpdate_","afterUpdateMany_","replaceOne_","_doReplaceOne_","deleteOne_","deleteOptions","_delete_","deleteMany_","deleteAll_","$deleteAll","toDelete","beforeDelete_","beforeDeleteMany_","deletedCount","RULE_BEFORE_DELETE","_internalBeforeDelete_","_internalBeforeDeleteMany_","delete_","_internalAfterDelete_","_internalAfterDeleteMany_","RULE_AFTER_DELETE","afterDelete_","afterDeleteMany_","_containsUniqueKey","hasKeyNameOnly","hasNotNullKey","hasKeys","_ensureContainsUniqueKey","condition","containsUniqueKeyAndValue","containsUniqueKeyOnly","isUpdating","i18n","existing","$existing","opOptions","_dependsOnExistingData","$retrieveExisting","RULE_BEFORE_VALIDATION","fieldInfo","fieldName","value","useRaw","readOnly","$migration","$bypassReadOnly","freezeAfterNonDefault","Error","default","optional","isPlainObject","oorType","sanitize","stack","forceUpdate","updateByDb","hasActivator","auto","createByDb","_translateValue","$variables","RULE_AFTER_VALIDATION","$skipModifiers","applyModifiers_","mapValues","$requireSplitColumns","_serializeByTypeInfo","executor","bind","commit_","message","latestData","rollback_","_dependencyChanged","fieldDependencies","deps","d","reference","hasIn","_referenceExist","input","ref","pos","indexOf","substr","hasDepends","nullDepends","dep","whenNull","atLeastOneNotNull","features","_hasReservedKeys","obj","v","keyFields","normalizedOptions","$key","query","forOwn","$bypassEnsureUnique","$groupBy","having","$projection","_prepareAssociations","inputKeyField","_translateSymbolToken","info","variables","skipTypeCast","arrayToInOperator","session","errArgs","missingMessage","missingStatus","BAD_REQUEST","$in","typeCast","module","exports"],"sources":["../src/EntityModel.js"],"sourcesContent":["const { HttpCode, UnexpectedState, ValidationError, DatabaseError, InvalidArgument } = require('@genx/error');\nconst { _, eachAsync_ } = require('@genx/july');\nconst Generators = require('./Generators');\nconst Convertors = require('./Convertors');\nconst Types = require('./types');\nconst Features = require('./entityFeatures');\nconst Rules = require('./enum/Rules');\nconst { excludeColumn } = require('./drivers/mysql/mixin/excludeColumn');\n\nconst { isNothing, hasValueIn } = require('./utils/lang');\nconst JES = require('@genx/jes');\n\nconst NEED_OVERRIDE = 'Should be overrided by driver-specific subclass.';\n\nfunction minifyAssocs(assocs) {\n    const sorted = _.uniq(assocs).sort().reverse();\n\n    const minified = _.take(sorted, 1);\n    const l = sorted.length - 1;\n\n    for (let i = 1; i < l; i++) {\n        const k = sorted[i] + '.';\n\n        if (!_.find(minified, (a) => a.startsWith(k))) {\n            minified.push(sorted[i]);\n        }\n    }\n\n    return minified;\n}\n\nconst oorTypesToBypass = new Set([\n    'ColumnReference',\n    'Function',\n    'BinaryExpression',\n    'DataSet',\n    'SQL',\n]);\n\n/**\n * Base entity model class.\n * @class\n */\nclass EntityModel {\n    /**\n     * @param {Object} [rawData] - Raw data object\n     */\n    constructor(rawData) {\n        if (rawData) {\n            // only pick those that are fields of this entity\n            Object.assign(this, rawData);\n        }\n    }\n\n    static valueOfKey(data) {\n        return data[this.meta.keyField];\n    }\n\n    // alias of fieldSchema, backward compatible with v1\n    static feildMeta(...args) {\n        return this.fieldSchema(...args);\n    }\n\n    /**\n     * Get a field schema based on the metadata of the field.\n     * @param {string} name - Field name\n     * @param {object} [extra] - Extra schema options\n     * @return {object|array} Schema object\n     */\n    static fieldSchema(name, extra) {\n        const meta = this.meta.fields[name];\n        if (!meta) {\n            throw new InvalidArgument(\n                `Unknown field \"${name}\" of entity \"${this.meta.name}\".`\n            );\n        }\n\n        const schema = _.omit(meta, ['default', 'optional']);\n\n        if (extra) {\n            const { $addEnumValues, $orAsArray, ...others } = extra;\n            let arrayElem = schema;\n\n            if ($orAsArray) {\n                arrayElem = { ...schema, ...others };\n            }\n\n            if (meta.type === Types.ENUM.name && $addEnumValues) {\n                schema.values = schema.values.concat($addEnumValues);\n            }\n\n            Object.assign(schema, others);\n\n            if ($orAsArray) {\n                return [\n                    schema,\n                    {\n                        type: 'array',\n                        elementSchema: arrayElem,\n                    },\n                ];\n            }\n        }\n\n        return schema;\n    }\n\n    /**\n     * Get a map of fields schema by predefined input set.\n     * @param {string} inputSetName - Input set name, predefined in geml\n     * @param {object} [options] - Input set options\n     * @return {object} Schema object\n     */\n    static inputSchema(inputSetName, options) {\n        const key =\n            inputSetName + (options == null ? '{}' : JSON.stringify(options));\n\n        if (this._cachedSchema) {\n            const cache = this._cachedSchema[key];\n            if (cache) {\n                return cache;\n            }\n        } else {\n            this._cachedSchema = {};\n        }\n\n        const schemaGenerator = this.db.require(\n            `inputs/${this.meta.name}-${inputSetName}`\n        );\n\n        return (this._cachedSchema[key] = schemaGenerator(options));\n    }\n\n    /**\n     * Helper to combine explicit required associations and associations required by query fields or projection fields.\n     * @param {*} extraArray \n     * @param {*} fields \n     * @returns {Array}\n     */\n    static assocFrom(extraArray, fields) {\n        const result = new Set(extraArray);\n\n        if (fields) {\n            fields.forEach(keyPath => {\n                const keyNodes = keyPath.split('.');\n                if (keyNodes.length > 1) {\n                    const assoc = keyNodes.slice(0, -1).map(p => p.startsWith(\":\") ? p.substring(1) : p).join('.');\n                    result.add(assoc);\n                }\n            })\n        }\n\n        return Array.from(result);\n    }\n\n    /**\n     * Get field names array of a unique key from input data.\n     * @param {object} data - Input data.\n     */\n    static getUniqueKeyFieldsFrom(data) {\n        return _.find(this.meta.uniqueKeys, (fields) =>\n            _.every(fields, (f) => !_.isNil(data[f]))\n        );\n    }\n\n    /**\n     * Get key-value pairs of a unique key from input data.\n     * @param {object} data - Input data.\n     */\n    static getUniqueKeyValuePairsFrom(data) {\n        const ukFields = this.getUniqueKeyFieldsFrom(data);\n        return _.pick(data, ukFields);\n    }\n\n    /**\n     * Get nested object of an entity.\n     * @param {*} entityObj\n     * @param {*} keyPath\n     */\n    static getNestedObject(entityObj, keyPath, defaultValue) {\n        const nodes = (\n            Array.isArray(keyPath) ? keyPath : keyPath.split('.')\n        ).map((key) => (key[0] === ':' ? key : ':' + key));\n        return _.get(entityObj, nodes, defaultValue);\n    }\n\n    /**\n     * Ensure the entity object containing required fields, if not, it will automatically fetched from db and return.\n     * @param {*} entityObj \n     * @param {Array} fields \n     * @param {*} connOpts \n     * @returns {Object}\n     */\n    static async ensureFields_(entityObj, fields, connOpts) {\n        if (_.find(fields, field => !_.has(entityObj, field))) {\n            const uk = this.getUniqueKeyValuePairsFrom(entityObj);\n\n            if (_.isEmpty(uk)) {\n                throw new UnexpectedState('None of the unique keys found from the data set.');\n            }\n\n            const findOptions = { $query: uk, /* $projection: fields,*/ $association: this.assocFrom(null, fields) };\n\n            return this.findOne_(findOptions, connOpts)\n        }\n\n        return entityObj;\n    }\n\n    /**\n     * Ensure context.latest be the just created entity.\n     * @param {*} context\n     * @param {*} customOptions\n     */\n    static ensureRetrieveCreated(context, customOptions) {\n        if (!context.options.$retrieveCreated) {\n            context.options.$retrieveCreated = customOptions || true;\n        }\n    }\n\n    /**\n     * Ensure context.latest be the just updated entity.\n     * @param {*} context\n     * @param {*} customOptions\n     */\n    static ensureRetrieveUpdated(context, customOptions) {\n        if (!context.options.$retrieveUpdated) {\n            context.options.$retrieveUpdated = customOptions || true;\n        }\n    }\n\n    /**\n     * Ensure context.exisintg be the just deleted entity.\n     * @param {*} context\n     * @param {*} customOptions\n     */\n    static ensureRetrieveDeleted(context, customOptions) {\n        if (!context.options.$retrieveDeleted) {\n            context.options.$retrieveDeleted = customOptions || true;\n        }\n    }\n\n    /**\n     * Ensure the upcoming operations are executed in a transaction.\n     * @param {*} context\n     */\n    static async ensureTransaction_(context) {\n        if (!context.connOptions || !context.connOptions.connection) {\n            context.connOptions || (context.connOptions = {});\n\n            context.connOptions.connection =\n                await this.db.connector.beginTransaction_();\n        }\n    }\n\n    /**\n     * Get value from context, e.g. session, query ...\n     * @param {*} context\n     * @param {string} key\n     * @returns {*}\n     */\n    static getValueFromContext(context, key) {\n        return _.get(context, 'options.$variables.' + key);\n    }\n\n    /**\n     * Get a pk-indexed hashtable with all undeleted data\n     * {string} [key] - The key field to used by the hashtable.\n     * {array} [associations] - With an array of associations.\n     * {object} [connOptions] - Connection options, e.g. transaction handle\n     */\n    static async cached_(key, associations, connOptions) {\n        if (key) {\n            let combinedKey = key;\n\n            if (!_.isEmpty(associations)) {\n                combinedKey += '/' + minifyAssocs(associations).join('&');\n            }\n\n            let cachedData;\n\n            if (!this._cachedData) {\n                this._cachedData = {};\n            } else if (this._cachedData[combinedKey]) {\n                cachedData = this._cachedData[combinedKey];\n            }\n\n            if (!cachedData) {\n                cachedData = this._cachedData[combinedKey] =\n                    await this.findAll_(\n                        { $association: associations, $toDictionary: key },\n                        connOptions\n                    );\n            }\n\n            return cachedData;\n        }\n\n        return this.cached_(this.meta.keyField, associations, connOptions);\n    }\n\n    static toDictionary(entityCollection, key, transformer) {\n        key || (key = this.meta.keyField);\n\n        return Convertors.toKVPairs(entityCollection, key, transformer);\n    }\n\n    /**\n     * Run aggregate pipeline\n     * @param {array} pipeline\n     * @param {object} [connOptions]\n     * @returns {*}\n     */\n    static async aggregate_(pipeline, connOptions) {\n        const _pipeline = pipeline.map(q => this._prepareQueries(q));\n\n        return this.db.connector.aggregate_(\n            this.meta.name,\n            _pipeline,\n            connOptions\n        );\n    }\n\n    /**\n     * Find one record, returns a model object containing the record or undefined if nothing found.     \n     * @param {object} [findOptions] - findOptions\n     * @property {object} [findOptions.$association] - Joinings\n     * @property {object} [findOptions.$projection] - Selected fields\n     * @property {object} [findOptions.$transformer] - Transform fields before returning\n     * @property {object} [findOptions.$query] - Extra condition\n     * @property {object} [findOptions.$groupBy] - Group by fields\n     * @property {object} [findOptions.$orderBy] - Order by fields\n     * @property {number} [findOptions.$offset] - Offset\n     * @property {number} [findOptions.$limit] - Limit\n     * @property {bool} [findOptions.$includeDeleted=false] - Include those marked as logical deleted.\n     * @param {object} [connOptions]\n     * @property {object} [connOptions.connection]\n     * @returns {*}\n     */\n    static async findOne_(findOptions, connOptions) {\n        const rawOptions = findOptions;\n\n        findOptions = this._prepareQueries(\n            findOptions,\n            true /* for single record */\n        );\n\n        const context = {\n            op: 'find',\n            options: findOptions,\n            connOptions,\n        };\n\n        await Features.applyRules_(Rules.RULE_BEFORE_FIND, this, context);\n\n        const result = await this._safeExecute_(async (context) => {\n            let records = await this.db.connector.find_(\n                this.meta.name,\n                context.options,\n                context.connOptions\n            );\n            if (!records)\n                throw new DatabaseError(\n                    'connector.find_() returns undefined data record.'\n                );\n\n            if (rawOptions && rawOptions.$retrieveDbResult) {\n                rawOptions.$result = records.slice(1);\n            }\n\n            if (findOptions.$relationships && !findOptions.$skipOrm) {\n                // rows, coloumns, aliasMap\n                if (records[0].length === 0) return undefined;\n\n                records = this._mapRecordsToObjects(\n                    records,\n                    findOptions.$relationships,\n                    findOptions.$nestedKeyGetter\n                );\n            } else if (records.length === 0) {\n                return undefined;\n            }\n\n            if (records.length !== 1) {\n                this.db.connector.log(\n                    'error',\n                    `findOne() returns more than one record.`,\n                    { entity: this.meta.name, options: context.options }\n                );\n            }\n\n            const result = records[0];\n\n            return result;\n        }, context);\n\n        if (findOptions.$transformer) {\n            return JES.evaluate(result, findOptions.$transformer);\n        }\n\n        return result;\n    }\n\n    /**\n     * Find records matching the condition, returns an array of records.\n     * @param {object} [findOptions] - findOptions\n     * @property {object} [findOptions.$association] - Joinings\n     * @property {object} [findOptions.$projection] - Selected fields\n     * @property {object} [findOptions.$transformer] - Transform fields before returning\n     * @property {object} [findOptions.$query] - Extra condition\n     * @property {object} [findOptions.$groupBy] - Group by fields\n     * @property {object} [findOptions.$orderBy] - Order by fields\n     * @property {number} [findOptions.$offset] - Offset\n     * @property {number} [findOptions.$limit] - Limit\n     * @property {number} [findOptions.$totalCount] - Return totalCount\n     * @property {bool} [findOptions.$includeDeleted=false] - Include those marked as logical deleted.\n     * @param {object} [connOptions]\n     * @property {object} [connOptions.connection]\n     * @returns {array}\n     */\n    static async findAll_(findOptions, connOptions) {\n        const rawOptions = findOptions;\n\n        findOptions = this._prepareQueries(findOptions);\n\n        const context = {\n            op: 'find',\n            options: findOptions,\n            connOptions,\n        };\n\n        await Features.applyRules_(Rules.RULE_BEFORE_FIND, this, context);\n\n        let totalCount;\n        \n        let rows = await this._safeExecute_(async (context) => {\n            let records = await this.db.connector.find_(\n                this.meta.name,\n                context.options,\n                context.connOptions\n            );\n\n            if (!records)\n                throw new DatabaseError(\n                    'connector.find_() returns undefined data record.'\n                );\n\n            if (rawOptions && rawOptions.$retrieveDbResult) {\n                rawOptions.$result = records.slice(1);\n            }\n\n            if (findOptions.$relationships) {\n                if (findOptions.$totalCount) {\n                    totalCount = records[3];\n                }\n\n                if (!findOptions.$skipOrm) {\n                    records = this._mapRecordsToObjects(\n                        records,\n                        findOptions.$relationships,\n                        findOptions.$nestedKeyGetter\n                    );\n                } else {\n                    records = records[0];\n                }\n            } else {\n                if (findOptions.$totalCount) {\n                    totalCount = records[1];\n                    records = records[0];\n                } else if (findOptions.$skipOrm) {\n                    records = records[0];\n                }\n            }\n\n            return this.afterFindAll_(context, records);\n        }, context);\n\n        if (findOptions.$transformer) {\n            rows = rows.map((row) =>\n                JES.evaluate(row, findOptions.$transformer)\n            );\n        }\n\n        if (findOptions.$totalCount) {\n            const ret = { totalItems: totalCount, items: rows };\n\n            if (!isNothing(findOptions.$offset)) {\n                ret.offset = findOptions.$offset;\n            }\n\n            if (!isNothing(findOptions.$limit)) {\n                ret.limit = findOptions.$limit;\n            }\n\n            return ret;\n        }\n\n        return rows;\n    }\n\n    /**\n     * Regenerate creation data and try again if duplicate record exists\n     * @param {Function} dataGenerator_\n     * @param {Object} connOptions\n     */\n    static async retryCreateOnDuplicate_(\n        dataGenerator_,\n        maxRery,\n        createOptions,\n        connOptions\n    ) {\n        let counter = 0;\n        let errorRet;\n        maxRery || (maxRery = 10);\n\n        while (counter++ < maxRery) {\n            const data = await dataGenerator_();\n\n            try {\n                return await this.create_(data, createOptions, connOptions);\n            } catch (error) {\n                if (error.code !== 'E_DUPLICATE') {\n                    throw error;\n                }\n\n                errorRet = error;\n            }\n        }\n\n        return errorRet;\n    }\n\n    /**\n     * Create a new entity with given data.\n     * @param {object} data - Entity data\n     * @param {object} [createOptions] - Create options\n     * @property {bool} [createOptions.$retrieveCreated=false] - Retrieve the newly created record from db.\n     * @property {bool} [createOptions.$upsert=false] - If already exist, just update the record.\n     * @param {object} [connOptions]\n     * @property {object} [connOptions.connection]\n     * @returns {EntityModel}\n     */\n    static async create_(data, createOptions, connOptions) {\n        const rawOptions = createOptions;\n\n        if (!createOptions) {\n            createOptions = {};\n        }\n\n        let [raw, associations, references] = this._extractAssociations(\n            data,\n            true\n        );\n\n        const context = {\n            op: 'create',\n            raw,\n            rawOptions,\n            options: createOptions,\n            connOptions,\n        };\n\n        if (!(await this.beforeCreate_(context))) {\n            return context.return;\n        }\n\n        const success = await this._safeExecute_(async (context) => {\n            if (!_.isEmpty(references)) {\n                await this.ensureTransaction_(context);\n                await this._populateReferences_(context, references);\n            }\n\n            let needCreateAssocs = !_.isEmpty(associations);\n            if (needCreateAssocs) {\n                await this.ensureTransaction_(context);\n\n                associations = await this._createAssocs_(\n                    context,\n                    associations,\n                    true /* before create */\n                );\n                // check any other associations left\n                needCreateAssocs = !_.isEmpty(associations);\n            }\n\n            await this._prepareEntityData_(context);\n\n            if (\n                !(await Features.applyRules_(\n                    Rules.RULE_BEFORE_CREATE,\n                    this,\n                    context\n                ))\n            ) {\n                return false;\n            }\n\n            if (!(await this._internalBeforeCreate_(context))) {\n                return false;\n            }\n\n            if (!context.options.$dryRun) {\n                if (context.options.$upsert) {\n                    const dataForUpdating = _.pick(context.latest, Object.keys(context.raw)); // only update the raw part    \n\n                    context.result = await this.db.connector.upsertOne_(\n                        this.meta.name,\n                        dataForUpdating,\n                        this.getUniqueKeyFieldsFrom(context.latest),\n                        context.connOptions,\n                        context.latest\n                    );\n                } else {\n                    context.result = await this.db.connector.create_(\n                        this.meta.name,\n                        context.latest,\n                        context.connOptions\n                    );\n                }\n\n                this._fillResult(context);\n            } else {\n                context.return = context.latest;\n                context.result = { insertId: context.latest[this.meta.keyField], affectedRows: 1 };\n            }\n\n            if (needCreateAssocs) {\n                await this._createAssocs_(context, associations);\n            }\n\n            await this._internalAfterCreate_(context);\n\n            if (!context.queryKey) {\n                context.queryKey = this.getUniqueKeyValuePairsFrom(\n                    context.latest\n                );\n            }\n\n            await Features.applyRules_(Rules.RULE_AFTER_CREATE, this, context);\n\n            return true;\n        }, context);\n\n        if (success && !context.options.$dryRun) {\n            await this.afterCreate_(context);\n        }\n\n        return context.return;\n    }\n\n    /**\n     * Update an existing entity with given data.\n     * @param {object} data - Entity data with at least one unique key (pair) given\n     * @param {object} [updateOptions] - Update options\n     * @property {object} [updateOptions.$query] - Extra condition\n     * @property {bool} [updateOptions.$retrieveUpdated=false] - Retrieve the updated entity from database\n     * @param {object} [connOptions]\n     * @property {object} [connOptions.connection]\n     * @returns {object}\n     */\n    static async updateOne_(data, updateOptions, connOptions) {\n        return this._update_(data, updateOptions, connOptions, true);\n    }\n\n    /**\n     * Update many existing entites with given data.\n     * @param {*} data\n     * @param {*} updateOptions\n     * @param {*} connOptions\n     */\n    static async updateMany_(data, updateOptions, connOptions) {\n        return this._update_(data, updateOptions, connOptions, false);\n    }\n\n    static async _update_(data, updateOptions, connOptions, forSingleRecord) {\n        const rawOptions = updateOptions;\n\n        if (!updateOptions) {\n            // if no condition given, extract from data\n            const conditionFields = this.getUniqueKeyFieldsFrom(data);\n            if (_.isEmpty(conditionFields)) {\n                throw new InvalidArgument(\n                    'Primary key value(s) or at least one group of unique key value(s) is required for updating an entity.',\n                    {\n                        entity: this.meta.name,\n                        data,\n                    }\n                );\n            }\n            updateOptions = { $query: _.pick(data, conditionFields) };\n            data = _.omit(data, conditionFields);\n        }\n\n        // see if there is associated entity data provided together\n        let [raw, associations, references] = this._extractAssociations(data);\n\n        const context = {\n            op: 'update',\n            raw,\n            rawOptions,\n            options: this._prepareQueries(\n                updateOptions,\n                forSingleRecord /* for single record */\n            ),\n            connOptions,\n            forSingleRecord,\n        };\n\n        // see if there is any runtime feature stopping the update\n        let toUpdate;\n\n        if (forSingleRecord) {\n            toUpdate = await this.beforeUpdate_(context);\n        } else {\n            toUpdate = await this.beforeUpdateMany_(context);\n        }\n\n        if (!toUpdate) {\n            return context.return;\n        }\n\n        const success = await this._safeExecute_(async (context) => {\n            if (!_.isEmpty(references)) {\n                await this.ensureTransaction_(context);\n                await this._populateReferences_(context, references);\n            }\n\n            let needUpdateAssocs = !_.isEmpty(associations);\n            let doneUpdateAssocs;\n\n            if (needUpdateAssocs) {\n                await this.ensureTransaction_(context);\n\n                associations = await this._updateAssocs_(\n                    context,\n                    associations,\n                    true /* before update */,\n                    forSingleRecord\n                );\n                needUpdateAssocs = !_.isEmpty(associations);\n                doneUpdateAssocs = true;\n            }\n\n            await this._prepareEntityData_(\n                context,\n                true /* is updating */,\n                forSingleRecord\n            );\n\n            if (\n                !(await Features.applyRules_(\n                    Rules.RULE_BEFORE_UPDATE,\n                    this,\n                    context\n                ))\n            ) {\n                return false;\n            }\n\n            if (forSingleRecord) {\n                toUpdate = await this._internalBeforeUpdate_(context);\n            } else {\n                toUpdate = await this._internalBeforeUpdateMany_(context);\n            }\n\n            if (!toUpdate) {\n                return false;\n            }\n\n            const { $query, ...otherOptions } = context.options;\n\n            if (_.isEmpty(context.latest)) {\n                if (!doneUpdateAssocs && !needUpdateAssocs) {\n                    throw new InvalidArgument(\n                        'Cannot do the update with empty record. Entity: ' +\n                        this.meta.name\n                    );\n                }\n            } else {\n                if (\n                    needUpdateAssocs &&\n                    !hasValueIn([$query, context.latest], this.meta.keyField) &&\n                    !otherOptions.$retrieveUpdated\n                ) {\n                    // has associated data depending on this record\n                    // should ensure the latest result will contain the key of this record\n                    otherOptions.$retrieveUpdated = true;\n                }\n\n                if (forSingleRecord && !otherOptions.$limit) {\n                    otherOptions.$limit = 1;\n                }\n\n                context.result = await this.db.connector.update_(\n                    this.meta.name,\n                    context.latest,\n                    $query,\n                    otherOptions,\n                    context.connOptions\n                );\n\n                context.return = context.latest;\n            }\n\n            if (forSingleRecord) {\n                await this._internalAfterUpdate_(context);\n\n                if (!context.queryKey) {\n                    context.queryKey = this.getUniqueKeyValuePairsFrom($query);\n                }\n            } else {\n                await this._internalAfterUpdateMany_(context);\n            }\n\n            await Features.applyRules_(Rules.RULE_AFTER_UPDATE, this, context);\n\n            if (needUpdateAssocs) {\n                await this._updateAssocs_(\n                    context,\n                    associations,\n                    false,\n                    forSingleRecord\n                );\n            }\n\n            return true;\n        }, context);\n\n        if (success && !context.options.$dryRun) {\n            if (forSingleRecord) {\n                await this.afterUpdate_(context);\n            } else {\n                await this.afterUpdateMany_(context);\n            }\n        }\n\n        return context.return;\n    }\n\n    /**\n     * Update an existing entity with given data, or create one if not found.\n     * @param {*} data\n     * @param {*} updateOptions\n     * @param {*} connOptions\n     */\n    static async replaceOne_(data, updateOptions, connOptions) {\n        const rawOptions = updateOptions;\n\n        if (!updateOptions) {\n            const conditionFields = this.getUniqueKeyFieldsFrom(data);\n            if (_.isEmpty(conditionFields)) {\n                throw new InvalidArgument(\n                    'Primary key value(s) or at least one group of unique key value(s) is required for replacing an entity.',\n                    {\n                        entity: this.meta.name,\n                        data,\n                    }\n                );\n            }\n\n            updateOptions = {\n                ...updateOptions,\n                $query: _.pick(data, conditionFields),\n            };\n        } else {\n            updateOptions = this._prepareQueries(updateOptions, true);\n        }\n\n        const context = {\n            op: 'replace',\n            raw: data,\n            rawOptions,\n            options: updateOptions,\n            connOptions,\n        };\n\n        return this._safeExecute_(async (context) => {\n            return this._doReplaceOne_(context); // different dbms has different replacing strategy\n        }, context);\n    }\n\n    /**\n     * Remove an existing entity with given data.\n     * @param {object} [deleteOptions] - Update options\n     * @property {object} [deleteOptions.$query] - Extra condition\n     * @property {bool} [deleteOptions.$retrieveDeleted=false] - Retrieve the deleted entity from database\n     * @property {bool} [deleteOptions.$physicalDeletion=false] - When $physicalDeletion = true, deletetion will not take into account logicaldeletion feature\n     * @param {object} [connOptions]\n     * @property {object} [connOptions.connection]\n     */\n    static async deleteOne_(deleteOptions, connOptions) {\n        return this._delete_(deleteOptions, connOptions, true);\n    }\n\n    /**\n     * Remove an existing entity with given data.\n     * @param {object} [deleteOptions] - Update options\n     * @property {object} [deleteOptions.$query] - Extra condition\n     * @property {bool} [deleteOptions.$retrieveDeleted=false] - Retrieve the deleted entity from database\n     * @property {bool} [deleteOptions.$physicalDeletion=false] - When $physicalDeletion = true, deletetion will not take into account logicaldeletion feature\n     * @property {bool} [deleteOptions.$deleteAll=false] - When $deleteAll = true, the operation will proceed even empty condition is given\n     * @param {object} [connOptions]\n     * @property {object} [connOptions.connection]\n     */\n    static async deleteMany_(deleteOptions, connOptions) {\n        return this._delete_(deleteOptions, connOptions, false);\n    }\n\n    static async deleteAll_(connOptions) {\n        return this.deleteMany_({ $deleteAll: true }, connOptions);\n    }\n\n    /**\n     * Remove an existing entity with given data.\n     * @param {object} [deleteOptions] - Update options\n     * @property {object} [deleteOptions.$query] - Extra condition\n     * @property {bool} [deleteOptions.$retrieveDeleted=false] - Retrieve the deleted entity from database\n     * @property {bool} [deleteOptions.$physicalDeletion=false] - When $physicalDeletion = true, deletetion will not take into account logicaldeletion feature\n     * @param {object} [connOptions]\n     * @property {object} [connOptions.connection]\n     */\n    static async _delete_(deleteOptions, connOptions, forSingleRecord) {\n        const rawOptions = deleteOptions;\n\n        deleteOptions = this._prepareQueries(\n            deleteOptions,\n            forSingleRecord /* for single record */\n        );\n\n        if (\n            _.isEmpty(deleteOptions.$query) &&\n            (forSingleRecord || !deleteOptions.$deleteAll)\n        ) {\n            throw new InvalidArgument(\n                'Empty condition is not allowed for deleting or add { $deleteAll: true } to delete all records.',\n                {\n                    entity: this.meta.name,\n                    deleteOptions,\n                }\n            );\n        }\n\n        const context = {\n            op: 'delete',\n            rawOptions,\n            options: deleteOptions,\n            connOptions,\n            forSingleRecord,\n        };\n\n        let toDelete;\n\n        if (forSingleRecord) {\n            toDelete = await this.beforeDelete_(context);\n        } else {\n            toDelete = await this.beforeDeleteMany_(context);\n        }\n\n        if (!toDelete) {\n            return context.return;\n        }\n\n        const deletedCount = await this._safeExecute_(async (context) => {\n            if (\n                !(await Features.applyRules_(\n                    Rules.RULE_BEFORE_DELETE,\n                    this,\n                    context\n                ))\n            ) {\n                return false;\n            }\n\n            if (forSingleRecord) {\n                toDelete = await this._internalBeforeDelete_(context);\n            } else {\n                toDelete = await this._internalBeforeDeleteMany_(context);\n            }\n\n            if (!toDelete) {\n                return false;\n            }\n\n            const { $query, ...otherOptions } = context.options;\n\n            context.result = await this.db.connector.delete_(\n                this.meta.name,\n                $query,\n                otherOptions,\n                context.connOptions\n            );\n\n            if (forSingleRecord) {\n                await this._internalAfterDelete_(context);\n            } else {\n                await this._internalAfterDeleteMany_(context);\n            }\n\n            if (!context.queryKey) {\n                if (forSingleRecord) {\n                    context.queryKey = this.getUniqueKeyValuePairsFrom(\n                        context.options.$query\n                    );\n                } else {\n                    context.queryKey = context.options.$query;\n                }\n            }\n\n            await Features.applyRules_(Rules.RULE_AFTER_DELETE, this, context);\n\n            return this.db.connector.deletedCount(context);\n        }, context);\n\n        if (deletedCount && !context.options.$dryRun) {\n            if (forSingleRecord) {\n                await this.afterDelete_(context);\n            } else {\n                await this.afterDeleteMany_(context);\n            }\n        }\n\n        return context.return || deletedCount;\n    }\n\n    /**\n     * Check whether a data record contains primary key or at least one unique key pair.\n     * @param {object} data\n     */\n    static _containsUniqueKey(data) {\n        let hasKeyNameOnly = false;\n\n        const hasNotNullKey = _.find(this.meta.uniqueKeys, (fields) => {\n            const hasKeys = _.every(fields, (f) => f in data);\n            hasKeyNameOnly = hasKeyNameOnly || hasKeys;\n\n            return _.every(fields, (f) => !_.isNil(data[f]));\n        });\n\n        return [hasNotNullKey, hasKeyNameOnly];\n    }\n\n    /**\n     * Ensure the condition contains one of the unique keys.\n     * @param {*} condition\n     */\n    static _ensureContainsUniqueKey(condition) {\n        const [containsUniqueKeyAndValue, containsUniqueKeyOnly] =\n            this._containsUniqueKey(condition);\n\n        if (!containsUniqueKeyAndValue) {\n            if (containsUniqueKeyOnly) {\n                throw new ValidationError(\n                    'One of the unique key field as query condition is null. Condition: ' +\n                    JSON.stringify(condition)\n                );\n            }\n\n            throw new InvalidArgument(\n                'Single record operation requires at least one unique key value pair in the query condition.',\n                {\n                    entity: this.meta.name,\n                    condition,\n                }\n            );\n        }\n    }\n\n    /**\n     * Prepare valid and sanitized entity data for sending to database.\n     * @param {object} context - Operation context.\n     * @property {object} context.raw - Raw input data.\n     * @property {object} [context.connOptions]\n     * @param {bool} isUpdating - Flag for updating existing entity.\n     */\n    static async _prepareEntityData_(\n        context,\n        isUpdating = false,\n        forSingleRecord = true\n    ) {\n        const meta = this.meta;\n        const i18n = this.i18n;\n        const { name, fields } = meta;\n\n        let { raw } = context;\n        let latest = {};\n        // returned by $retrieveExisting\n        let existing = context.options.$existing;\n        context.latest = latest;\n\n        if (!context.i18n) {\n            context.i18n = i18n;\n        }\n\n        const opOptions = context.options;\n\n        if (opOptions.$upsert && typeof opOptions.$upsert === 'object') {\n            raw = { ...raw, ...opOptions.$upsert };\n        }\n\n        if (\n            isUpdating &&\n            _.isEmpty(existing) &&\n            (this._dependsOnExistingData(raw) || opOptions.$retrieveExisting)\n        ) {\n            await this.ensureTransaction_(context);\n\n            if (forSingleRecord) {\n                existing = await this.findOne_(\n                    { $query: opOptions.$query },\n                    context.connOptions\n                );\n            } else {\n                existing = await this.findAll_(\n                    { $query: opOptions.$query },\n                    context.connOptions\n                );\n            }\n            context.existing = existing;\n        }\n\n        if (opOptions.$retrieveExisting && !context.rawOptions.$existing) {\n            context.rawOptions.$existing = existing;\n        }\n\n        await Features.applyRules_(Rules.RULE_BEFORE_VALIDATION, this, context);\n\n        await eachAsync_(fields, async (fieldInfo, fieldName) => {\n            let value;\n            let useRaw = false;\n\n            if (fieldName in raw) {\n                value = raw[fieldName];\n                useRaw = true;\n            } else if (fieldName in latest) {\n                value = latest[fieldName];\n            }\n\n            if (typeof value !== 'undefined') {\n                // field value given in raw data\n                if (fieldInfo.readOnly && useRaw) {\n                    if (\n                        !opOptions.$migration &&\n                        (!opOptions.$bypassReadOnly ||\n                            !opOptions.$bypassReadOnly.has(fieldName))\n                    ) {\n                        // read only, not allow to set by input value\n                        throw new ValidationError(\n                            `Read-only field \"${fieldName}\" is not allowed to be set by manual input.`,\n                            {\n                                entity: name,\n                                fieldInfo: fieldInfo,\n                            }\n                        );\n                    }\n                }\n\n                if (isUpdating && fieldInfo.freezeAfterNonDefault) {\n                    if (!existing) {\n                        throw new Error(\n                            '\"freezeAfterNonDefault\" qualifier requires existing data.'\n                        );\n                    }\n\n                    if (existing[fieldName] !== fieldInfo.default) {\n                        // freezeAfterNonDefault, not allow to change if value is non-default\n                        throw new ValidationError(\n                            `FreezeAfterNonDefault field \"${fieldName}\" is not allowed to be changed.`,\n                            {\n                                entity: name,\n                                fieldInfo: fieldInfo,\n                            }\n                        );\n                    }\n                }\n\n                /**  todo: fix dependency, check writeProtect \n                if (isUpdating && fieldInfo.writeOnce) {     \n                    assert: existing, '\"writeOnce\" qualifier requires existing data.';\n                    if (!_.isNil(existing[fieldName])) {\n                        throw new ValidationError(`Write-once field \"${fieldName}\" is not allowed to be update once it was set.`, {\n                            entity: name,\n                            fieldInfo: fieldInfo \n                        });\n                    }\n                } */\n\n                // sanitize first\n                if (isNothing(value)) {\n                    if (fieldInfo.default) {\n                        // has default setting in meta data\n                        latest[fieldName] = fieldInfo.default;\n                    } else if (!fieldInfo.optional) {\n                        throw new ValidationError(\n                            `The \"${fieldName}\" value of \"${name}\" entity cannot be null.`,\n                            {\n                                entity: name,\n                                fieldInfo: fieldInfo,\n                            }\n                        );\n                    } else {\n                        latest[fieldName] = null;\n                    }\n                } else {\n                    if (_.isPlainObject(value) && value.oorType) {\n                        latest[fieldName] = value;\n\n                        return;\n                    }\n\n                    try {\n                        latest[fieldName] = Types.sanitize(\n                            value,\n                            fieldInfo,\n                            i18n\n                        );\n                    } catch (error) {\n                        throw new ValidationError(\n                            `Invalid \"${fieldName}\" value of \"${name}\" entity.`,\n                            {\n                                entity: name,\n                                fieldInfo: fieldInfo,\n                                value,\n                                error: error.stack,\n                            }\n                        );\n                    }\n                }\n\n                return;\n            }\n\n            // not given in raw data\n            if (isUpdating) {\n                if (fieldInfo.forceUpdate) {\n                    // has force update policy, e.g. updateTimestamp\n                    if (fieldInfo.updateByDb || fieldInfo.hasActivator) {\n                        return;\n                    }\n\n                    // require generator to refresh auto generated value\n                    if (fieldInfo.auto) {\n                        latest[fieldName] = await Generators.default(\n                            fieldInfo,\n                            i18n\n                        );\n                        return;\n                    }\n\n                    throw new ValidationError(\n                        `Field \"${fieldName}\" of \"${name}\" entity is required for each update.`,\n                        {\n                            entity: name,\n                            fieldInfo: fieldInfo,\n                        }\n                    );\n                }\n\n                return;\n            }\n\n            // new record\n            if (!fieldInfo.createByDb) {\n                if ('default' in fieldInfo) {\n                    // has default setting in meta data\n                    latest[fieldName] = fieldInfo.default;\n                } else if (fieldInfo.optional) {\n                    // ignore\n                } else if (fieldInfo.auto) {\n                    // automatically generated\n                    latest[fieldName] = await Generators.default(\n                        fieldInfo,\n                        i18n\n                    );\n                } else if (!fieldInfo.hasActivator) {\n                    // skip those have activators\n\n                    throw new ValidationError(\n                        `Field \"${fieldName}\" of \"${name}\" entity is required.`,\n                        {\n                            entity: name,\n                            fieldInfo: fieldInfo,\n                            raw,\n                        }\n                    );\n                }\n            } // else default value set by database or by rules\n        });\n\n        latest = context.latest = this._translateValue(\n            latest,\n            opOptions.$variables,\n            true\n        );\n\n        await Features.applyRules_(Rules.RULE_AFTER_VALIDATION, this, context);\n\n        if (!opOptions.$skipModifiers) {\n            await this.applyModifiers_(context, isUpdating);\n        }\n\n        // final round process before entering database\n        context.latest = _.mapValues(latest, (value, key) => {\n            if (value == null) return value;\n\n            if (_.isPlainObject(value) && value.oorType) {\n                // there is special input column which maybe a function or an expression\n                opOptions.$requireSplitColumns = true;\n                return value;\n            }\n\n            const fieldInfo = fields[key];\n\n            return this._serializeByTypeInfo(value, fieldInfo);\n        });\n\n        return context;\n    }\n\n    /**\n     * Ensure commit or rollback is called if transaction is created within the executor.\n     * @param {*} executor\n     * @param {*} context\n     */\n    static async _safeExecute_(executor, context) {\n        executor = executor.bind(this);\n\n        if (context.connOptions && context.connOptions.connection) {\n            return executor(context);\n        }\n\n        try {\n            const result = await executor(context);\n\n            // if the executor have initiated a transaction\n            if (context.connOptions && context.connOptions.connection) {\n                await this.db.connector.commit_(context.connOptions.connection);\n                delete context.connOptions.connection;\n            }\n\n            return result;\n        } catch (error) {\n            // we have to rollback if error occurred in a transaction\n            if (context.connOptions && context.connOptions.connection) {\n                this.db.connector.log(\n                    'error',\n                    `Rollbacked, reason: ${error.message}`,\n                    {\n                        entity: this.meta.name,\n                        context: context.options,\n                        rawData: context.raw,\n                        latestData: context.latest,\n                    }\n                );\n                await this.db.connector.rollback_(\n                    context.connOptions.connection\n                );\n                delete context.connOptions.connection;\n            }\n\n            throw error;\n        }\n    }\n\n    static _dependencyChanged(fieldName, context) {\n        if (this.meta.fieldDependencies) {\n            const deps = this.meta.fieldDependencies[fieldName];\n\n            return _.find(deps, (d) =>\n                _.isPlainObject(d)\n                    ? (d.reference !== fieldName && _.hasIn(context, d.reference))\n                    : _.hasIn(context, d)\n            );\n        }\n\n        return false;\n    }\n\n    static _referenceExist(input, ref) {\n        const pos = ref.indexOf('.');\n\n        if (pos > 0) {\n            return ref.substr(pos + 1) in input;\n        }\n\n        return ref in input;\n    }\n\n    static _dependsOnExistingData(input) {\n        // check modifier dependencies\n        const deps = this.meta.fieldDependencies;\n        let hasDepends = false;\n\n        if (deps) {\n            const nullDepends = new Set();\n\n            hasDepends = _.find(deps, (dep, fieldName) =>\n                _.find(dep, (d) => {\n                    if (_.isPlainObject(d)) {\n                        if (d.whenNull) {\n                            if (_.isNil(input[fieldName])) {\n                                nullDepends.add(dep);\n                            }\n\n                            return false;\n                        }\n\n                        if (d.reference === fieldName) return false;\n\n                        d = d.reference;\n                    }\n\n                    return (\n                        fieldName in input && !this._referenceExist(input, d)\n                    ) || (this._referenceExist(input, d) && !(fieldName in input));\n                })\n            );\n\n            if (hasDepends) {\n                return true;\n            }\n\n            for (const dep of nullDepends) {\n                if (\n                    _.find(\n                        dep,\n                        (d) => !this._referenceExist(input, d.reference)\n                    )\n                ) {\n                    return true;\n                }\n            }\n        }\n\n        // check by special rules\n        const atLeastOneNotNull = this.meta.features.atLeastOneNotNull;\n        if (atLeastOneNotNull) {\n            hasDepends = _.find(atLeastOneNotNull, (fields) =>\n                _.find(\n                    fields,\n                    (field) => field in input && _.isNil(input[field])\n                )\n            );\n            if (hasDepends) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    static _hasReservedKeys(obj) {\n        return _.find(obj, (v, k) => k[0] === '$');\n    }\n\n    /**\n     * Normalize options including moving entries with key not starting with '$' into $query, interpolating variables and building relationship structure.\n     * @param {object} options \n     * @param {boolean} [forSingleRecord=false]\n     * @returns {object}\n     */\n    static _prepareQueries(options, forSingleRecord = false) {\n        excludeColumn(this, this.meta, options);\n\n        if (!_.isPlainObject(options)) {\n            if (forSingleRecord && Array.isArray(this.meta.keyField)) {\n                throw new InvalidArgument(\n                    'Cannot use a singular value as condition to query against an entity with combined primary key.',\n                    {\n                        entity: this.meta.name,\n                        keyFields: this.meta.keyField,\n                    }\n                );\n            }\n\n            return options\n                ? {\n                    $query: {\n                        [this.meta.keyField]: this._translateValue(options),\n                    },\n                }\n                : {};\n        }\n\n        const normalizedOptions = { $key: this.meta.keyField };\n        const query = {};\n\n        _.forOwn(options, (v, k) => {\n            if (k[0] === '$') {\n                normalizedOptions[k] = v;\n            } else {\n                query[k] = v;\n            }\n        });\n\n        normalizedOptions.$query = { ...query, ...normalizedOptions.$query };\n\n        if (forSingleRecord && !options.$bypassEnsureUnique) {\n            this._ensureContainsUniqueKey(normalizedOptions.$query);\n        }\n\n        normalizedOptions.$query = this._translateValue(\n            normalizedOptions.$query,\n            normalizedOptions.$variables,\n            null,\n            true\n        );\n\n        if (normalizedOptions.$groupBy) {\n            if (_.isPlainObject(normalizedOptions.$groupBy)) {\n                if (normalizedOptions.$groupBy.having) {\n                    normalizedOptions.$groupBy.having = this._translateValue(\n                        normalizedOptions.$groupBy.having,\n                        normalizedOptions.$variables\n                    );\n                }\n            }\n        }\n\n        if (normalizedOptions.$projection) {\n            normalizedOptions.$projection = this._translateValue(\n                normalizedOptions.$projection,\n                normalizedOptions.$variables\n            );\n        }\n\n        if (\n            normalizedOptions.$association &&\n            !normalizedOptions.$relationships\n        ) {\n            normalizedOptions.$relationships =\n                this._prepareAssociations(normalizedOptions);\n        }\n\n        return normalizedOptions;\n    }\n\n    /**\n     * Pre create processing, return false to stop upcoming operation.\n     * @param {*} context\n     */\n    static async beforeCreate_(context) {\n        return true;\n    }\n\n    /**\n     * Pre update processing, return false to stop upcoming operation.\n     * @param {*} context\n     */\n    static async beforeUpdate_(context) {\n        return true;\n    }\n\n    /**\n     * Pre update processing, multiple records, return false to stop upcoming operation.\n     * @param {*} context\n     */\n    static async beforeUpdateMany_(context) {\n        return true;\n    }\n\n    /**\n     * Pre delete processing, return false to stop upcoming operation.\n     * @param {*} context\n     */\n    static async beforeDelete_(context) {\n        return true;\n    }\n\n    /**\n     * Pre delete processing, multiple records, return false to stop upcoming operation.\n     * @param {*} context\n     */\n    static async beforeDeleteMany_(context) {\n        return true;\n    }\n\n    /**\n     * Post create processing.\n     * @param {*} context\n     */\n    static async afterCreate_(context) {}\n\n    /**\n     * Post update processing.\n     * @param {*} context\n     */\n    static async afterUpdate_(context) {}\n\n    /**\n     * Post update processing, multiple records\n     * @param {*} context\n     */\n    static async afterUpdateMany_(context) {}\n\n    /**\n     * Post delete processing.\n     * @param {*} context\n     */\n    static async afterDelete_(context) {}\n\n    /**\n     * Post delete processing, multiple records\n     * @param {*} context\n     */\n    static async afterDeleteMany_(context) {}\n\n    /**\n     * Post findAll processing\n     * @param {*} context\n     * @param {*} records\n     */\n    static async afterFindAll_(context, records) {\n        if (context.options.$toDictionary) {\n            let keyField = this.meta.keyField;\n\n            if (typeof context.options.$toDictionary === 'string') {\n                keyField = context.options.$toDictionary;\n\n                if (!(keyField in this.meta.fields)) {\n                    throw new InvalidArgument(\n                        `The key field \"${keyField}\" provided to index the cached dictionary is not a field of entity \"${this.meta.name}\".`,\n                        {\n                            entity: this.meta.name,\n                            inputKeyField: keyField,\n                        }\n                    );\n                }\n            }\n\n            return this.toDictionary(records, keyField);\n        }\n\n        return records;\n    }\n\n    static _prepareAssociations() {\n        throw new Error(NEED_OVERRIDE);\n    }\n\n    static _mapRecordsToObjects() {\n        throw new Error(NEED_OVERRIDE);\n    }\n\n    static _extractAssociations(data) {\n        throw new Error(NEED_OVERRIDE);\n    }\n\n    // will update context.raw if applicable\n    static async _populateReferences_(context, references) {\n        throw new Error(NEED_OVERRIDE);\n    }\n\n    // will update context.raw if applicable\n    static async _createAssocs_(context, assocs) {\n        throw new Error(NEED_OVERRIDE);\n    }\n\n    static async _updateAssocs_(context, assocs) {\n        throw new Error(NEED_OVERRIDE);\n    }\n\n    static _translateSymbolToken(name) {\n        throw new Error(NEED_OVERRIDE);\n    }\n\n    static _serializeByTypeInfo(value, info) {\n        throw new Error(NEED_OVERRIDE);\n    }\n\n    static _translateValue(value, variables, skipTypeCast, arrayToInOperator) {\n        if (_.isPlainObject(value)) {\n            if (value.oorType) {\n                if (oorTypesToBypass.has(value.oorType)) return value;\n\n                if (value.oorType === 'SessionVariable') {\n                    if (!variables) {\n                        throw new InvalidArgument(\n                            'Variables context missing.',\n                            {\n                                entity: this.meta.name,\n                            }\n                        );\n                    }\n\n                    if (\n                        (!variables.session ||\n                            !(value.name in variables.session)) &&\n                        !value.optional\n                    ) {\n                        const errArgs = [];\n                        if (value.missingMessage) {\n                            errArgs.push(value.missingMessage);\n                        }\n                        if (value.missingStatus) {\n                            errArgs.push(\n                                value.missingStatus || HttpCode.BAD_REQUEST\n                            );\n                        }\n\n                        throw new ValidationError(...errArgs);\n                    }\n\n                    return variables.session[value.name];\n                } else if (value.oorType === 'QueryVariable') {\n                    if (!variables) {\n                        throw new InvalidArgument(\n                            'Variables context missing.',\n                            {\n                                entity: this.meta.name,\n                            }\n                        );\n                    }\n\n                    if (!variables.query || !(value.name in variables.query)) {\n                        throw new InvalidArgument(\n                            `Query parameter \"${value.name}\" in configuration not found.`,\n                            {\n                                entity: this.meta.name,\n                            }\n                        );\n                    }\n\n                    return variables.query[value.name];\n                } else if (value.oorType === 'SymbolToken') {\n                    return this._translateSymbolToken(value.name);\n                }\n\n                throw new Error('Not implemented yet. ' + value.oorType);\n            }\n\n            return _.mapValues(value, (v, k) =>\n                this._translateValue(\n                    v,\n                    variables,\n                    skipTypeCast,\n                    arrayToInOperator && k[0] !== '$'\n                )\n            );\n        }\n\n        if (Array.isArray(value)) {\n            const ret = value.map((v) =>\n                this._translateValue(\n                    v,\n                    variables,\n                    skipTypeCast,\n                    arrayToInOperator\n                )\n            );\n            return arrayToInOperator ? { $in: ret } : ret;\n        }\n\n        if (skipTypeCast) return value;\n\n        return this.db.connector.typeCast(value);\n    }\n}\n\nmodule.exports = EntityModel;\n"],"mappings":"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"}