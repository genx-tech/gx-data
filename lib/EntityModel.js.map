{"version":3,"sources":["../src/EntityModel.js"],"names":["HttpCode","require","_","eachAsync_","Errors","Generators","Convertors","Types","ValidationError","DatabaseError","InvalidArgument","Features","Rules","isNothing","hasValueIn","JES","NEED_OVERRIDE","minifyAssocs","assocs","sorted","uniq","sort","reverse","minified","take","l","length","i","k","find","a","startsWith","push","oorTypesToBypass","Set","EntityModel","constructor","rawData","Object","assign","valueOfKey","data","meta","keyField","fieldSchema","name","extra","fields","schema","omit","$addEnumValues","others","type","ENUM","values","concat","inputSchema","inputSetName","options","key","JSON","stringify","_cachedSchema","cache","schemaGenerator","db","getUniqueKeyFieldsFrom","uniqueKeys","every","f","isNil","getUniqueKeyValuePairsFrom","ukFields","pick","getNestedObject","entityObj","keyPath","defaultValue","nodes","Array","isArray","split","map","get","ensureRetrieveCreated","context","customOptions","$retrieveCreated","ensureRetrieveUpdated","$retrieveUpdated","ensureRetrieveDeleted","$retrieveDeleted","ensureTransaction_","connOptions","connection","connector","beginTransaction_","getValueFromContext","cached_","associations","combinedKey","isEmpty","join","cachedData","_cachedData","findAll_","$association","$toDictionary","toDictionary","entityCollection","transformer","toKVPairs","findOne_","findOptions","rawOptions","_prepareQueries","op","applyRules_","RULE_BEFORE_FIND","result","_safeExecute_","records","find_","$retrieveDbResult","$result","slice","$relationships","$skipOrm","undefined","_mapRecordsToObjects","$nestedKeyGetter","log","entity","$transformer","evaluate","totalCount","rows","$totalCount","afterFindAll_","row","ret","totalItems","items","$offset","offset","$limit","limit","retryCreateOnDuplicate_","dataGenerator_","maxRery","createOptions","counter","errorRet","create_","error","code","raw","references","_extractAssociations","beforeCreate_","return","success","_populateReferences_","needCreateAssocs","_createAssocs_","_prepareEntityData_","RULE_BEFORE_CREATE","_internalBeforeCreate_","$dryRun","$upsert","upsertOne_","latest","_fillResult","insertId","affectedRows","_internalAfterCreate_","queryKey","RULE_AFTER_CREATE","afterCreate_","updateOne_","updateOptions","$bypassReadOnly","reason","_update_","updateMany_","forSingleRecord","conditionFields","$query","toUpdate","beforeUpdate_","beforeUpdateMany_","needUpdateAssocs","doneUpdateAssocs","_updateAssocs_","RULE_BEFORE_UPDATE","_internalBeforeUpdate_","_internalBeforeUpdateMany_","otherOptions","update_","_internalAfterUpdate_","_internalAfterUpdateMany_","RULE_AFTER_UPDATE","afterUpdate_","afterUpdateMany_","replaceOne_","_doReplaceOne_","deleteOne_","deleteOptions","_delete_","deleteMany_","deleteAll_","$deleteAll","toDelete","beforeDelete_","beforeDeleteMany_","deletedCount","RULE_BEFORE_DELETE","_internalBeforeDelete_","_internalBeforeDeleteMany_","delete_","_internalAfterDelete_","_internalAfterDeleteMany_","RULE_AFTER_DELETE","afterDelete_","afterDeleteMany_","_containsUniqueKey","hasKeyNameOnly","hasNotNullKey","hasKeys","_ensureContainsUniqueKey","condition","containsUniqueKeyAndValue","containsUniqueKeyOnly","isUpdating","i18n","existing","$existing","opOptions","_dependsOnExistingData","$retrieveExisting","RULE_BEFORE_VALIDATION","fieldInfo","fieldName","value","useRaw","readOnly","$migration","has","freezeAfterNonDefault","Error","default","optional","isPlainObject","oorType","sanitize","stack","forceUpdate","updateByDb","hasActivator","auto","createByDb","_translateValue","$variables","RULE_AFTER_VALIDATION","$skipModifiers","applyModifiers_","mapValues","$requireSplitColumns","_serializeByTypeInfo","executor","bind","commit_","message","latestData","rollback_","_dependencyChanged","fieldDependencies","deps","d","reference","hasIn","_referenceExist","input","ref","pos","indexOf","substr","hasDepends","nullDepends","dep","whenNull","add","atLeastOneNotNull","features","field","_hasReservedKeys","obj","v","keyFields","normalizedOptions","query","forOwn","$bypassEnsureUnique","$groupBy","having","$projection","_prepareAssociations","inputKeyField","_translateSymbolToken","info","variables","skipTypeCast","arrayToInOperator","session","errArgs","missingMessage","missingStatus","BAD_REQUEST","$in","typeCast","module","exports"],"mappings":"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","sourcesContent":["const { HttpCode } = require('@genx/error');\nconst { _, eachAsync_ } = require('@genx/july');\nconst Errors = require('./utils/Errors');\nconst Generators = require('./Generators');\nconst Convertors = require('./Convertors');\nconst Types = require('./types');\nconst { ValidationError, DatabaseError, InvalidArgument } = Errors;\nconst Features = require('./entityFeatures');\nconst Rules = require('./enum/Rules');\n\nconst { isNothing, hasValueIn } = require('./utils/lang');\nconst JES = require('@genx/jes');\n\nconst NEED_OVERRIDE = 'Should be overrided by driver-specific subclass.';\n\nfunction minifyAssocs(assocs) {\n    const sorted = _.uniq(assocs).sort().reverse();\n\n    const minified = _.take(sorted, 1);\n    const l = sorted.length - 1;\n\n    for (let i = 1; i < l; i++) {\n        const k = sorted[i] + '.';\n\n        if (!_.find(minified, (a) => a.startsWith(k))) {\n            minified.push(sorted[i]);\n        }\n    }\n\n    return minified;\n}\n\nconst oorTypesToBypass = new Set([\n    'ColumnReference',\n    'Function',\n    'BinaryExpression',\n    'DataSet',\n    'SQL',\n]);\n\n/**\n * Base entity model class.\n * @class\n */\nclass EntityModel {\n    /**\n     * @param {Object} [rawData] - Raw data object\n     */\n    constructor(rawData) {\n        if (rawData) {\n            // only pick those that are fields of this entity\n            Object.assign(this, rawData);\n        }\n    }\n\n    static valueOfKey(data) {\n        return data[this.meta.keyField];\n    }\n\n    /**\n     * Get a field schema based on the metadata of the field.\n     * @param {string} name - Field name\n     * @param {object} [extra] - Extra schema options\n     * @return {object} Schema object\n     */\n    static fieldSchema(name, extra) {\n        const meta = this.meta.fields[name];\n        if (!meta) {\n            throw new InvalidArgument(\n                `Unknown field \"${name}\" of entity \"${this.meta.name}\".`\n            );\n        }\n\n        const schema = _.omit(meta, ['default']);\n        if (extra) {\n            const { $addEnumValues, ...others } = extra;\n            if (meta.type === Types.ENUM.name && $addEnumValues) {\n                schema.values = schema.values.concat($addEnumValues);\n            } \n\n            Object.assign(schema, others);\n        }\n\n        return schema;\n    }\n\n    /**\n     * Get a map of fields schema by predefined input set.\n     * @param {string} inputSetName - Input set name, predefined in geml\n     * @param {object} [options] - Input set options\n     * @return {object} Schema object\n     */\n    static inputSchema(inputSetName, options) {\n        const key =\n            inputSetName + (options == null ? '{}' : JSON.stringify(options));\n\n        if (this._cachedSchema) {\n            const cache = this._cachedSchema[key];\n            if (cache) {\n                return cache;\n            }\n        } else {\n            this._cachedSchema = {};\n        }\n\n        const schemaGenerator = this.db.require(\n            `inputs/${this.meta.name}-${inputSetName}`\n        );\n\n        return (this._cachedSchema[key] = schemaGenerator(options));\n    }\n\n    /**\n     * Get field names array of a unique key from input data.\n     * @param {object} data - Input data.\n     */\n    static getUniqueKeyFieldsFrom(data) {\n        return _.find(this.meta.uniqueKeys, (fields) =>\n            _.every(fields, (f) => !_.isNil(data[f]))\n        );\n    }\n\n    /**\n     * Get key-value pairs of a unique key from input data.\n     * @param {object} data - Input data.\n     */\n    static getUniqueKeyValuePairsFrom(data) {\n        const ukFields = this.getUniqueKeyFieldsFrom(data);\n        return _.pick(data, ukFields);\n    }\n\n    /**\n     * Get nested object of an entity.\n     * @param {*} entityObj\n     * @param {*} keyPath\n     */\n    static getNestedObject(entityObj, keyPath, defaultValue) {\n        const nodes = (\n            Array.isArray(keyPath) ? keyPath : keyPath.split('.')\n        ).map((key) => (key[0] === ':' ? key : ':' + key));\n        return _.get(entityObj, nodes, defaultValue);\n    }\n\n    /**\n     * Ensure context.latest be the just created entity.\n     * @param {*} context\n     * @param {*} customOptions\n     */\n    static ensureRetrieveCreated(context, customOptions) {\n        if (!context.options.$retrieveCreated) {\n            context.options.$retrieveCreated = customOptions || true;\n        }\n    }\n\n    /**\n     * Ensure context.latest be the just updated entity.\n     * @param {*} context\n     * @param {*} customOptions\n     */\n    static ensureRetrieveUpdated(context, customOptions) {\n        if (!context.options.$retrieveUpdated) {\n            context.options.$retrieveUpdated = customOptions || true;\n        }\n    }\n\n    /**\n     * Ensure context.exisintg be the just deleted entity.\n     * @param {*} context\n     * @param {*} customOptions\n     */\n    static ensureRetrieveDeleted(context, customOptions) {\n        if (!context.options.$retrieveDeleted) {\n            context.options.$retrieveDeleted = customOptions || true;\n        }\n    }\n\n    /**\n     * Ensure the upcoming operations are executed in a transaction.\n     * @param {*} context\n     */\n    static async ensureTransaction_(context) {\n        if (!context.connOptions || !context.connOptions.connection) {\n            context.connOptions || (context.connOptions = {});\n\n            context.connOptions.connection =\n                await this.db.connector.beginTransaction_();\n        }\n    }\n\n    /**\n     * Get value from context, e.g. session, query ...\n     * @param {*} context\n     * @param {string} key\n     * @returns {*}\n     */\n    static getValueFromContext(context, key) {\n        return _.get(context, 'options.$variables.' + key);\n    }\n\n    /**\n     * Get a pk-indexed hashtable with all undeleted data\n     * {string} [key] - The key field to used by the hashtable.\n     * {array} [associations] - With an array of associations.\n     * {object} [connOptions] - Connection options, e.g. transaction handle\n     */\n    static async cached_(key, associations, connOptions) {\n        if (key) {\n            let combinedKey = key;\n\n            if (!_.isEmpty(associations)) {\n                combinedKey += '/' + minifyAssocs(associations).join('&');\n            }\n\n            let cachedData;\n\n            if (!this._cachedData) {\n                this._cachedData = {};\n            } else if (this._cachedData[combinedKey]) {\n                cachedData = this._cachedData[combinedKey];\n            }\n\n            if (!cachedData) {\n                cachedData = this._cachedData[combinedKey] =\n                    await this.findAll_(\n                        { $association: associations, $toDictionary: key },\n                        connOptions\n                    );\n            }\n\n            return cachedData;\n        }\n\n        return this.cached_(this.meta.keyField, associations, connOptions);\n    }\n\n    static toDictionary(entityCollection, key, transformer) {\n        key || (key = this.meta.keyField);\n\n        return Convertors.toKVPairs(entityCollection, key, transformer);\n    }\n\n    /**\n     * Find one record, returns a model object containing the record or undefined if nothing found.\n     * @param {object|array} condition - Query condition, key-value pair will be joined with 'AND', array element will be joined with 'OR'.\n     * @param {object} [findOptions] - findOptions\n     * @property {object} [findOptions.$association] - Joinings\n     * @property {object} [findOptions.$projection] - Selected fields\n     * @property {object} [findOptions.$transformer] - Transform fields before returning\n     * @property {object} [findOptions.$query] - Extra condition\n     * @property {object} [findOptions.$groupBy] - Group by fields\n     * @property {object} [findOptions.$orderBy] - Order by fields\n     * @property {number} [findOptions.$offset] - Offset\n     * @property {number} [findOptions.$limit] - Limit\n     * @property {bool} [findOptions.$includeDeleted=false] - Include those marked as logical deleted.\n     * @param {object} [connOptions]\n     * @property {object} [connOptions.connection]\n     * @returns {*}\n     */\n    static async findOne_(findOptions, connOptions) {\n        const rawOptions = findOptions;\n\n        findOptions = this._prepareQueries(\n            findOptions,\n            true /* for single record */\n        );\n\n        const context = {\n            op: 'find',\n            options: findOptions,\n            connOptions,\n        };\n\n        await Features.applyRules_(Rules.RULE_BEFORE_FIND, this, context);\n\n        const result = await this._safeExecute_(async (context) => {\n            let records = await this.db.connector.find_(\n                this.meta.name,\n                context.options,\n                context.connOptions\n            );\n            if (!records)\n                throw new DatabaseError(\n                    'connector.find_() returns undefined data record.'\n                );\n\n            if (rawOptions && rawOptions.$retrieveDbResult) {\n                rawOptions.$result = records.slice(1);\n            }\n\n            if (findOptions.$relationships && !findOptions.$skipOrm) {\n                // rows, coloumns, aliasMap\n                if (records[0].length === 0) return undefined;\n\n                records = this._mapRecordsToObjects(\n                    records,\n                    findOptions.$relationships,\n                    findOptions.$nestedKeyGetter\n                );\n            } else if (records.length === 0) {\n                return undefined;\n            }\n\n            if (records.length !== 1) {\n                this.db.connector.log(\n                    'error',\n                    `findOne() returns more than one record.`,\n                    { entity: this.meta.name, options: context.options }\n                );\n            }\n\n            const result = records[0];\n\n            return result;\n        }, context);\n\n        if (findOptions.$transformer) {\n            return JES.evaluate(result, findOptions.$transformer);\n        }\n\n        return result;\n    }\n\n    /**\n     * Find records matching the condition, returns an array of records.\n     * @param {object} [findOptions] - findOptions\n     * @property {object} [findOptions.$association] - Joinings\n     * @property {object} [findOptions.$projection] - Selected fields\n     * @property {object} [findOptions.$transformer] - Transform fields before returning\n     * @property {object} [findOptions.$query] - Extra condition\n     * @property {object} [findOptions.$groupBy] - Group by fields\n     * @property {object} [findOptions.$orderBy] - Order by fields\n     * @property {number} [findOptions.$offset] - Offset\n     * @property {number} [findOptions.$limit] - Limit\n     * @property {number} [findOptions.$totalCount] - Return totalCount\n     * @property {bool} [findOptions.$includeDeleted=false] - Include those marked as logical deleted.\n     * @param {object} [connOptions]\n     * @property {object} [connOptions.connection]\n     * @returns {array}\n     */\n    static async findAll_(findOptions, connOptions) {\n        const rawOptions = findOptions;\n\n        findOptions = this._prepareQueries(findOptions);\n\n        const context = {\n            op: 'find',\n            options: findOptions,\n            connOptions,\n        };\n\n        await Features.applyRules_(Rules.RULE_BEFORE_FIND, this, context);\n\n        let totalCount;\n\n        let rows = await this._safeExecute_(async (context) => {\n            let records = await this.db.connector.find_(\n                this.meta.name,\n                context.options,\n                context.connOptions\n            );\n\n            if (!records)\n                throw new DatabaseError(\n                    'connector.find_() returns undefined data record.'\n                );\n\n            if (rawOptions && rawOptions.$retrieveDbResult) {\n                rawOptions.$result = records.slice(1);\n            }\n\n            if (findOptions.$relationships) {\n                if (findOptions.$totalCount) {\n                    totalCount = records[3];\n                }\n\n                if (!findOptions.$skipOrm) {\n                    records = this._mapRecordsToObjects(\n                        records,\n                        findOptions.$relationships,\n                        findOptions.$nestedKeyGetter\n                    );\n                } else {\n                    records = records[0];\n                }\n            } else {\n                if (findOptions.$totalCount) {\n                    totalCount = records[1];\n                    records = records[0];\n                } else if (findOptions.$skipOrm) {\n                    records = records[0];\n                }\n            }\n\n            return this.afterFindAll_(context, records);\n        }, context);\n\n        if (findOptions.$transformer) {\n            rows = rows.map((row) =>\n                JES.evaluate(row, findOptions.$transformer)\n            );\n        }\n\n        if (findOptions.$totalCount) {\n            const ret = { totalItems: totalCount, items: rows };\n\n            if (!isNothing(findOptions.$offset)) {\n                ret.offset = findOptions.$offset;\n            }\n\n            if (!isNothing(findOptions.$limit)) {\n                ret.limit = findOptions.$limit;\n            }\n\n            return ret;\n        }\n\n        return rows;\n    }\n\n    /**\n     * Regenerate creation data and try again if duplicate record exists\n     * @param {Function} dataGenerator_\n     * @param {Object} connOptions\n     */\n    static async retryCreateOnDuplicate_(\n        dataGenerator_,\n        maxRery,\n        createOptions,\n        connOptions\n    ) {\n        let counter = 0;\n        let errorRet;\n        maxRery || (maxRery = 10);\n\n        while (counter++ < maxRery) {\n            const data = await dataGenerator_();\n\n            try {\n                return await this.create_(data, createOptions, connOptions);\n            } catch (error) {\n                if (error.code !== 'E_DUPLICATE') {\n                    throw error;\n                }\n\n                errorRet = error;\n            }\n        }\n\n        return errorRet;\n    }\n\n    /**\n     * Create a new entity with given data.\n     * @param {object} data - Entity data\n     * @param {object} [createOptions] - Create options\n     * @property {bool} [createOptions.$retrieveCreated=false] - Retrieve the newly created record from db.\n     * @property {bool} [createOptions.$upsert=false] - If already exist, just update the record.\n     * @param {object} [connOptions]\n     * @property {object} [connOptions.connection]\n     * @returns {EntityModel}\n     */\n    static async create_(data, createOptions, connOptions) {\n        const rawOptions = createOptions;\n\n        if (!createOptions) {\n            createOptions = {};\n        }\n\n        let [raw, associations, references] = this._extractAssociations(\n            data,\n            true\n        );\n\n        const context = {\n            op: 'create',\n            raw,\n            rawOptions,\n            options: createOptions,\n            connOptions,\n        };\n\n        if (!(await this.beforeCreate_(context))) {\n            return context.return;\n        }\n\n        const success = await this._safeExecute_(async (context) => {\n            if (!_.isEmpty(references)) {\n                await this.ensureTransaction_(context);\n                await this._populateReferences_(context, references);\n            }\n\n            let needCreateAssocs = !_.isEmpty(associations);\n            if (needCreateAssocs) {\n                await this.ensureTransaction_(context);\n\n                associations = await this._createAssocs_(\n                    context,\n                    associations,\n                    true /* before create */\n                );\n                // check any other associations left\n                needCreateAssocs = !_.isEmpty(associations);\n            }\n\n            await this._prepareEntityData_(context);\n\n            if (\n                !(await Features.applyRules_(\n                    Rules.RULE_BEFORE_CREATE,\n                    this,\n                    context\n                ))\n            ) {\n                return false;\n            }\n\n            if (!(await this._internalBeforeCreate_(context))) {\n                return false;\n            }\n\n            if (!context.options.$dryRun) {\n                if (context.options.$upsert) {\n                    context.result = await this.db.connector.upsertOne_(\n                        this.meta.name,\n                        context.latest,\n                        this.getUniqueKeyFieldsFrom(context.latest),\n                        context.connOptions,\n                        context.options.$upsert\n                    );\n                } else {\n                    context.result = await this.db.connector.create_(\n                        this.meta.name,\n                        context.latest,\n                        context.connOptions\n                    );\n                }\n\n                this._fillResult(context);\n            } else {\n                context.return = context.latest;\n                context.result = { insertId: context.latest[this.meta.keyField], affectedRows: 1 };\n            }\n\n            if (needCreateAssocs) {\n                await this._createAssocs_(context, associations);\n            }\n\n            await this._internalAfterCreate_(context);\n\n            if (!context.queryKey) {\n                context.queryKey = this.getUniqueKeyValuePairsFrom(\n                    context.latest\n                );\n            }\n\n            await Features.applyRules_(Rules.RULE_AFTER_CREATE, this, context);\n\n            return true;\n        }, context);\n\n        if (success) {\n            await this.afterCreate_(context);\n        }\n\n        return context.return;\n    }\n\n    /**\n     * Update an existing entity with given data.\n     * @param {object} data - Entity data with at least one unique key (pair) given\n     * @param {object} [updateOptions] - Update options\n     * @property {object} [updateOptions.$query] - Extra condition\n     * @property {bool} [updateOptions.$retrieveUpdated=false] - Retrieve the updated entity from database\n     * @param {object} [connOptions]\n     * @property {object} [connOptions.connection]\n     * @returns {object}\n     */\n    static async updateOne_(data, updateOptions, connOptions) {\n        if (updateOptions && updateOptions.$bypassReadOnly) {\n            throw new InvalidArgument('Unexpected usage.', {\n                entity: this.meta.name,\n                reason: '$bypassReadOnly option is not allow to be set from public update_ method.',\n                updateOptions,\n            });\n        }\n\n        return this._update_(data, updateOptions, connOptions, true);\n    }\n\n    /**\n     * Update many existing entites with given data.\n     * @param {*} data\n     * @param {*} updateOptions\n     * @param {*} connOptions\n     */\n    static async updateMany_(data, updateOptions, connOptions) {\n        if (updateOptions && updateOptions.$bypassReadOnly) {\n            throw new InvalidArgument('Unexpected usage.', {\n                entity: this.meta.name,\n                reason: '$bypassReadOnly option is not allow to be set from public update_ method.',\n                updateOptions,\n            });\n        }\n\n        return this._update_(data, updateOptions, connOptions, false);\n    }\n\n    static async _update_(data, updateOptions, connOptions, forSingleRecord) {\n        const rawOptions = updateOptions;\n\n        if (!updateOptions) {\n            // if no condition given, extract from data\n            const conditionFields = this.getUniqueKeyFieldsFrom(data);\n            if (_.isEmpty(conditionFields)) {\n                throw new InvalidArgument(\n                    'Primary key value(s) or at least one group of unique key value(s) is required for updating an entity.',\n                    {\n                        entity: this.meta.name,\n                        data,\n                    }\n                );\n            }\n            updateOptions = { $query: _.pick(data, conditionFields) };\n            data = _.omit(data, conditionFields);\n        }\n\n        // see if there is associated entity data provided together\n        let [raw, associations, references] = this._extractAssociations(data);\n\n        const context = {\n            op: 'update',\n            raw,\n            rawOptions,\n            options: this._prepareQueries(\n                updateOptions,\n                forSingleRecord /* for single record */\n            ),\n            connOptions,\n            forSingleRecord,\n        };\n\n        // see if there is any runtime feature stopping the update\n        let toUpdate;\n\n        if (forSingleRecord) {\n            toUpdate = await this.beforeUpdate_(context);\n        } else {\n            toUpdate = await this.beforeUpdateMany_(context);\n        }\n\n        if (!toUpdate) {\n            return context.return;\n        }\n\n        const success = await this._safeExecute_(async (context) => {\n            if (!_.isEmpty(references)) {\n                await this.ensureTransaction_(context);\n                await this._populateReferences_(context, references);\n            }\n\n            let needUpdateAssocs = !_.isEmpty(associations);\n            let doneUpdateAssocs;\n\n            if (needUpdateAssocs) {\n                await this.ensureTransaction_(context);\n\n                associations = await this._updateAssocs_(\n                    context,\n                    associations,\n                    true /* before update */,\n                    forSingleRecord\n                );\n                needUpdateAssocs = !_.isEmpty(associations);\n                doneUpdateAssocs = true;\n            }\n\n            await this._prepareEntityData_(\n                context,\n                true /* is updating */,\n                forSingleRecord\n            );\n\n            if (\n                !(await Features.applyRules_(\n                    Rules.RULE_BEFORE_UPDATE,\n                    this,\n                    context\n                ))\n            ) {\n                return false;\n            }\n\n            if (forSingleRecord) {\n                toUpdate = await this._internalBeforeUpdate_(context);\n            } else {\n                toUpdate = await this._internalBeforeUpdateMany_(context);\n            }\n\n            if (!toUpdate) {\n                return false;\n            }\n\n            const { $query, ...otherOptions } = context.options;\n\n            if (_.isEmpty(context.latest)) {\n                if (!doneUpdateAssocs && !needUpdateAssocs) {\n                    throw new InvalidArgument(\n                        'Cannot do the update with empty record. Entity: ' +\n                            this.meta.name\n                    );\n                }\n            } else {\n                if (\n                    needUpdateAssocs &&\n                    !hasValueIn([$query, context.latest], this.meta.keyField) &&\n                    !otherOptions.$retrieveUpdated\n                ) {\n                    // has associated data depending on this record\n                    // should ensure the latest result will contain the key of this record\n                    otherOptions.$retrieveUpdated = true;\n                }\n\n                context.result = await this.db.connector.update_(\n                    this.meta.name,\n                    context.latest,\n                    $query,\n                    otherOptions,\n                    context.connOptions\n                );\n\n                context.return = context.latest;\n            }\n\n            if (forSingleRecord) {\n                await this._internalAfterUpdate_(context);\n\n                if (!context.queryKey) {\n                    context.queryKey = this.getUniqueKeyValuePairsFrom($query);\n                }\n            } else {\n                await this._internalAfterUpdateMany_(context);\n            }\n\n            await Features.applyRules_(Rules.RULE_AFTER_UPDATE, this, context);\n\n            if (needUpdateAssocs) {\n                await this._updateAssocs_(\n                    context,\n                    associations,\n                    false,\n                    forSingleRecord\n                );\n            }\n\n            return true;\n        }, context);\n\n        if (success) {\n            if (forSingleRecord) {\n                await this.afterUpdate_(context);\n            } else {\n                await this.afterUpdateMany_(context);\n            }\n        }\n\n        return context.return;\n    }\n\n    /**\n     * Update an existing entity with given data, or create one if not found.\n     * @param {*} data\n     * @param {*} updateOptions\n     * @param {*} connOptions\n     */\n    static async replaceOne_(data, updateOptions, connOptions) {\n        const rawOptions = updateOptions;\n\n        if (!updateOptions) {\n            const conditionFields = this.getUniqueKeyFieldsFrom(data);\n            if (_.isEmpty(conditionFields)) {\n                throw new InvalidArgument(\n                    'Primary key value(s) or at least one group of unique key value(s) is required for replacing an entity.',\n                    {\n                        entity: this.meta.name,\n                        data,\n                    }\n                );\n            }\n\n            updateOptions = {\n                ...updateOptions,\n                $query: _.pick(data, conditionFields),\n            };\n        } else {\n            updateOptions = this._prepareQueries(updateOptions, true);\n        }\n\n        const context = {\n            op: 'replace',\n            raw: data,\n            rawOptions,\n            options: updateOptions,\n            connOptions,\n        };\n\n        return this._safeExecute_(async (context) => {\n            return this._doReplaceOne_(context); // different dbms has different replacing strategy\n        }, context);\n    }\n\n    /**\n     * Remove an existing entity with given data.\n     * @param {object} [deleteOptions] - Update options\n     * @property {object} [deleteOptions.$query] - Extra condition\n     * @property {bool} [deleteOptions.$retrieveDeleted=false] - Retrieve the deleted entity from database\n     * @property {bool} [deleteOptions.$physicalDeletion=false] - When $physicalDeletion = true, deletetion will not take into account logicaldeletion feature\n     * @param {object} [connOptions]\n     * @property {object} [connOptions.connection]\n     */\n    static async deleteOne_(deleteOptions, connOptions) {\n        return this._delete_(deleteOptions, connOptions, true);\n    }\n\n    /**\n     * Remove an existing entity with given data.\n     * @param {object} [deleteOptions] - Update options\n     * @property {object} [deleteOptions.$query] - Extra condition\n     * @property {bool} [deleteOptions.$retrieveDeleted=false] - Retrieve the deleted entity from database\n     * @property {bool} [deleteOptions.$physicalDeletion=false] - When $physicalDeletion = true, deletetion will not take into account logicaldeletion feature\n     * @property {bool} [deleteOptions.$deleteAll=false] - When $deleteAll = true, the operation will proceed even empty condition is given\n     * @param {object} [connOptions]\n     * @property {object} [connOptions.connection]\n     */\n    static async deleteMany_(deleteOptions, connOptions) {\n        return this._delete_(deleteOptions, connOptions, false);\n    }\n\n    static async deleteAll_(connOptions) {\n        return this.deleteMany_({ $deleteAll: true }, connOptions);\n    }\n\n    /**\n     * Remove an existing entity with given data.\n     * @param {object} [deleteOptions] - Update options\n     * @property {object} [deleteOptions.$query] - Extra condition\n     * @property {bool} [deleteOptions.$retrieveDeleted=false] - Retrieve the deleted entity from database\n     * @property {bool} [deleteOptions.$physicalDeletion=false] - When $physicalDeletion = true, deletetion will not take into account logicaldeletion feature\n     * @param {object} [connOptions]\n     * @property {object} [connOptions.connection]\n     */\n    static async _delete_(deleteOptions, connOptions, forSingleRecord) {\n        const rawOptions = deleteOptions;\n\n        deleteOptions = this._prepareQueries(\n            deleteOptions,\n            forSingleRecord /* for single record */\n        );\n\n        if (\n            _.isEmpty(deleteOptions.$query) &&\n            (forSingleRecord || !deleteOptions.$deleteAll)\n        ) {\n            throw new InvalidArgument(\n                'Empty condition is not allowed for deleting an entity.',\n                {\n                    entity: this.meta.name,\n                    deleteOptions,\n                }\n            );\n        }\n\n        const context = {\n            op: 'delete',\n            rawOptions,\n            options: deleteOptions,\n            connOptions,\n            forSingleRecord,\n        };\n\n        let toDelete;\n\n        if (forSingleRecord) {\n            toDelete = await this.beforeDelete_(context);\n        } else {\n            toDelete = await this.beforeDeleteMany_(context);\n        }\n\n        if (!toDelete) {\n            return context.return;\n        }\n\n        const deletedCount = await this._safeExecute_(async (context) => {\n            if (\n                !(await Features.applyRules_(\n                    Rules.RULE_BEFORE_DELETE,\n                    this,\n                    context\n                ))\n            ) {\n                return false;\n            }\n\n            if (forSingleRecord) {\n                toDelete = await this._internalBeforeDelete_(context);\n            } else {\n                toDelete = await this._internalBeforeDeleteMany_(context);\n            }\n\n            if (!toDelete) {\n                return false;\n            }\n\n            const { $query, ...otherOptions } = context.options;\n\n            context.result = await this.db.connector.delete_(\n                this.meta.name,\n                $query,\n                otherOptions,\n                context.connOptions\n            );\n\n            if (forSingleRecord) {\n                await this._internalAfterDelete_(context);\n            } else {\n                await this._internalAfterDeleteMany_(context);\n            }\n\n            if (!context.queryKey) {\n                if (forSingleRecord) {\n                    context.queryKey = this.getUniqueKeyValuePairsFrom(\n                        context.options.$query\n                    );\n                } else {\n                    context.queryKey = context.options.$query;\n                }\n            }\n\n            await Features.applyRules_(Rules.RULE_AFTER_DELETE, this, context);\n\n            return this.db.connector.deletedCount(context);\n        }, context);\n\n        if (deletedCount) {\n            if (forSingleRecord) {\n                await this.afterDelete_(context);\n            } else {\n                await this.afterDeleteMany_(context);\n            }\n        }\n\n        return context.return || deletedCount;\n    }\n\n    /**\n     * Check whether a data record contains primary key or at least one unique key pair.\n     * @param {object} data\n     */\n    static _containsUniqueKey(data) {\n        let hasKeyNameOnly = false;\n\n        const hasNotNullKey = _.find(this.meta.uniqueKeys, (fields) => {\n            const hasKeys = _.every(fields, (f) => f in data);\n            hasKeyNameOnly = hasKeyNameOnly || hasKeys;\n\n            return _.every(fields, (f) => !_.isNil(data[f]));\n        });\n\n        return [hasNotNullKey, hasKeyNameOnly];\n    }\n\n    /**\n     * Ensure the condition contains one of the unique keys.\n     * @param {*} condition\n     */\n    static _ensureContainsUniqueKey(condition) {\n        const [containsUniqueKeyAndValue, containsUniqueKeyOnly] =\n            this._containsUniqueKey(condition);\n\n        if (!containsUniqueKeyAndValue) {\n            if (containsUniqueKeyOnly) {\n                throw new ValidationError(\n                    'One of the unique key field as query condition is null. Condition: ' +\n                        JSON.stringify(condition)\n                );\n            }\n\n            throw new InvalidArgument(\n                'Single record operation requires at least one unique key value pair in the query condition.',\n                {\n                    entity: this.meta.name,\n                    condition,\n                }\n            );\n        }\n    }\n\n    /**\n     * Prepare valid and sanitized entity data for sending to database.\n     * @param {object} context - Operation context.\n     * @property {object} context.raw - Raw input data.\n     * @property {object} [context.connOptions]\n     * @param {bool} isUpdating - Flag for updating existing entity.\n     */\n    static async _prepareEntityData_(\n        context,\n        isUpdating = false,\n        forSingleRecord = true\n    ) {\n        const meta = this.meta;\n        const i18n = this.i18n;\n        const { name, fields } = meta;\n\n        const { raw } = context;\n        let latest = {};\n        // returned by $retrieveExisting\n        let existing = context.options.$existing;\n        context.latest = latest;\n\n        if (!context.i18n) {\n            context.i18n = i18n;\n        }\n\n        const opOptions = context.options;\n\n        if (\n            isUpdating &&\n            _.isEmpty(existing) &&\n            (this._dependsOnExistingData(raw) || opOptions.$retrieveExisting)\n        ) {\n            await this.ensureTransaction_(context);\n\n            if (forSingleRecord) {\n                existing = await this.findOne_(\n                    { $query: opOptions.$query },\n                    context.connOptions\n                );\n            } else {\n                existing = await this.findAll_(\n                    { $query: opOptions.$query },\n                    context.connOptions\n                );\n            }\n            context.existing = existing;\n        }\n\n        if (opOptions.$retrieveExisting && !context.rawOptions.$existing) {\n            context.rawOptions.$existing = existing;\n        }\n\n        await Features.applyRules_(Rules.RULE_BEFORE_VALIDATION, this, context);\n\n        await eachAsync_(fields, async (fieldInfo, fieldName) => {\n            let value;\n            let useRaw = false;\n\n            if (fieldName in raw) {\n                value = raw[fieldName];\n                useRaw = true;\n            } else if (fieldName in latest) {\n                value = latest[fieldName];\n            }\n\n            if (typeof value !== 'undefined') {\n                // field value given in raw data\n                if (fieldInfo.readOnly && useRaw) {\n                    if (\n                        !opOptions.$migration &&\n                        (!isUpdating ||\n                            !opOptions.$bypassReadOnly ||\n                            !opOptions.$bypassReadOnly.has(fieldName))\n                    ) {\n                        // read only, not allow to set by input value\n                        throw new ValidationError(\n                            `Read-only field \"${fieldName}\" is not allowed to be set by manual input.`,\n                            {\n                                entity: name,\n                                fieldInfo: fieldInfo,\n                            }\n                        );\n                    }\n                }\n\n                if (isUpdating && fieldInfo.freezeAfterNonDefault) {\n                    if (!existing) {\n                        throw new Error(\n                            '\"freezeAfterNonDefault\" qualifier requires existing data.'\n                        );\n                    }\n\n                    if (existing[fieldName] !== fieldInfo.default) {\n                        // freezeAfterNonDefault, not allow to change if value is non-default\n                        throw new ValidationError(\n                            `FreezeAfterNonDefault field \"${fieldName}\" is not allowed to be changed.`,\n                            {\n                                entity: name,\n                                fieldInfo: fieldInfo,\n                            }\n                        );\n                    }\n                }\n\n                /**  todo: fix dependency, check writeProtect \n                if (isUpdating && fieldInfo.writeOnce) {     \n                    assert: existing, '\"writeOnce\" qualifier requires existing data.';\n                    if (!_.isNil(existing[fieldName])) {\n                        throw new ValidationError(`Write-once field \"${fieldName}\" is not allowed to be update once it was set.`, {\n                            entity: name,\n                            fieldInfo: fieldInfo \n                        });\n                    }\n                } */\n\n                // sanitize first\n                if (isNothing(value)) {\n                    if (fieldInfo.default) {\n                        // has default setting in meta data\n                        latest[fieldName] = fieldInfo.default;\n                    } else if (!fieldInfo.optional) {\n                        throw new ValidationError(\n                            `The \"${fieldName}\" value of \"${name}\" entity cannot be null.`,\n                            {\n                                entity: name,\n                                fieldInfo: fieldInfo,\n                            }\n                        );\n                    } else {\n                        latest[fieldName] = null;\n                    }\n                } else {\n                    if (_.isPlainObject(value) && value.oorType) {\n                        latest[fieldName] = value;\n\n                        return;\n                    }\n\n                    try {\n                        latest[fieldName] = Types.sanitize(\n                            value,\n                            fieldInfo,\n                            i18n\n                        );\n                    } catch (error) {\n                        throw new ValidationError(\n                            `Invalid \"${fieldName}\" value of \"${name}\" entity.`,\n                            {\n                                entity: name,\n                                fieldInfo: fieldInfo,\n                                value,\n                                error: error.stack,\n                            }\n                        );\n                    }\n                }\n\n                return;\n            }\n\n            // not given in raw data\n            if (isUpdating) {\n                if (fieldInfo.forceUpdate) {\n                    // has force update policy, e.g. updateTimestamp\n                    if (fieldInfo.updateByDb || fieldInfo.hasActivator) {\n                        return;\n                    }\n\n                    // require generator to refresh auto generated value\n                    if (fieldInfo.auto) {                        \n                        latest[fieldName] = await Generators.default(\n                            fieldInfo,\n                            i18n\n                        );\n                        return;\n                    }\n\n                    throw new ValidationError(\n                        `Field \"${fieldName}\" of \"${name}\" entity is required for each update.`,\n                        {\n                            entity: name,\n                            fieldInfo: fieldInfo,\n                        }\n                    );\n                }\n\n                return;\n            }\n\n            // new record\n            if (!fieldInfo.createByDb) {\n                if ('default' in fieldInfo) {\n                    // has default setting in meta data\n                    latest[fieldName] = fieldInfo.default;\n                } else if (fieldInfo.optional) {\n                    // ignore\n                } else if (fieldInfo.auto) {\n                    // automatically generated\n                    latest[fieldName] = await Generators.default(\n                        fieldInfo,\n                        i18n\n                    );\n                } else if (!fieldInfo.hasActivator) {\n                    // skip those have activators\n\n                    throw new ValidationError(\n                        `Field \"${fieldName}\" of \"${name}\" entity is required.`,\n                        {\n                            entity: name,\n                            fieldInfo: fieldInfo,\n                            raw,\n                        }\n                    );\n                }\n            } // else default value set by database or by rules\n        });\n\n        latest = context.latest = this._translateValue(\n            latest,\n            opOptions.$variables,\n            true\n        );\n\n        await Features.applyRules_(Rules.RULE_AFTER_VALIDATION, this, context);\n\n        if (!opOptions.$skipModifiers) {\n            await this.applyModifiers_(context, isUpdating);\n        }\n\n        // final round process before entering database\n        context.latest = _.mapValues(latest, (value, key) => {\n            if (value == null) return value;\n\n            if (_.isPlainObject(value) && value.oorType) {\n                // there is special input column which maybe a function or an expression\n                opOptions.$requireSplitColumns = true;\n                return value;\n            }\n\n            const fieldInfo = fields[key];\n\n            return this._serializeByTypeInfo(value, fieldInfo);\n        });\n\n        return context;\n    }\n\n    /**\n     * Ensure commit or rollback is called if transaction is created within the executor.\n     * @param {*} executor\n     * @param {*} context\n     */\n    static async _safeExecute_(executor, context) {\n        executor = executor.bind(this);\n\n        if (context.connOptions && context.connOptions.connection) {\n            return executor(context);\n        }\n\n        try {\n            const result = await executor(context);\n\n            // if the executor have initiated a transaction\n            if (context.connOptions && context.connOptions.connection) {\n                await this.db.connector.commit_(context.connOptions.connection);\n                delete context.connOptions.connection;\n            }\n\n            return result;\n        } catch (error) {\n            // we have to rollback if error occurred in a transaction\n            if (context.connOptions && context.connOptions.connection) {\n                this.db.connector.log(\n                    'error',\n                    `Rollbacked, reason: ${error.message}`,\n                    {\n                        entity: this.meta.name,\n                        context: context.options,\n                        rawData: context.raw,\n                        latestData: context.latest,\n                    }\n                );\n                await this.db.connector.rollback_(\n                    context.connOptions.connection\n                );\n                delete context.connOptions.connection;\n            }\n\n            throw error;\n        }\n    }\n\n    static _dependencyChanged(fieldName, context) {\n        if (this.meta.fieldDependencies) {\n            const deps = this.meta.fieldDependencies[fieldName];\n\n            return _.find(deps, (d) =>\n                _.isPlainObject(d)\n                    ? (d.reference !== fieldName && _.hasIn(context, d.reference))\n                    : _.hasIn(context, d)\n            );\n        }\n        \n        return false;\n    }\n\n    static _referenceExist(input, ref) {\n        const pos = ref.indexOf('.');\n\n        if (pos > 0) {\n            return ref.substr(pos + 1) in input;\n        }\n\n        return ref in input;\n    }\n\n    static _dependsOnExistingData(input) {\n        // check modifier dependencies\n        const deps = this.meta.fieldDependencies;\n        let hasDepends = false;\n\n        if (deps) {\n            const nullDepends = new Set();\n\n            hasDepends = _.find(deps, (dep, fieldName) =>\n                _.find(dep, (d) => {\n                    if (_.isPlainObject(d)) {\n                        if (d.whenNull) {\n                            if (_.isNil(input[fieldName])) {\n                                nullDepends.add(dep);\n                            }\n\n                            return false;\n                        }\n\n                        if (d.reference === fieldName) return false;\n\n                        d = d.reference;\n                    }\n\n                    return (\n                        fieldName in input && !this._referenceExist(input, d)\n                    ) || (this._referenceExist(input, d) && !(fieldName in input));\n                })\n            );\n\n            if (hasDepends) {\n                return true;\n            }\n\n            for (const dep of nullDepends) {\n                if (\n                    _.find(\n                        dep,\n                        (d) => !this._referenceExist(input, d.reference)\n                    )\n                ) {\n                    return true;\n                }\n            }\n        }\n\n        // check by special rules\n        const atLeastOneNotNull = this.meta.features.atLeastOneNotNull;\n        if (atLeastOneNotNull) {\n            hasDepends = _.find(atLeastOneNotNull, (fields) =>\n                _.find(\n                    fields,\n                    (field) => field in input && _.isNil(input[field])\n                )\n            );\n            if (hasDepends) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    static _hasReservedKeys(obj) {\n        return _.find(obj, (v, k) => k[0] === '$');\n    }\n\n    static _prepareQueries(options, forSingleRecord = false) {\n        if (!_.isPlainObject(options)) {\n            if (forSingleRecord && Array.isArray(this.meta.keyField)) {\n                throw new InvalidArgument(\n                    'Cannot use a singular value as condition to query against a entity with combined primary key.',\n                    {\n                        entity: this.meta.name,\n                        keyFields: this.meta.keyField,\n                    }\n                );\n            }\n\n            return options\n                ? {\n                      $query: {\n                          [this.meta.keyField]: this._translateValue(options),\n                      },\n                  }\n                : {};\n        }\n\n        const normalizedOptions = {};\n        const query = {};\n\n        _.forOwn(options, (v, k) => {\n            if (k[0] === '$') {\n                normalizedOptions[k] = v;\n            } else {\n                query[k] = v;\n            }\n        });\n\n        normalizedOptions.$query = { ...query, ...normalizedOptions.$query };\n\n        if (forSingleRecord && !options.$bypassEnsureUnique) {\n            this._ensureContainsUniqueKey(normalizedOptions.$query);\n        }\n\n        normalizedOptions.$query = this._translateValue(\n            normalizedOptions.$query,\n            normalizedOptions.$variables,\n            null,\n            true\n        );\n\n        if (normalizedOptions.$groupBy) {\n            if (_.isPlainObject(normalizedOptions.$groupBy)) {\n                if (normalizedOptions.$groupBy.having) {\n                    normalizedOptions.$groupBy.having = this._translateValue(\n                        normalizedOptions.$groupBy.having,\n                        normalizedOptions.$variables\n                    );\n                }\n            }\n        }\n\n        if (normalizedOptions.$projection) {\n            normalizedOptions.$projection = this._translateValue(\n                normalizedOptions.$projection,\n                normalizedOptions.$variables\n            );\n        }\n\n        if (\n            normalizedOptions.$association &&\n            !normalizedOptions.$relationships\n        ) {\n            normalizedOptions.$relationships =\n                this._prepareAssociations(normalizedOptions);\n        }\n\n        return normalizedOptions;\n    }\n\n    /**\n     * Pre create processing, return false to stop upcoming operation.\n     * @param {*} context\n     */\n    static async beforeCreate_(context) {\n        return true;\n    }\n\n    /**\n     * Pre update processing, return false to stop upcoming operation.\n     * @param {*} context\n     */\n    static async beforeUpdate_(context) {\n        return true;\n    }\n\n    /**\n     * Pre update processing, multiple records, return false to stop upcoming operation.\n     * @param {*} context\n     */\n    static async beforeUpdateMany_(context) {\n        return true;\n    }\n\n    /**\n     * Pre delete processing, return false to stop upcoming operation.\n     * @param {*} context\n     */\n    static async beforeDelete_(context) {\n        return true;\n    }\n\n    /**\n     * Pre delete processing, multiple records, return false to stop upcoming operation.\n     * @param {*} context\n     */\n    static async beforeDeleteMany_(context) {\n        return true;\n    }\n\n    /**\n     * Post create processing.\n     * @param {*} context\n     */\n    static async afterCreate_(context) {}\n\n    /**\n     * Post update processing.\n     * @param {*} context\n     */\n    static async afterUpdate_(context) {}\n\n    /**\n     * Post update processing, multiple records\n     * @param {*} context\n     */\n    static async afterUpdateMany_(context) {}\n\n    /**\n     * Post delete processing.\n     * @param {*} context\n     */\n    static async afterDelete_(context) {}\n\n    /**\n     * Post delete processing, multiple records\n     * @param {*} context\n     */\n    static async afterDeleteMany_(context) {}\n\n    /**\n     * Post findAll processing\n     * @param {*} context\n     * @param {*} records\n     */\n    static async afterFindAll_(context, records) {\n        if (context.options.$toDictionary) {\n            let keyField = this.meta.keyField;\n\n            if (typeof context.options.$toDictionary === 'string') {\n                keyField = context.options.$toDictionary;\n\n                if (!(keyField in this.meta.fields)) {\n                    throw new InvalidArgument(\n                        `The key field \"${keyField}\" provided to index the cached dictionary is not a field of entity \"${this.meta.name}\".`,\n                        {\n                            entity: this.meta.name,\n                            inputKeyField: keyField,\n                        }\n                    );\n                }\n            }\n\n            return this.toDictionary(records, keyField);\n        }\n\n        return records;\n    }\n\n    static _prepareAssociations() {\n        throw new Error(NEED_OVERRIDE);\n    }\n\n    static _mapRecordsToObjects() {\n        throw new Error(NEED_OVERRIDE);\n    }\n\n    static _extractAssociations(data) {\n        throw new Error(NEED_OVERRIDE);\n    }\n\n    // will update context.raw if applicable\n    static async _populateReferences_(context, references) {\n        throw new Error(NEED_OVERRIDE);\n    }\n\n    // will update context.raw if applicable\n    static async _createAssocs_(context, assocs) {\n        throw new Error(NEED_OVERRIDE);\n    }\n\n    static async _updateAssocs_(context, assocs) {\n        throw new Error(NEED_OVERRIDE);\n    }\n\n    static _translateSymbolToken(name) {\n        throw new Error(NEED_OVERRIDE);\n    }\n\n    static _serializeByTypeInfo(value, info) {\n        throw new Error(NEED_OVERRIDE);\n    }\n\n    static _translateValue(value, variables, skipTypeCast, arrayToInOperator) {\n        if (_.isPlainObject(value)) {\n            if (value.oorType) {\n                if (oorTypesToBypass.has(value.oorType)) return value;\n\n                if (value.oorType === 'SessionVariable') {\n                    if (!variables) {\n                        throw new InvalidArgument(\n                            'Variables context missing.',\n                            {\n                                entity: this.meta.name,\n                            }\n                        );\n                    }\n\n                    if (\n                        (!variables.session ||\n                            !(value.name in variables.session)) &&\n                        !value.optional\n                    ) {\n                        const errArgs = [];\n                        if (value.missingMessage) {\n                            errArgs.push(value.missingMessage);\n                        }\n                        if (value.missingStatus) {\n                            errArgs.push(\n                                value.missingStatus || HttpCode.BAD_REQUEST\n                            );\n                        }\n\n                        throw new ValidationError(...errArgs);\n                    }\n\n                    return variables.session[value.name];\n                } else if (value.oorType === 'QueryVariable') {\n                    if (!variables) {\n                        throw new InvalidArgument(\n                            'Variables context missing.',\n                            {\n                                entity: this.meta.name,\n                            }\n                        );\n                    }\n\n                    if (!variables.query || !(value.name in variables.query)) {\n                        throw new InvalidArgument(\n                            `Query parameter \"${value.name}\" in configuration not found.`,\n                            {\n                                entity: this.meta.name,\n                            }\n                        );\n                    }\n\n                    return variables.query[value.name];\n                } else if (value.oorType === 'SymbolToken') {\n                    return this._translateSymbolToken(value.name);\n                }\n\n                throw new Error('Not implemented yet. ' + value.oorType);\n            }\n\n            return _.mapValues(value, (v, k) =>\n                this._translateValue(\n                    v,\n                    variables,\n                    skipTypeCast,\n                    arrayToInOperator && k[0] !== '$'\n                )\n            );\n        }\n\n        if (Array.isArray(value)) {\n            const ret = value.map((v) =>\n                this._translateValue(\n                    v,\n                    variables,\n                    skipTypeCast,\n                    arrayToInOperator\n                )\n            );\n            return arrayToInOperator ? { $in: ret } : ret;\n        }\n\n        if (skipTypeCast) return value;\n\n        return this.db.connector.typeCast(value);\n    }\n}\n\nmodule.exports = EntityModel;\n"],"file":"EntityModel.js"}